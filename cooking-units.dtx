% \iffalse  meta-comment
% !TEX encoding = UTF-8 Unicode
% !TEX program  = pdfLaTeX
%^^A PdfLaTeX-dev
%
%<*internal>
\iffalse
%</internal>
%<*readme>

cooking-units
=============

Overview
--------

While writing a cookery book, units and their format can be quite
troublesome. This contains not only the question of how to print those
units, but also the question of the conversion of units. A cookery
book doesn't contain only SI units, it contains a much more colorful
range of units (kg, dag, g, oz, ... for example) and it may cause
some confusion if too many different units are used, but if you just
write a cookery book for fun you don't think about this ... until
someone (my mother in my case) tells you that it's too confusing.
 
This package solves both problems: It formats your input and you have
the option to convert the units globally or locally using an easy to
use key-value system.

Please note that this package is not intended to be used to print
units (and numbers) physically correct. It should be used for more
light-hearted stuff (like a cookery book for example).

Requirements 
------------

 * expl3 & xparse
 * translations
 * xfrac
 * l3keys2e
 * fmtcount (optional)
 

This file contains
------------------

 * README
 * cooking-units.pdf
 * cooking-units.dtx
 * cooking-units.ins

Changes
-------

See section 'Change History' in the documentation.

Supported Languages
-------------------

* German
* English
* French (suboptimal)

License
-------
This material is subject to the LaTeX Project Public License 1.3c or later. See

  https://www.latex-project.org/lppl/

for the details of that license.

%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
%\keepsilent
\askforoverwritefalse
\preamble
Copyright (C) 2016--2020 by Ben Vitecek (current Maintainer)

This file may be distributed and/or modified under the 
conditions of the LaTeX Project Public License, either 
version 1.3c of this license or (at your option) any later 
version. The latest version of this license is in: 

        https://www.latex-project.org/lppl/

and version 1.3c or later is part of all distributions of 
LaTeX version 2008-05-04 or later. 

This work has the LPPL maintenance status `maintained'.

This work consists of the files README.md, cooking-units.dtx and cooking-units.ins
and the derived file cooking-units.sty.

\endpreamble
%\postamble


%\endpostamble
\usedir{tex/latex/cooking-units}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/cooking-units}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble 
\usedir{doc/latex/cooking-units}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver> 
\documentclass[
        ngerman,
        french,
        english, %french, naustrian
        onlydoc,
%        check-declarations,
]{l3doc}
\usepackage[utf8]{inputenc}
\usepackage[main=english]{babel}
\usepackage[use-fmtcount-numerals=true]{cooking-units}
\usepackage{tikzsymbols}
\usepackage{listings}
\usepackage{environ}
\usepackage{nicefrac}
\usepackage{cleveref}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{totalcount}
\usepackage{microtype}
\usepackage{enumitem}


\newcounter{CookingUnitsCounter}
\newcounter{cunumCounter}
\newcounter{cuamCounter}
\newcounter{cutextCounter}
\newcounter{CutextCounter}
\DeclareTotalCounter{CookingUnitsCounter}
\DeclareTotalCounter{cunumCounter}
\DeclareTotalCounter{cuamCounter}
\DeclareTotalCounter{cutextCounter}
\DeclareTotalCounter{CutextCounter}

\babeltags{myde = ngerman}

\DeclareSIUnit{\ounce}{oz}
\DeclareSIUnit{\oz}{\ounce}
\DeclareSIUnit{\pound}{lb}
\DeclareSIUnit{\lb}{\pound}
\DeclareSIUnit{\stone}{st}
\DeclareSIUnit{\st}{\stone}
\DeclareSIUnit{\stick}{st}
\DeclareSIUnit{\inch}{in}
\cusetup{print-numerals=false}

%\EnableCrossrefs

\newcommand\US{$^{\mathrm{U.S.}}$}



\ExplSyntaxOn

\NewDocumentCommand \cookingunitsToDo { m }
  {
    \marginpar { \textcolor{red}{#1} }
  }
\NewDocumentCommand \cookingunitsTODO { m } { \cookingunitsToDo {#1} }
\NewDocumentCommand \cookingunitsContinue {  } { \cookingunitsToDo {Continue} }
\NewDocumentCommand \cookingunitsCONTINUE {  } { \cookingunitsContinue }
\NewDocumentCommand \cookingunitsChecked {  }
  {
    \cookingunitsToDo{Checked}
  }


\clist_new:N \l_cookingunits_list_of_defined_befehlen_clist
\clist_set:Nn \l_cookingunits_list_of_defined_befehlen_clist
  {
    cunum,
    cutext,
    Cutext,
    cuam,
    newcookingunit,
    declarecookingunit,
    providecookingunit,
    cudefinename,
    cudefinesymbol,
    cusetup,
    cudefinekeys,
    cudefinesinglekey,
    cuaddkeys,
    cuaddsinglekeys,
    cuaddtokeys,
    culabel,
    curef,
    cudefinephrase,
    declarecookingderivatives , 
    cufrac ,
    cusetoptionfor, cuaddoptionfor, cuclearoptionfor,
    cudeclareunitgroup, cuaddtounitgroup, cuclearunitgroup
  }

\NewDocumentCommand \mycs { m }
  {
    \clist_if_in:NnTF \l_cookingunits_list_of_defined_befehlen_clist {#1}
      { 
        \cs_if_exist:cTF {#1}
          { \cs{\textcolor{blue}{#1}} }
          { \tl_show:n {#1}\mycsERRORII }
      }
      { \tl_show:n {#1} \mycsERROR }
  }
\newcommand\opt{\texttt}
\newcommand\myunit{\texttt}
\newcommand\mygroup{\texttt}
\newcommand\myaarg[1]{\texttt{<}\meta{#1}\texttt{>}}
\newcommand\true{\opt{true}}
\newcommand\false{\opt{false}}

%: \PrintUnit
\NewDocumentCommand \PrintUnit { o m }
  {
    \__cookingunits_culang_let:nnN { name } {#2} \l_tmpa_tl
    \tl_if_eq:NNF \l_tmpa_tl \q__cookingunits_no_translation
      { \l_tmpa_tl }
    \IfNoValueF {#1} {#1}
    &
    \PrintUnitSymbol {#2}
  }
\NewDocumentCommand \PrintUnitSymbol { m }
  {
    \texttt {#1} & 
    \tl_use:c { l__cookingunits_default_unit_ #1 _tl }
  }
\NewDocumentCommand \PrintGroup { m }
  {
    \mygroup {#1} & 
    \texttt{\seq_use:cn { l__cookingunits_group_ #1 _seq } { \textrm{,~} }}
  }

\NewDocumentCommand \DeactivateForbiddenUnitError { }
  {
    \msg_redirect_name:nnn { cooking-units } { curef-forbidden-unit } { warning }
  }

%% Allyourwhitespacearebelongtous (too long)
%% 42
%% Miep!
%% Ducks
\NewDocumentCommand \dothewhitespace { O{ cup~of~tea } }
  {
    \textcolor{white} {#1} \\
  }
\newcommand\eatthewhitespace{}
\NewEnviron { cuexamplecode }[1][]
  { 
    \begin{center}
    \begin{minipage}{0.4\linewidth}
      \hbadness=10000
      \tl_replace_all:Nnn \BODY { @ } { \dothewhitespace }
      \tl_replace_all:Nnn \BODY { \% } { \color{red} \% \ignorespaces }
      \tl_replace_all:Nnn \BODY { \\ } { \\ \color{black} }
      \tl_replace_all:Nnn \BODY { & } { \ignorespaces }
      \BODY
    \end{minipage}
    
    #1
    \int_zero:N \l_tmpa_int
    \begin{minipage}{0.5\linewidth}
    \hbadness=10000
    \ttfamily
    \tl_set_rescan:Nno \l_tmpa_tl
      {
        \char_set_catcode_other:N \{ %
        \char_set_catcode_other:N \} %
        \char_set_catcode_other:N \_ %
        \char_set_catcode_other:N \~ %
      }
      { \BODY }
    \tl_map_inline:Nn \l_tmpa_tl
      {
        \token_if_cs:NTF ##1
          { 
            \cs_if_eq:NNTF ##1 \\ 
              { \textbackslash\textbackslash \\  } 
              { \textbackslash \textcolor{blue}{\cs_to_str:N ##1} }
          }{
            \token_if_letter:NTF ##1
              {##1}
              {
                \str_case:nnF {##1}
                  {
                    { @ } { \\ }
                    { & } { \space }
                  }{
                    \token_if_active:NTF ##1 
                      {##1}
                      {
                        \token_if_parameter:NTF ##1
                          { 
                           \int_incr:N \l_tmpa_int
                            \int_compare:nNnTF { \l_tmpa_int } = { 0 }
                              { \c_hash_str }
                              { \int_zero:N \l_tmpa_int }
                          }
                          { ##1 {} }
                      }
                  }
              }
          }
      }
    \end{minipage}
    \end{center}
  }
\ProvideDocumentEnvironment{cuexamplecode}{}{}{}{}



\NewDocumentEnvironment { cuexample } { }
  { 
    \paragraph{Example:} 
%    \par \bigskip \noindent
%    \mbox{}
%    \marginpar{\raggedleft\textbf{Example}}\
%    \ignorespaces
  }
  { }

\NewDocumentEnvironment { cunote } { }
  {
    \paragraph{Note:}
  }{ }

\NewEnviron { cuenumnote }
  {
    \begin{enumerate}[label={Note \space \arabic*:}]
      \BODY
    \end{enumerate}
  }


\NewDocumentEnvironment { cuinterest } { m }
  { 
    \par \bigskip
    \clist_set:Nn \l_tmpa_clist {#1}
    \mbox{}\marginpar{\raggedleft\opt{ \clist_use:Nn \l_tmpa_clist { \\ } }}
    \ignorespaces
  }
  { }


%: table
\tl_new:N \l_translation_does_not_exist_tl
\tl_set:Nn \l_translation_does_not_exist_tl { --- }
\tl_new:N \translationdoesnotexisttl
\tl_set_eq:NN \translationdoesnotexisttl \l_translation_does_not_exist_tl
\tl_new:N \mytablecolumns
\tl_set:Nn \mytablecolumns { l l l l l }
\clist_new:N \l_list_of_units_clist
\clist_new:N \l_list_of_textunits_clist
\clist_set:Nn \l_list_of_textunits_clist
  {
    decimal-mark ,
    one (m) ,
    one (f) ,
    one (n) ,
  }
\clist_set:Nx \l_list_of_units_clist
  {
    kg , dag , g , oz , lb , space ,
    C , F , Re , K , space ,
    d , h , min , s , space ,
    m , dm , cm , mm , in , space ,
    l , dl , cl , ml , space ,
    cal , kcal , J , kJ , eV ,  space ,
    pn , EL , TL ,  csp , dsp , ssp , Msp , space ,
    \clist_use:Nn \l_list_of_textunits_clist { , } ,
    THEEND
  }

\cs_new:Npn \__table_midrule:
  {
    \\ \midrule
    \cs_gset:Npn \__table_midrule: { \\ }
  }
\cs_new_eq:NN \__table_default_midrule: \__table_midrule:

\cs_new:Npn \_cook_use:n #1
  { \cs_if_exist_use:cF { __cookingunits_#1 } {\ERRORcommandNOTexist} }

\NewDocumentCommand \CreateTableForLanguages { s >{\TrimSpaces} m }
  {
    \IfBooleanTF {#1}
      { \clist_gset_eq:NN \l_tmpa_clist \l_list_of_textunits_clist }
      { \clist_gset_eq:NN \l_tmpa_clist \l_list_of_units_clist }
    \cs_gset_eq:NN \__table_midrule: \__table_default_midrule:
%    \CreateTableHeader {#2} 
%    \CreateTableRow {#2} 
  }

\NewDocumentCommand \CreateTableHeader { m }
  {
     \meta{unit-key} & 
     printed \ unit & unit name & (plural) & gender
  }
\NewDocumentCommand \CreateTableRow { m }
  {
    \clist_map_inline:Nn \l_tmpa_clist
      { 
        \str_case:nnF {##1}
          {
            { space } { \\ \addlinespace \cs_set:Npn \__table_midrule: {} }
            { THEEND } { \\ \bottomrule }
          }{
            \__table_midrule:
            \texttt{##1}
               & 
                 \clist_if_in:NnTF \l_list_of_textunits_clist {##1}
                   { \l_translation_does_not_exist_tl }
                   { 
                     \_cook_use:n { translate_let:nNnV } {#1} \l_tmpa_tl {##1} \c__cookingunits_postfix_unit_tl 
                     \tl_if_in:NnTF \l_tmpa_tl \q__cookingunits_no_translation
                       { \l_translation_does_not_exist_tl }
                       { \l_tmpa_tl }
                   }
               & 
               \_cook_use:n { translate_let:nNnV } {#1} \l_tmpa_tl {##1} \c__cookingunits_postfix_name_tl 
               \tl_if_in:NnTF \l_tmpa_tl \q__cookingunits_no_translation
                 { \l_translation_does_not_exist_tl }
                 { \l_tmpa_tl }
               & 
               \_cook_use:n { translate_let:nNnV } {#1} \l_tmpa_tl {##1} \c__cookingunits_postfix_name_tl 
               \_cook_use:n { translate_let:nNnV } {#1} \l_tmpb_tl {##1} \c__cookingunits_postfix_name_pl_tl 
               \tl_if_eq:NNF \l_tmpa_tl \l_tmpb_tl
                 { 
                   \tl_if_in:NnTF \l_tmpb_tl \q__cookingunits_no_translation
                     { \l_translation_does_not_exist_tl  }
                     { (\l_tmpb_tl)  }
                 }
               &
               \_cook_use:n { translate_let:nNnV } {#1} \l_tmpa_tl {##1} \c__cookingunits_postfix_gender_tl 
               \tl_if_in:NnTF \l_tmpa_tl \q__cookingunits_no_translation
                 { \l_translation_does_not_exist_tl }
                 { \l_tmpa_tl }
          }
      } 
  }

\NewDocumentCommand \CreateTableForPhrases { >{\TrimSpaces}  m }
  {
%    \tl_set:Nn \l_tmpa_tl {#1}
%    \__cookingunits_phrase_list_get_for:NNTF \l_tmpa_prop \l_tmpa_tl
%      { 
%          \__cookingunits_translate_let:VNnV \l_tmpa_tl \l_tmpa_seq 
%            { phrase-clist } \c__cookingunits_postfix_phrase_tl
%      }
%      { \ERRORCreateTable }
%    \seq_gput_right:Nn \l_tmpa_seq { THEEND }
%    \cs_gset_eq:NN \__table_midrule: \__table_default_midrule:
%        \begin{tabular}{ l l l l l }
%          \toprule 
%          \meta{Phrase-key} &  phrase & (plural) & gender 
%          \CreatePhraseTableRow {#1} 
%        \end{tabular}
  }

\NewDocumentCommand \CreatePhraseTableRow { m }
  {
%    \tl_show:n { Fix Phrase Table }
    \seq_map_inline:Nn \l_tmpa_seq
      { 
        \str_case:nnF {##1}
          {
            { space } { \addlinespace \cs_set:Npn \__table_midrule: {} }
            { THEEND } { \\ \bottomrule }
          }{
            \__table_midrule:
            ##1
               & 
                 \prop_get:NnN \l__cookingunits_phrase_prop {##1} \l_tmpa_tl
                 \tl_gset:NV \l_tmpa_tl \l_tmpa_tl %% Damit global
                 \l_tmpa_tl
               & 
                 \prop_get:NnN \l__cookingunits_phrase_prop {##1-pl} \l_tmpb_tl
                 \tl_if_eq:NNF \l_tmpa_tl \l_tmpb_tl { \l_tmpb_tl }
               &
            \__cookingunits_translate_let:nNnV {#1} 
              \l_tmpa_tl { ##1 -phrase-gender } \c__cookingunits_postfix_gender_tl
               \l_tmpa_tl
          }
      }
  }





\newcommand\txtupde{\textsuperscript{de}}
\newcommand\txtupsic{\textsuperscript{sicilian}}
\newcommand\txtupen{\textsuperscript{en}}
\NewDocumentCommand\unititem { m d** O{} O{} }
  {
   \item 
     [{ 
       #1 
       \IfNoValueF {#2} { \use:c { txtup #2 } }
       \tl_if_empty:nF {#3} {\ (#3) }
       \tl_if_empty:nF {#4} {\ [#4] }
     }]
  }

\NewDocumentEnvironment { myquote } { o o }
  {
    \list{}{%
      \topsep 0pt
     \leftmargin 0pt
    } 
    \item\relax
    \itshape
  }{
    \normalfont
    \IfNoValueF{#1}{(see\ \cite{#1} \IfNoValueF{#2}{\ page \ #2}  )}
    \endlist
  }
\makeatletter
\newenvironment{mydescription}
               {\list{}{\labelwidth\z@ \itemindent-\leftmargin
                        \let\makelabel\descriptionlabel}}
               {\endlist}
\renewcommand*\descriptionlabel[1]{\hspace\labelsep
                                \normalfont\bfseries #1}
\makeatother
\ExplSyntaxOff

\newcommand\cCutext{\mycs{cutext} and \mycs{Cutext}}

\lstset
  {
    basicstyle   = \ttfamily,
    basewidth    = 0.51em,
    gobble       = 3,
    keywordstyle = \color{blue},
    language     = [LaTeX]{TeX},
    commentstyle=\color{red!80!black},
    moretexcs =
      {
        cunum,
        cutext,
        Cutext,
        cuam,
        newcookingunit,
        declarecookingunit,
        providecookingunit,
        cudefinename,
        cudefinesymbol,
        cusetup,
        cudefinekeys,
        cudefinesinglekey,
        cuaddkeys,
        cuaddsinglekeys,
        cuaddtokeys,
        culabel,
        curef,
        cudefinephrase,
        declarecookingderivatives,
      }
  }

\newcookingunit {st}
\newcookingunit [\ensuremath{ {} ^ { \circ } }\kern-\scriptspace R{\text{\o}}] {Ro}
\newcookingunit {ft}
\newcookingunit {km}

\cuaddkeys {lb}  
  { 
    {st} { 1/14 }  %% 1 lb are 1/14 st
  }        
\cuaddtokeys {m} {ft} {0.3048}
\cuaddtokeys {m} {km} {1000}
\cuaddsinglekeys {C}
  {
    {Ro} { #1*21/40 + 7.5 }
  }

\newcommand\eneunit[3]{\sfrac{#1\,#2${}^2$}{#3${}^2$}}
%% Can overflow and takes too long, hard code it
\declarecookingderivatives{kg,m,s}{#1*#2:#3}{ (#1)*(#2)^2/(#3)^2 } {\eneunit{#1}{#2}{#3}}
\declarecookingderivatives{m,s}{#1:#2}{ (#1)/(#2) } {\sfrac{#1}{#2}}



\cusetup 
  {
    commands-add-hook = {\stepcounter{CookingUnitsCounter}} ,
    cunum-add-hook = {\stepcounter{cunumCounter}} ,
    cutext-add-hook = {\stepcounter{cutextCounter}} ,
    Cutext-add-hook = {\stepcounter{CutextCounter}} ,
    cuam-add-hook = {\stepcounter{cuamCounter}} ,
    set-option-for-Ro = { round-precision= 0 }  ,
%    add-unit-to-group = { weight = {st} , temperature = {Ro} }
  }

%: \cusetup
\cusetup
  {
%    weight=stick,
%    42 = true ,
%    convert-to-eV=true ,
%    cutext-range-sign = {as},
%    erase-all-options,
%    set-option-for-K= {},
% set-unknown-message = error ,
%   check-temperature = true,
%   round-precision = 30 ,
  }


\EnableCrossrefs 
\CodelineIndex 
\RecordChanges 
\AtEndDocument { \PrintChanges \PrintIndex }


\begin{document}
\DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
%
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \iffalse 
%: changes
% \fi
% 
% \changes {2016/06/11} {0.99} {Added the package option to load 'fmtcount'.}
% \changes {2016/08/31} {1.00} {Initial version}
% \changes {2016/08/31} {1.00a} {Fixed calculation: degree Reamur to eV}
% \changes {2016/09/03} {1.01} {Added units 'ssp', 'csp', 'dsp'}
% \changes {2016/09/03} {1.01} {English unit: litre (and only litre) uses the curly l \protect\ensuremath{\protect\ell} now }
% \changes {2016/09/03} {1.01} {British English: 'pinch' is written in full}
% \changes {2016/09/03} {1.01} {Separated Messerspitze and pinch}
% \changes {2016/09/05} {1.02} {Replaced \cs{cufrac} by \cs{cuam}}
% \changes {2016/09/05} {1.02} {New message: 'obsolete-command'}
% \changes {2016/09/09} {1.02a} {Changed name from \cs{@@_parse_fraction_in_input:www} to \cs{@@_parse_mixed_fraction_in_input:www}}
% \changes {2016/09/09} {1.02b} {Changed name from \cs{@@_cunum_parse_range} (and derivatives) to \cs{@@_cutext_parse_range}.}
% \changes {2016/09/09} {1.02c} {In \cs{@@_cutext_default:nnn} it is only
%   checked once if a range is inside.}
% \changes {2016/09/09} {1.02d} {\cs{@@_calculate_input_and_store_in:nN} optimiert durch neue property-key: single.}
% \changes {2016/09/09} {1.02d} {Add 'single' to property list of singlekeys.}
% \changes {2016/09/16} {1.02e} {Only use \cs{phantom} if the argument (for \cs{phantom}) is not empty.}
% \changes {2016/09/09} {1.02i} {Delete 'single' from property lists of singlekeys cause it is not as safe as I thought.}
% \changes {2016/09/09} {1.02f} {Corrected mistake: 'ELektronenvolt' (note uppercase L) to 'Elektronenvolt' in german.}
% \changes {2016/09/26} {1.03} {New option  (and needed macros): add-temperature-to-check.}
% \changes {2016/09/26} {1.03a} {\cs{cuaddsinglekeys} now tests if the unit exists (it didn't before).}
% \changes {2016/09/26} {1.03b} {Replaced \cs{prop_clear_new:c} by \cs{prop_clear:c}.}
% \changes {2016/09/26} {1.03b} {Recalculated all electron volt values for conversion (as 'kg' was wrong before). Let's hope they are correct this time.}
% \changes {2016/09/26} {1.04} {New option: 'round-half'.}
% \changes {2016/10/19} {1.04} {Use \cs{keys_set:nn} only if second argument is not empty.}
% \changes {2016/10/19} {1.04} {'convert-to-eV' now also as optional argument available.}
% \changes {2016/10/19} {1.04} {Option 'load-time-option' now spells 'available' correct.}
% \changes {2016/10/19} {1.04} {Update of documentation.}
% \changes {2016/10/28} {1.10alpha} {Start implementation of \enquote{Change recipe from $n$ to $m$ persons.}.}
% \changes {2016/10/28} {1.10alpha} {\cs{cutext} (and \cs{Cutext}) and \cs{cuam} now parse their input like \cs{cunum}. This is needed as they also need to be changed.}
% \changes {2016/10/29} {1.10alpha} {Tiding code: Now every command is separated into a \enquote{calc} function, a \enquote{print numeric value} and a \enquote{print unit} (if there) function. At least, that's the plan.}
% \changes {2016/10/30} {1.10} {Fractions should now deal correctly with minus signs.}
% \changes {2016/11/07} {1.10} {Finished writing v1.10.}
% \changes {2016/11/13} {1.10} {Change amounts for specific number of persons.}
% \changes {2016/11/13} {1.10} {\cs{cutext}, \cs{Cutext} and \cs{cuam} check their input, allows conversion of units.}
% \changes {2016/11/13} {1.10} {New commands: \cs{culabel} and \cs{curef}.}
% \changes {2016/11/13} {1.10} {New commands: \cs{declarecookingunit} and \cs{providecookingunit}.}
% \changes {2016/11/13} {1.10} {New options: \opt{cutext-to-cunum}, \opt{cutext-change-unit} and \opt{cutext-space}.}
% \changes {2016/11/13} {1.10} {New options: \opt{cuam-version} and \opt{cutext-version}}
% \changes {2016/11/13} {1.10} {New options: \opt{recalculate-amount} and \opt{set-number-of-persons}, \opt{label}, \opt{get-label}, \opt{ref}.}
% \changes {2017/03/10} {1.10a} {\cs{curef} is now defined by \cs{NewExpandableDocumentCommand} instead of the Declare variant.}
% \changes {2017/03/10} {1.11} {Removed \cs{translate} and others from code
%   and replaced them with wrapper-macros.}
% \changes {2017/03/10} {1.11} {Removed things like 'cu-unit' from translate input
%   and placed them into separate tl's.}
% 
% \changes {2017/10/23} {1.20} {Replaced \pkg{translator} by \pkg{translations}.}
% \changes {2017/10/23} {1.20} {Added \enquote{phrases}.}
% \changes {2017/10/23} {1.20} {Added unit \enquote{stick} (of butter).}
% \changes {2017/10/23} {1.20} {|<| is not allowed as a special sign anymore.}
% \changes {2017/10/23} {1.20} {New option: \opt{set-cutext-translation-message}.}
% \changes {2017/10/23} {1.20} {New option: \opt{print-numerals}.}
% \changes {2017/10/23} {1.20} {New option: \opt{use-phrases}.}
% \changes {2017/10/23} {1.20} {New option: \opt{phrase-space}.}
% \changes {2017/10/23} {1.20} {New option: \opt{amount-unit-space}.}
% \changes {2017/10/23} {1.20} {Now checks for ranges if both values can be printed as numerals (if activated) (bug fix).}
% \changes {2017/10/23} {1.20} {Reworked quite a lot of code.}
%
% \changes {2018/04/20} {1.30} {Allow round precision to be negative.}
% \changes {2018/04/20} {1.30} {Fix argument specifiers.}
% \changes {2018/04/20} {1.30} {Change large portions of code.}
% \changes {2018/04/20} {1.30} {Introduce key-groups (weight, volume, etc.).}
% \changes {2018/04/20} {1.30} {Option: \opt{add-natural-unit}.}
% \changes {2018/04/20} {1.30} {New Option: \opt{42}.}
% \changes {2018/04/20} {1.30} {New options: \opt{expand-both}, \opt{expand-amount}, \opt{expand-unit}.}
% \changes {2018/04/20} {1.30} {New options: \opt{set-option-for} \& \opt{add-option-for}.}
% \changes {2018/04/20} {1.30} {New option: \opt{erase-all-options-for}}
% \changes {2018/04/20} {1.30} {New option: \opt{add-unit-to-group}}
% \changes {2018/04/20} {1.30} {New feature: Hooks}
% \changes {2018/04/20} {1.30} {New parsing algorithm. Hopefully better
%   error recovery (if signs for fractions are in wrong order e.g.)}
% \changes {2018/04/20} {1.30} {Add \enquote{Division-by-zero} error.}
% \changes {2018/04/20} {1.30} {Cooking Units-keys are not allowed to contain
%   either \enquote{,} or \enquote{/}.}
%
% \changes {2018/06/05} {1.40} {This version introduces mayor internal changes.
%   For users not many things change.} 
% \changes {2018/06/05} {1.40} {Rework parsing code (again). As this is 
% basically an improved version of the old parsing algorithm, there is
% no huge version change.}
% \changes {2018/06/05} {1.40} {Improve error-recovery by a lot!} 
% \changes {2018/06/05} {1.40} {Bugfix: A range in \mycs{Cutext} (and numerals=true)
% will print the second word small.} 
% \changes {2018/06/05} {1.40} {Add \enquote{range-sign} for translations (not usable yet).} 
% \changes {2018/06/05} {1.40} {Convert \texttt{clist} to \texttt{seq} if possible.} 
% \changes {2018/06/05} {1.40} {Remove unnecessary variants.} 
% \changes {2018/06/05} {1.40} {Fix some more argument specifiers.} 
% \changes {2018/06/05} {1.40} {Renaming of some internal commands.} 
% \changes {2018/06/05} {1.40} {\opt{set-unknown-message}: Fix default value.} 
% \changes {2018/06/05} {1.40} {Change (\texttt{amount-not-known}): Change message a bit.} 
% \changes {2018/06/05} {1.40} {Bugfix (\texttt{label-not-defined}): Add |'#1'|.} 
% \changes {2018/06/05} {1.40} {Bugfix (\texttt{unit-change}): \opt{convert-to-eV}
%   can be again used as a local argument.} 
% \changes {2018/06/05} {1.40} {Change order of boolean testing for |\@@_calc_references_and_store_in:N|.} 
% \changes {2018/06/05} {1.40} {Bugfix (\texttt{phrases}): Use the phrase from the first amount to check
% the second (and don't parse through the second amount).} 
%
% \changes {2018/09/24} {1.45} {Changes prefix from \texttt{cooking\_units} to \texttt{cookingunits}.}
% \changes {2018/09/24} {1.45} {New language symbols: \opt{cutext-range-sign}}
% \changes {2018/09/24} {1.45} {Improved french (not in general, only for this package)}
% \changes {2018/09/24} {1.45} {New section in documentation.}
% \changes {2018/09/24} {1.45} {Remove exhaustive expansion from internals (shouldn't change anything for users).}
%
% \changes {2020/03/21} {vVERSIONv} {Remove exhaustive expansion from translations. Shouldn't really change much if anything.}
% \changes {2020/03/21} {vVERSIONv} {New options: \opt{definition/symbol}, \opt{definition/gender}, \opt{definition/set-option}, \opt{definition/add-to-group}. }
% 
%
%
%
%
%
% \GetFileInfo{\jobname.sty}
% 
%\title{The \pkg{\jobname} package^^A
%\thanks{This document corresponds to \textsf{Benedikt Vitecek}~\fileversion, dated~\filedate.}}
%\author{Ben Vitecek \\ b.vitecek@gmx.at}%
%\date{\filedate}%
%
%
% \maketitle
%
%
% \begin{documentation}
% \begin{abstract}
%   This package enables user to globally format units, to switch
%   between them and  change your recipes to a given
%   number of persons.
%   
%  For not implemented units or differences between Imperial and U.S.\ unit
%  you may have a look at \cref{sec:other-units}.
%
%   It should be used for light-hearted things like
%   cookery books (and not e.g. scientific texts; use e.g.\ \pkg{siunitx} for those).
%
% ^^A  Please read through the section \enquote{Important Changes}
% \end{abstract}
%
% \tableofcontents
%
% \section{Introduction}
% \cookingunitsChecked
%
% While writing on a cookery book I used -- for some reasons whatsoever --
% three different units for weight: kilogram (kg), gram (g) and
% decagram (dag, or older: dkg). Later my mother told me that she
% doesn't like it if a cookery book uses more than two different units
% (for weight in this case).  Happily I hardly used Decagram and
% therefore didn't have many problems changing the units. But, well
% \dots\ I am using \LaTeX\ and changing those units by hand seemed
% not very \LaTeX-like, so I started writing some code to convert
% units. I expanded the code, rewrote it in \LaTeX3 (which is much
% more pleasant than \LaTeXe) and here it is.
%
%
%
%
%
% \subsection{Supported languages}
% \cookingunitsChecked
% \begin{itemize}
%  \item German
%  \item English
%  \item French (currently suboptimal\footnote{You can only get limited information from the internet.})
% \end{itemize}
% Want to contribute a new language or make a correction to an existing one?
% See \cref{sec:bug-feed} for more details. Wanna just check the
% existing translations? See \cref{sec:Translations}.
%
% \section {The Commands}
% \label{sec:commands}
% \cookingunitsChecked
%
% This package offers the following commands for unit printing (and
% converting):
%
% \begin{itemize}
%   \item \mycs{cunum}\myaarg{label}\oarg{options}\marg{amount}\oarg{space}\marg{unit-key}
%   \item \mycs{cutext}\myaarg{label}\oarg{options}\marg{amount}\marg{unit-key}
%   \item \mycs{Cutext}\myaarg{label}\oarg{options}\marg{amount}\marg{unit-key}
%   \item \mycs{cuam}\myaarg{label}\oarg{options} \marg{amount}
%   \item \mycs{cusetup}\marg{options}
% \end{itemize}
%
% Numbers and units are printed using \mycs{cunum}. The numerical part
% can interpret \verb|_| and \texttt{/} as (mixed) fractions and
% \verb|--| as a separator for ranges; to convert units use the option
% \texttt{\meta{old-unit}=\meta{new-unit}}\footnote{New keys can be
% added and defined, see \cref{sec:pred-units} and
% \cref{sec:def-units} for further information.}.  It furthermore
% allows the sign \texttt{?} to be used as a placeholder for not known
% amounts and raises a warning to remind you that this amount needs a
% check-up\footnote{You can customize this behavior, see
% \cref{sec:options}}. \oarg{space} adds a space between the number
% and the unit using \lstinline|\phantom|.
%
% For a list of predefined units have a look at \cref{tab:def-units}. 
%
% \meta{label} is explained in \cref{sec:labeletref}.
% 
% 
% \begin{cuexamplecode}
%   \cunum{1}{kg} \\
%   \cunum{2.3}{kg} \\
%   \cunum{2,3}{kg}  \\
%   \cunum{2--3}{kg}  \\
%   \cunum{2.5--3.5}{kg}  \\
%   \cunum[kg=g]{2.5--3,5}{kg}  \\
%   \cunum[C=F]{200}{C}  \\
%   \cunum[C=F]{180--200}{C} \\
%   \cunum{1/2}{m}  \\
%   \cunum{1_1/2}{m}  \\
%   \cunum[m=cm]{1_1/2}{m}  \\
%   \cunum{?}{l}  \\
%   \cunum{50}{dag}  \\
%   \cunum{5}[0]{dag}  \\
%   \cunum{1.1234}{m} 
% \end{cuexamplecode} 
%
% Decimal numbers are automatically rounded to 2 digits after the
% colon, temperatures (\myunit{C}, \myunit{F}, \myunit{K} and
% \myunit{Re}) are automatically rounded to integers.\footnote{You can
% -- of course -- change this behavior, see \cref{sec:options}.}
% 
%
% \cCutext\ print the number and the written name of the unit. Since
% v1.10 it works similar\footnote{One could also say \enquote{exactly
% like}.} to \mycs{cunum}: it allows the conversion between units and
% interprets the numerical part (again |_| and |/| are used for
% (mixed) fractions and |--| for ranges).  Furthermore, \cCutext\ allow
% the usages of numerals (see \cref{sec:load-time-options} for more information). 
%^^A if the package
%^^A option \opt{use-fmtcount-numerals} (see \cref{sec:load-time-options})
%^^A is used, integers below a specific integer
%^^A (by default 13; see \opt{use-numerals-below}) are written out with
%^^A \lstinline|\Cutext| capitalizing the first letter (using package
%^^A \pkg{fmtcount}).
%
% \begin{cuexamplecode}
%   \cutext{1}{l} \\
%   \Cutext{1}{l} \\
%   \Cutext{1--2}{l} \\
%   \cutext{12}{l} \\
%   \Cutext{13}{l} 
% \end{cuexamplecode}
% and using (e.g.) package option \opt{use-fmtcount-numerals=true}
% \cusetup{print-numerals=true}
% \begin{cuexamplecode}
%   \cutext{1}{l} \\
%   \Cutext{1}{l} \\
%   \cutext{1--2}{l} \\
%   \Cutext{1--2}{l} \\
%   \cutext{12}{l} \\
%   \Cutext{13}{l} 
% \end{cuexamplecode}
% \cusetup{print-numerals=false}
% You can customize the numeral functions used with \opt{numeral-function} and
% \opt{Numeral-function}.
%
% Furthermore,
% since v1.10 \cCutext\ also allow their units to be changed (this behavior
% can be altered using \opt{cutext-change-unit}):
% \begin{cuexamplecode}
%   \cusetup{ l=ml } @
%   \cutext{1}{l} \\
%   \Cutext{1}{l} \\
%   \cutext{1--2}{l} \\
%   \cutext{12}{l} \\
%   \Cutext{13}{l} \\
%   \Cutext{?}{l} \\
%   \Cutext{1/2}{l} \\
% \end{cuexamplecode}
%
% 
% \lstinline|\cuam| works like \mycs{cunum}, but without a unit, so
% changing units doesn't affect it. Like \mycs{cunum} \texttt{\_} and
% \texttt{/} are used to imply a (mixed) fraction and |--| is used for ranges.
%
% \begin{cuexamplecode}
%   \cuam{3} \\
%   \cuam{2--3} \\
%   \cuam{2/3} \\
%   \cuam{1_2/3} 
% \end{cuexamplecode}
%
% Furthermore it allows the concept of \enquote{phrases} (replacing a positive integer
% by a word; such as \enquote{12} becoming \enquote{dozen}\footnote{At least I think})
% which can be activated by the option \opt{use-phrases}
% (as I don't know any english phrases, I switched the language to german  for the following examples)
%^^A \begin{myde}
% \begin{cuexamplecode}
%   \selectlanguage{ngerman} @
%   \cusetup{use-phrases=true} @
%   \cuam{11} \\
%   \cuam{12} \\
%   \cuam{13} \\
%   \cuam{24} \\
%   \cuam{12--24} \\
%   \cuam{12--13}\\
%   \cuam{18} \\
%   \cuam{60} 
% \end{cuexamplecode}
%^^A \end{myde}
%
%
% \section{Label \& refs: Changing the amount of the recipe}
% \label{sec:labeletref}
% \cookingunitsChecked
%
% What if you don't want to change units, but the amounts of the recipe because
% you cook not for 4 persons, but for 2 and don't like to do the math? 
% Simple, use the following commands:
%
% \begin{itemize}
%   \item \mycs{culabel}\marg{label}\marg{number of persons}
%   \item \mycs{curef}\marg{label}
% \end{itemize}
%
%
% The first one is the important one: It defines a \meta{label} for a recipe
% which is initially for  \meta{number of persons}. Afterwards \meta{label}
% can be used to tell the commands from \cref{sec:commands} that the given
% amounts are for \meta{number of persons}.
% Each \meta{label} must be unique and an error is raised if a \meta{label}
% is already defined.
%  
% If you would like to print the number of persons this recipe is for, use 
% \mycs{curef}, which is fully expandable.
%
% The following example uses \mycs{culabel} to specify that the recipe is
% initially intended for 2 persons:
% \begin{cuexamplecode}
%   \culabel{recipe}{2} @
%   recipe & for & \curef{recipe} & persons: \\
%   \cunum<recipe>{10--20}{dag} & flour, \\
%   \cunum<recipe>{1/2}{l} & water, \\
%   \cutext[ref=recipe]{10}{g} & nuts, \\
%   \cuam<recipe>{2--3} & eggs, \\
%   \cunum{180}{C} & (\cunum[C=F]{180}{C}) & open & fire
% \end{cuexamplecode}
%
% In combination with the option \opt{set-number-of-persons}
% and  \opt{recalculate-amount}  you can have this recipe
% changed to four persons:
% \begin{lstlisting}
%   \culabel{recipe}{2}
%   %% adding options:
%   \cusetup{set-number-of-persons=4,recalculate-amount=true}
% \end{lstlisting}
% \cusetup{set-number-of-persons=4,recalculate-amount=true}
%
% \begin{cuexamplecode}
%   recipe & for & \curef{recipe} & persons: \\
%   \cunum<recipe>{10--20}{dag} & flour, \\
%   \cunum<recipe>{1/2}{l} & water, \\
%   \cutext[ref=recipe]{10}{g} & nuts, \\
%   \cuam<recipe>{2--3} & eggs, \\
%   \cunum{180}{C} & & (\cunum[C=F]{180}{C}) & open & fire
% \end{cuexamplecode}
% \cusetup{recalculate-amount=false}
%
% Note that fractions are automatically evaluated and that only values
% with a \meta{label} are changed (\lstinline|\cunum{180}{C}| for example
% stays the same which also makes sense as the heat should be the same).
%
%
%
%
%
%
%
%
%\subsection{Rounding temperatures}
% \cookingunitsChecked
%
% By default temperatures are rounded to integers (using \opt{round-precision=0}).
% Since v1.30 it is possible to round amounts to a negative precision. 
% If you want to round temperatures to the tens see the following 
% example (\mycs{cusetoptionfor} is described in \cref{sec:opt:unit-spec}).
% 
% \begin{cuexamplecode}
%   \cunum{182}{C} \\
%   \cunum[C=F]{180}{C} \\
%   \cunum[C=Re]{180}{C} \\
%   \cunum[C=K]{180}{C} \\
%   \cusetoptionfor{C,F,K,Re}{ round-precision = -1 } @
%   \cunum{182}{C} \\
%   \cunum[C=F]{180}{C} \\
%   \cunum[C=Re]{180}{C} \\
%   \cunum[C=K]{180}{C} \\
% \end{cuexamplecode}
%
% \section{Predefined units \& some notes}
% \label{sec:pred-units}
% \cookingunitsChecked
%
%
% In \cref{tab:def-units} and you can find all predefined units which can be
% transformed into each other (sorted by group). Other predefined units
% (which cannot be used for transformations) are shown in \cref{tab:some-more-units}.
% \Cref{tab:strange-units} pretty much exists just for fun.
%
%
% \begin{table}[tbp]
%   \centering
%   \caption{^^A
%   This table shows all units which  can be transformed into each other, sorted
%   by group. The columns \enquote{default} show the abbreviations used if
%   no translation is defined for the given language. The translations used for \cCutext\
%   are shown in \cref{sec:Translations}. 
%   Note that \enquote{electron volt} exists just for fun.
% }
% \smallskip
%   \begin{tabular}{ lll @{\hspace{1cm}} lll  }
%      \toprule
%      description & key & default & description & key & default \\ \midrule
%     \PrintUnit {kg} & \PrintUnit{m}  \\
%     \PrintUnit {dag} & \PrintUnit{dm}  \\
%     \PrintUnit {g} & \PrintUnit{cm}  \\
%     \PrintUnit {oz} & \PrintUnit{mm} \\ 
%     \PrintUnit {lb} & \PrintUnit{in} \\ 
%     \PrintUnit [ (of butter)] {stick} \\ \addlinespace
%
%     \PrintUnit {d} & \PrintUnit {l}  \\
%     \PrintUnit {h} & \PrintUnit {dl}  \\
%     \PrintUnit {min} & \PrintUnit {cl} \\
%     \PrintUnit {s} & \PrintUnit{ml} \\ \addlinespace
%
%     \PrintUnit{cal} & \PrintUnit{C} \\
%     \PrintUnit{kcal} & \PrintUnit{F} \\
%     \PrintUnit{J} & \PrintUnit{Re} \\
%     \PrintUnit{kJ} & \PrintUnit{K} \\
%     \PrintUnit{eV} 
%
%    \\  \bottomrule
%   \end{tabular}
%   \label{tab:def-units}
% \end{table}
%
% \begin{table}[htbp]
%   \centering
%   \caption{A (not only) spoonful of (more or less) country and
%   language dependent units.  Please note that sometimes a
%   translation is nearly impossible as a unit
%   (e.g. \enquote{saltspoonful}) may not exist in another language
%   (like german; at least I never heard of it). So please only use
%   units known to you. For \enquote{tablespoon} and \enquote{teaspoon}
%   I used the german abbreviations \enquote{EL} and \enquote{TL} (because I forgot to
%   change them initially).}
%   \smallskip
%   \begin{tabular}{ lll }
%     \toprule
%     description & key & symbol \\ \midrule
%     \PrintUnit {pn} \\ \addlinespace
%     \PrintUnit {EL} \\
%     \PrintUnit {TL} \\
%     \PrintUnit {dsp} \\ 
%     \PrintUnit {csp} \\ 
%     \PrintUnit {ssp} \\ \addlinespace
%     \PrintUnit [Messerspitze (point of a knife)] {Msp} \\
%     \bottomrule
%   \end{tabular}
%   \label{tab:some-more-units}
% \end{table}
% 
% \begin{table}[htbp]
%   \centering
%   \caption{List of (not really) nonsense units (exist just for fun, there will be
%   no support for those units; unless -- of course -- you really want it).}
%   \smallskip
%   \begin{tabular}{ ll }
%    \toprule
%      unit-key & symbol \\ \midrule
%     \PrintUnitSymbol {eVc-2} \\
%     \PrintUnitSymbol {hbareV-1} \\
%     \PrintUnitSymbol {chbareV-1} \\ 
%     \PrintUnitSymbol {(chbareV-1)3} \\ 
%     \bottomrule
%   \end{tabular}
%   \label{tab:strange-units}
% \end{table}
%
%
%
% \section{Defining units}
% \label{sec:def-units}
% \cookingunitsChecked
%
% New units can be defined using 
% \begin{itemize}
%   \item \mycs{declarecookingunit}\oarg{symbol/key-val-list}\marg{unit-key}
%   \item \mycs{newcookingunit}\oarg{symbol/key-val-list}\marg{unit-key}
%   \item \mycs{providecookingunit}\oarg{symbol/key-val-list}\marg{unit-key}
% \end{itemize} 
%
% \begin{function}{\declarecookingunit,\newcookingunit,\providecookingunit}
%   \begin{syntax}
%     \mycs{declarecookingunit}\oarg{symbol/key-val-list}\marg{unit-key}
%     \mycs{newcookingunit}\oarg{symbol/key-val-list}\marg{unit-key}
%     \mycs{providecookingunit}\oarg{symbol/key-val-list}\marg{unit-key}
%   \end{syntax}
%
%   These commands define the unit  \meta{unit-key}. Note that \meta{unit-key}
%   can neither contain |/| nor |,|; but is allowed to be a command since v2.0 
%   (see examples below).
%
%   If the key is not the same as the printed symbol use the optional argument.
%   It can either contain the symbol you want printed or a key-value list (see below) 
%   for more advanced adjustments.
%   
%   \mycs{newcookingunit} raises an error if the unit is already defined,
%   \mycs{declarecookingunit} creates or (if given) overwrites  \meta{symbol} 
%   and \mycs{providecookingunit} does nothing if the unit is already
%   defined. 
%
%   All units have male gender |m| by default (unless you change it using a key below).
%
% Some examples:
% \begin{lstlisting}[commentstyle=\color{black}]
%   \declarecookingunit{kg}
%   \declarecookingunit{g}
%   \declarecookingunit[Msp.] {Msp}
%   \declarecookingunit[\ensuremath{{}^{\circ}}\kern-\scriptspace C] {C}
%   \declarecookingunit{\%} % can use commands now
% \end{lstlisting}
%
% \end{function}
%
% \begin{cunote}
%  The definition of the printed degree Celsius is
%  copied and pasted from (a maybe older version of) \pkg{siunitx}.
% \end{cunote}
%
% \begin{function}{symbol, gender, set-option, add-to-group, natural-unit}
%
%   \begin{syntax}
%     symbol = \meta{symbol}
%     gender = \meta{m/f/n}
%     set-option = \marg{key-val-list}
%     add-to-group = \meta{group}
%     natural-unit = \meta{true/false}
%   \end{syntax}
%  
%   Those keys can only be used in the optional argument of 
%   \mycs{declarecookingunit}, \mycs{newcookingunit} or \mycs{providecookingunit}.
%   They can be used to define some properties of the unit during its initialization.
%   
%   \opt{symbol} allows you to set the printed symbol of the unit. A similar effect can be
%    achieved by just using the optional argument. Use this option if you want to
%    use other keys during the definition.
%
%    \opt{gender} sets the gender of the unit (default ist |m|).  Allowed is |m|, |f| or |n|.
%    Note that this sets the default gender for all languages.
%    \opt{set-option} allows to add some key-vals to the specific unit which are
%    activated once the unit is used. See \cpageref{code:set-option}. 
%    \opt{add-to-group} adds the unit defined to \meta{group}. See \cref{sec:opt:unit-spec}
%    for more information.
%    \opt{natural-unit} is a simple true/false switch. If |true| the unit will be specified to be
%    a \enquote{natural-unit}. This is more or less a joke option.
% \end{function}
%
%
%
% \begin{function}{\declarecookingderivatives}
%   \begin{syntax}
%     \mycs{declarecookingderivatives} \marg{unit-list} \marg{unit-key}
%     \ \  \marg{mathematical-relation} \marg{unit-symbol}
%   \end{syntax}
%
%   \emph{This function is experimental}. Defines new units which are a combination
%   of the units given in \meta{unit-list} \emph{and} their key-chain.
%  \meta{unit-key}, \meta{mathematical-relation} and \meta{unit-symbol}
%  accept |#1| to |#n| as arguments with $n$ being the number of units
%  given in \meta{unit-list}. $n$ \emph{cannot} be greater than $8$ (and it will
%  probably compile for quite a while). Also note that this command doesn't work/isn't
%  tested for single keys.
%
%  Also note that it is quite possible that an \enquote{overflow-error} will
%  occur if there are too many units.
%
% \end{function}
%
% \begin{cuexample}
%  Your homework is to change the unit of energy \si{\kg\m\squared\per\s\squared}
%  into \si{\ounce\inch\squared\per\minute\squared}. To check if you are correct
%  you use \mycs{declarecookingderivatives}:
%    \begin{lstlisting}
%      \declarecookingderivatives{kg,m,s}{#1*#2:#3}
%      { (#1)*(#2)^2/(#3)^2 } {\sfrac{#1\,#2${}^2$}{#3${}^2$}}
%    \end{lstlisting}
%
% Using |\cunum[kg*m:s=oz*in:min]{1}{kg*m:s}| shows that
% \cunum{1}{kg*m:s} is equal to \cunum[kg*m:s=oz*in:min]{1}{kg*m:s}. 
%^^A\cunum{196829101.34}{oz*in:min}
%
%^^A \cunum[m:s=km:h]{1}{m:s}
%
% \end{cuexample}
%
% \begin{cunote}
%   As this is a bit more experimental and can easily lead to overflow-errors,
%   no actual \LaTeX\ keys are created with \mycs{declarecookingderivatives}.
%   Internally the keys and possible values are stored in a \emph{huge} property list.
%   If an unknown key is encountered, it checks if said key can be found in the
%   property list. 
% \end{cunote}
%
%
%
%
%
% \section{Defining options to change units}
% \label{sec:defining-opt}
% \cookingunitsCONTINUE
% Options (to change units) can be newly defined or added to already existing keys (units)
% using
% \begin{itemize}
%   \item \mycs{cudefinekeys}
%   \item \mycs{cudefinesinglekey}
%   \item \mycs{cuaddkeys}
%   \item \mycs{cuaddsinglekeys}
%   \item \mycs{cuaddtokeys}
% \end{itemize}
% I apologize for the (name) inconsistency between \mycs{cudefinekeys} and
% \mycs{cudefinesinglekey} (although they are named similarly, they work differently).
%
% \begin{function}{\cudefinekeys,\cudefinesinglekey}
%   \begin{syntax}
%     \mycs{cudefinekeys}\marg{unit-key-1}
%     \ \ \{
%     \ \ \ \ \marg{unit-key-2} \marg{$1$ unit-key-1 are \dots\ unit-key-2}
%     \ \ \ \ \marg{unit-key-3} \marg{$1$ unit-key-1 are \dots\ unit-key-3}
%     \ \ \ \ \marg{unit-key-4} \marg{$1$ unit-key-1 are \dots\ unit-key-4}
%     \ \ \ \ \dots
%     \ \ \}
%    
%     \mycs{cudefinesinglekey}\marg{unit-key-1}
%     \ \ \{
%     \ \ \ \ \marg{unit-key-2} \marg{$1$ unit-key-2 are \dots\ unit-key-1}
%     \ \ \ \ \marg{unit-key-3} \marg{$1$ unit-key-3 are \dots\ unit-key-1}
%     \ \ \ \ \dots
%     \ \ \}
%   \end{syntax}
%
%   If you define new units (see \cref{sec:def-units}) and cannot add
%   them to already existing keys you can use
%   \lstinline|\cudefinekeys| or  \lstinline|\cudefinesinglekey|  respectively to
%   define new keys.
%
%   \lstinline|\cudefinekeys| takes  \marg{unit-key-1} as a
%   \enquote{basis}, defines a key with the name \meta{unit-key-1} and
%   adds the values \meta{unit-key-1}, \meta{unit-key-2},
%   \meta{unit-key-3}, etc. Furthermore this command also defines the
%   keys \meta{unit-key-2}, \meta{unit-key-3}, etc.  with the same
%   values as \meta{unit-key-1}. Please note that \meta{\dots} has to
%   be a number. 
%  
%   Sometimes it is not that easy and the conversion of one unit into
%   another needs are more complicated formula (see for example
%   temperatures).  If that is the case use
%   \lstinline|\cudefinesinglekey|. As the name says it defines
%   \emph{only} the key \meta{unit-key-1} with the values
%   \meta{unit-key-1}, \meta{unit-key-2}, etc. The advantage of this
%   command is that now \meta{\dots} can be a formula and the
%   numerical input can be placed explicitly using \texttt{\#1}.
%
%
% \end{function}
%
% \begin{cuexample}
%
% This example defines following keys with their respective value:
% \begin{itemize}
% \item the key \myunit{kg} with the values \myunit{kg}, \myunit{dag},
%   \myunit{g} and \myunit{oz}
% \item the key \myunit{dag} with the values \myunit{kg},
%   \myunit{dag}, \myunit{g} and \myunit{oz}
% \item the key \myunit{g} with the values \myunit{kg}, \myunit{dag},
%   \myunit{g} and \myunit{oz}
% \item the key \myunit{oz} with the values \myunit{kg}, \myunit{dag},
%   \myunit{g} and \myunit{oz}
% \item the key \myunit{d} with the values \myunit{d}, \myunit{h},
%   \myunit{min} and \myunit{s}
% \item \dots
% \end{itemize}
% \begin{align*}
%   \SI{1}{\kg}&= \SI{1}{\kg} &
%   \SI{1}{\kg}&= \SI{100}{\deka\g} &
%   \SI{1}{\kg}&= \SI{1000}{\g}  \\
%   \SI{1}{\kg}&= \SI{35.27399}{\ounce} &
%   \SI{1}{\kg}&= \SI{2.204 622 6}{\pound} 
% \end{align*}
% \begin{lstlisting}
%  \cudefinekeys {kg} 
%    {
%      {dag}{ 100 } %% 1 kg are 100 dag
%      {g}  { 1000 } %% 1 kg are 1000 g
%      {oz} { 35.27399 }  %% 1 kg are 35.27399 oz
%      {lb} { 2.204 622 6 } %% 1 kg are  2.204 622 6 lb
%    }
%
%  \cudefinekeys {d}
%    {
%      {h}  { 24 } %% 1 day are 24 hours
%      {min}{ 1440 } %% 1 day are 1440 minutes
%      {s}  { 86400 } %% 1 day are 86400 seconds
%    }
% \end{lstlisting}
%
% To convert degree Fahrenheit to degree Celsius, kelvin and degree R\'eamur one 
% needs the formulas\footnote{See Wikipedia.}
% \begin{align*}
%   T_C &= ( T_F - 32 ) \cdot \frac{5}{9} \\
%   T_K &= ( T_F - 459.67 ) \cdot \frac{5}{9} \\
%   T_{Re} &= ( T_F - 32 ) \cdot \frac{4}{9} 
% \end{align*}
% with $T_F$ being the input temperature in degree Fahrenheit and
% $T_C$ being the same temperature in degree Celsius, etc. Using
% \lstinline|\cudefinesinglekey| the key \myunit{F} with values
% \myunit{C}, \myunit{K} and \myunit{Re} is defined:
% 
% \begin{lstlisting}
%  \cudefinesinglekey {F}
%    {
%      {C}  { ( #1 - 32 ) *  5/9 } %% see formulas above
%      {K}  { ( #1 + 459.67 ) *  5/9 }
%      {Re} { ( #1 - 32 ) * 4/9 } 
%    }
% \end{lstlisting}
%
% This defines the key \myunit{F} with the values \myunit{F}, \myunit{C}, 
% \myunit{K} and \myunit{Re}.
%
% \end{cuexample}
%
%
%
% \begin{function}{\cuaddkeys,\cuaddsinglekeys}
%
%   \begin{syntax}
%     \mycs{cuaddkeys}\marg{unit-key-1}
%     \ \ \{
%     \ \ \ \ \marg{unit-key-2} \marg{$1$ unit-key-1 are \dots\ unit-key-2}
%     \ \ \ \ \marg{unit-key-3} \marg{$1$ unit-key-1 are \dots\ unit-key-3}
%     \ \ \ \ \marg{unit-key-4} \marg{$1$ unit-key-1 are \dots\ unit-key-4}
%     \ \ \ \ \dots
%     \ \ \}
%    
%     \mycs{cuaddsinglekeys}\marg{unit-key-1}
%     \ \ \{
%     \ \ \ \ \marg{unit-key-2} \marg{$1$ unit-key-2 are \dots\ unit-key-1}
%     \ \ \ \ \marg{unit-key-3} \marg{$1$ unit-key-3 are \dots\ unit-key-1}
%     \ \ \ \ \dots
%     \ \ \}
%   \end{syntax}
%
%   These commands add \meta{unit-key-2}, etc. to the already defined
%   key \meta{unit-key-1}.
%
%   \lstinline|\cuaddkeys| takes the already defined key
%   \marg{unit-key-1} as a \enquote{basis}, and adds
%   \meta{unit-key-2}, \meta{unit-key-3}, etc. to its
%   values. Furthermore it adds those new values to other keys linked
%   to \meta{unit-key-1} and defines the new keys \meta{unit-key-2},
%   etc.\ with the same values as \meta{unit-key-1}.
%  
%  
%   If the conversion is more complicated use
%   \lstinline|\cuaddsinglekeys|.  It adds \meta{unit-key-2}, etc.\ as
%   values to \meta{unit-key-1}.  The numerical input can be placed
%   using \myunit{\#1} (see \lstinline|\cudefinesinglekey|).  This
%   command neither defines new keys nor does it add values to other
%   keys than \meta{unit-key-1}.
%
%
% \end{function}
%
%
% \begin{cuexample}
%   Suppose you are British (I am sorry, I can't think of another
%   reason to use those units) and you want to implement 'stone' (yes,
%   I was surprised myself that such a unit exists, but it even
%   appears in a Sherlock Holmes story). You exactly know that
%   \SI{1}{\st} equals \SI{14}{\lb}, well \dots\ now you have two
%   choices. \lstinline|\cuaddkeys| or \lstinline|\cuaddtokeys| (use
%   the one best fitting). This example uses the first, the next the
%   latter one.
% \begin{lstlisting}
%  \newcookingunit{st} %% defining new unit 'stone'
%  \cuaddkeys{lb}  %% adding st to lb (could also add to kg, dag and oz)
%    { 
%      {st} { 1/14 }  %% 1 lb are 1/14 st as 14 lb are 1 st
%    }        
% \end{lstlisting}
% \begin{cuexamplecode}
% \cunum[lb=st]{1}{lb} \\
% \cunum[st=lb]{1}{st} \\
% \cunum[st=g]{1}{st} \\
% \cunum[st=kg]{1}{st} \\
% \cunum[kg=st]{1}{kg} \\
% \cunum[st=kg]{16}{st} 
% \end{cuexamplecode}
% \end{cuexample}
%
%
% \begin{cuexample}
%   Now you want to add degree R{\o}mer and convert Celsius to degree
%   R{\o}mer:
% \begin{equation*}
%   T_{R\text\o} = T_C * \frac{21}{40} + 7.5
% \end{equation*}
%
% \begin{lstlisting}
%  %% defining new unit 'degree R{\o}mer'
%  \newcookingunit [\ensuremath{ {} ^ { \circ } }\kern-\scriptspace R{\o}] {Ro} 
%  \cuaddsinglekeys {C} %% adds value 'Ro' to 'C'.
%    {
%      {Ro} { #1 * 21/40 + 7.5 }
%    }
%  \cusetup %% round to integer automatically
%    {
%      set-option-for-Ro = { round-precision = 0 }
%    }
% \end{lstlisting}
% \begin{cuexamplecode}
% \cunum{10}{C} \\
% \cunum[C=Ro]{10}{C} 
% \end{cuexamplecode}
% \end{cuexample}
%
%
%
%
%
%
%
%
%
%
%
% \begin{function}{\cuaddtokeys}
%   \begin{syntax}
%     \mycs{cuaddtokeys} \marg{unit-key-1} \marg{unit-key-2} \marg{$1$ unit-key-2 are \dots\ unit-key-1}
%   \end{syntax}
%   Works similar to \mycs{cuaddkeys} regarding the definition of keys.
% \end{function}
%
% \begin{cuexample}
% Continuing the example from before, this time with \lstinline|\cuaddtokeys|:
% \begin{lstlisting}
%  \newcookingunit{st} %% defining (again) new unit 'stone'
%  \cuaddtokeys {lb} {st} { 14 }  %% 1 st are 14 lb
% \end{lstlisting}
% \begin{cuexamplecode}
% \cunum[lb=st]{1}{lb} \\
% \cunum[st=lb]{1}{st} \\
% \cunum[st=g]{1}{st} \\
% \cunum[st=kg]{1}{st} \\
% \cunum[kg=st]{1}{kg} \\
% \cunum[st=kg]{16}{st} 
% \end{cuexamplecode}
% \end{cuexample}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \section{Language support}
% \label{sec:language}
%
% Unit names and symbols depend on the language.  To change the
% name and symbol for given language you can use \lstinline|\cudefinename|;
%  to only change symbols use \lstinline|\cudefinesymbol|.
%
% \begin{function}{decimal-mark,cutext-range-sign, one(m),one(f),one(n)}
%   Those are special keys (as they cannot be used as units). Not only
%   are printed units language depending, but as is the decimal mark
%   (|.| or |,|) and the text which substitutes the range-sign. 
%   To set the decimal mark use
%   \opt{decimal-mark} (see examples below), to set the range-sign for \cCutext\
%   use \opt{cutext-range-sign}.
%
%   Note that \opt{cutext-range-sign} is \enquote{overwritten} by the \emph{option}
%  \opt{cutext-range-sign}. If the \emph{option} is set, then the language symbol
%  will be ignored.
%
%   Furthermore if you are using numerals
%   you may also use the keys \opt{one(m)}, \opt{one(f)} and
%   \opt{one(n)}. Integers below a certain
%   value (see option \opt{use-numerals-below}) are written-out. The
%   only problem is the written-out \enquote{1} mostly depends on the
%   gender of the word following (e.g. \enquote{ein Baum} (m),
%   \enquote{eine Pflanze} (f) and \enquote{ein Auto} (n)). To set the
%   written-out \enquote{1} to be correct with the gender of the used unit, use
%   these keys (see also examples below)
% \end{function}
%
% \begin{function}{\cudefinename}
%   \begin{syntax}
%     \mycs{cudefinename}\marg{Language}
%      \ \ \{
%      \ \ \ \ \marg{unit-key-1} \oarg{symbol-1} \marg{singular-1} \oarg{plural-1} \myaarg{gender}
%      \ \ \ \ \marg{unit-key-2} \oarg{symbol-2} \marg{singular-2} \oarg{plural-2} \myaarg{gender}
%      \ \ \ \ \dots
%      \ \ \}
%   \end{syntax}
%   
%   This command defines the names (and optionally the symbol) of the
%   units printed in \lstinline|\cutext| and \lstinline|\Cutext|
%   (and \lstinline|\cunum| regarding the symbol) for the specific
%   \meta{Language}. For details regarding \meta{language} see the
%   \pkg{translations} documentation.
%
%   If the plural form of the name differs from the singular form use
%   \oarg{plural} to specify the plural form, else it will be equal to its singular
%   form. The singular form
%   is only used if the number in \lstinline|\cutext| and
%   \lstinline|\Cutext| is equal to $1$.
%
%   \meta{gender} can be \texttt{m} (maskulin), \texttt{f} (feminin) or
%   \texttt{n} (neutrum). If not given \texttt{m} is used as default.
% \end{function}
%
% \begin{lstlisting}
%  \cudefinename {English}
%    {
%      {kg}  {kilogramme}
%      {oz}  {ounce} 
%      {h}   {hour} [hours]
%      {C}   {degree\space Celsius} [degrees\space Celsius]
%      {decimal-marker} {.}
%      {cutext-range-sign} {~to~}
%      {one(m)} {one}
%      {one(f)} {one}
%      {one(n)} {one}
%   }
% \end{lstlisting}
% \begin{lstlisting}
%  \cudefinename {German}
%    {
%      {kg}  {Kilogramm} <n>
%      {oz}  {Unze} <f>
%      {d}   {Tag} [Tage]
%      {h}   {Stunde} [Stunden] <f>
%      {C}   {Grad\space Celsius}
%      {decimal-marker} {,}
%      {cutext-range-sign} {~bis~}
%      {one(m)} {ein}
%      {one(f)} {eine}
%      {one(n)} {ein}
%    }
% \end{lstlisting}
%
%
% \begin{function}{\cudefinesymbol}
%
%   \begin{syntax}
%     \mycs{cudefinesymbol}\marg{Language}
%      \ \ \{
%      \ \ \ \ \marg{unit-key-1} \marg{symbol-1} 
%      \ \ \ \ \marg{unit-key-2} \marg{symbol-2} 
%      \ \ \ \ \dots
%      \ \ \}
%   \end{syntax}
%   
%   This command defines the symbols of the units printed in
%   \lstinline|\cunum| for the specific \meta{Language}.  It works
%   similar as \lstinline|\cudefinename|, but only the symbols (and no
%   names) can be set.   For details regarding \meta{Language} see
%   the \pkg{translations} documentation.
%
% \end{function}
%
%
% \begin{lstlisting}
%  \cudefinesymbol {English}
%    {
%      {decimal-mark} {.}
%      {cutext-range-sign} {~to~}
%      {one(m)} {one}
%      {one(f)} {one}
%      {one(n)} {one}
%    }
%  \cudefinesymbol {German}
%    {
%      {decimal-mark} {,}
%      {cutext-range-sign} {~bis~}
%      {one(m)} {ein}
%      {one(f)} {eine}
%      {one(n)} {ein}
%    }
%  \cudefinesymbol {French}
%    {
%      {l} {L}
%      {dl} {dL}
%      {cl} {cL}
%      {ml} {mL}
%      {decimal-mark} {.}
%      {one(m)} {un}
%      {one(f)} {une}
%      {one(n)} {un}
%    }
% \end{lstlisting}
%
% \begin{cuexample}
%  Imagine that instead of the abbreviation \enquote{dag} for \enquote{decagramme}
%  you want to use \enquote{ducks} (because \dots\ I don't know). You can easily
%  do this via
%  \begin{lstlisting}
%  \cudefinesymbol {English}
%    {
%      {dag} {ducks}
%    }
%  \end{lstlisting}
%  \cudefinesymbol {English}
%    {
%      {dag} {ducks}
%    }
% As you can see it may be a bit suboptimal as there is no plural version allowed.
% You do it anyway and end up with:
%  \begin{cuexamplecode}
%    \cunum{12}{dag} & weed\\
%    \cunum{3}[0]{dag} & nuts\\
%    \cunum{10}{dag} & duckmeat
%  \end{cuexamplecode}
%
%
% \end{cuexample}
%
%
%
%
%
%
% \subsection{Phrases}
% \label{sec:phrases}
%
% Each language has synonyms for certain (integer) numbers. This package
% supports those phrases and they can be implemented with the following
% command and used by \mycs{cuam}:
%
% \begin{function}{\cudefinephrase}
%   \begin{syntax}
%     \mycs{cudefinephrase}\marg{Language}
%      \ \ \{
%      \    \marg{integer-1}   \marg{phrase-1} \oarg{phrase-1-plural} \myaarg{gender-1}
%      \    \marg{integer-2} * \marg{phrase-2} \oarg{phrase-2-plural} \myaarg{gender-2}
%      \    \dots
%      \ \ \}
%   \end{syntax}
%   
%   This command pairs for a given \marg{Language} (see package \pkg{translations})
%   the number \marg{integer-1}
%   with \marg{phrase-1} (\& plural and gender). The package then checks if the amount
%   given in \mycs{cuam} is either this number or a \emph{multiple} of it.
%
%   If the behavior of checking for a multiple is not wanted, you can use the optional
%   star \texttt{*} for a given \marg{integer}
%
%   \meta{gender} can be \opt{m}, \opt{f} or \opt{n}. It is \opt{m} by default.
%   
%   Afterwards the numbers are ordered from highest to lowest so that
%   the phrase with the highest number is used (if used at all).
%
%   Furthermore, it chooses star (|*|) phrases over non-star phrases.   
%   \begin{cunote}
%     Numbers with the optional star |*| are stored as negative numbers. 
%   \end{cunote}
% \end{function}
% \begin{cuexample}
%   The following example creates some phrases for the language
%   \enquote{German}:
%   
% \cudefinephrase {German}
%   {
%      { 60 }  {Schock} <n>
%      { 6  }* {halbes\  Dutzend} <n>
%   }
%
%
% \begin{lstlisting}
%  \cudefinephrase {German}
%    {
%      { 12 }  {Dutzend} <n> %% implemented by default
%      { 60 }  {Schock} <n>
%      { 6  }* {halbes\ Dutzend} <n>
%    }
% \end{lstlisting}
%   Let's just use them (german language activated!):
%^^A   \begin{myde}
%   \begin{cuexamplecode}
%     \selectlanguage{ngerman} @
%     \cusetup{use-phrases=true} @
%     \cuam{12} \\
%     \cuam{24} \\
%     \cuam{60} \\
%     \cuam{120} \\
%     \cuam{6} \\
%     \cuam{18} 
%   \end{cuexamplecode}
%^^A   \end{myde}
%
% As you can see, \enquote{Schock} ($60$) is preferred over \enquote{Dutzend} ($12$)
% as it linked to the higher number. Furthermore, for $6$ the phrase \enquote{halbes
% Dutzend}  (half a dozen) is used, but because it is a star version it is \emph{not}
% used for $18$.
%
% \end{cuexample}
% 
%
% \section{Options}
% \label{sec:options}
%
%
% Options in \pkg{cooking-units} can mostly be set globally using
% \lstinline|\cusetup| or locally using the optional argument of the
% respective command (but \emph{not} as a package option).  The only
% exception is the option given in \cref{sec:load-time-options} which
% needs to be used as a package option.
%
% \begin{function}{\cusetup}
%   \begin{syntax}
%     \mycs{cusetup}\marg{options}
%   \end{syntax}
%   Options can be set using \mycs{cusetup}\Arg{options}.
% \end{function}
%
%
% \begin{function}{\cusetoptionfor,\cuaddoptionfor,\cuclearoptionfor}
%   \label{code:set-option}
%   \begin{syntax}
%     \mycs{cusetoptionfor}\marg{unit-list}\marg{options}
%     \mycs{cuaddoptionfor}\marg{unit-list}\marg{options}
%     \mycs{cuclearoptionfor}\marg{unit-list}
%   \end{syntax}
%   \pkg{cooking-units} allows you to attach options to units.
%    Those
%   options are  activated if (and only if) the specific unit is used \emph{or} 
%   if another unit is converted
%   into it. Those options allow you to e.g.\ round temperatures to
%   integers automatically. Furthermore, those added options are
%   overwritten by local options.
%
%   \mycs{cusetoptionfor} \emph{sets}  \meta{options} to each unit  in \meta{unit-list}
%   overwriting the old ones.
%
%   \mycs{cuaddoptionfor} \emph{add}s \meta{options} to each unit  in \meta{unit-list}.
%   
%   \mycs{cuclearoptionfor} clears all options given to each unit in \meta{unit-list}.
% \end{function}
% \begin{cuexample}
%   Temperatures \myunit{C}, \myunit{F}, \myunit{K} and \myunit{Re} are
%  by default rounded to integers.
%   \begin{cuexamplecode}
%     \cunum{75.23}{C} \\
%     \cunum{75.23}{F} \\
%     \cunum{75.23}{K} \\
%     \cunum{75.23}{Re} \\
%     \cusetoptionfor{C,F,K,Re}{round-precision=-1} @
%     \cunum{75.23}{C} \\
%     \cunum{75.23}{F} \\
%     \cunum{75.23}{K} \\
%     \cunum{75.23}{Re} \\
%     \cuclearoptionfor{C,F,K,Re} @
%     \cunum{75.23}{C} \\
%     \cunum{75.23}{F} \\
%     \cunum{75.23}{K} \\
%     \cunum{75.23}{Re}
%   \end{cuexamplecode}
% \end{cuexample}
%
% \subsection{Load time options}
% \label{sec:load-time-options}
% \begin{function}{use-fmtcount-numerals}
%   \begin{syntax}
%     \cs{usepackage}[use-fmtcount-numerals=\meta{true/false}]\{cooking-units\}
%   \end{syntax}
%   If set to \true\ loads package \pkg{fmtcount} and uses 
%   \cs{numberstringnum}  for \mycs{cutext}
%   and \cs{Numberstringnum} for \mycs{Cutext} to write-out numbers below
%   \opt{use-numerals-below} ($13$ by default), integers above are
%   printed as numbers. 
%   You can decide to not print any numerals by setting \opt{print-numerals}
%   to \false.
%
%  Note: You don't need to use this function to use numerals. Using 
%  \opt{print-numerals} and setting \opt{numeral-function} and \opt{Numeral-function}
%  also works.
% \end{function}
% 
% \cusetup{print-numerals=true}
% \begin{cuexamplecode}
%   \cutext{1}{kg} \\
%   \Cutext{1}{kg} \\
%   \cutext{2}{kg} \\
%   \Cutext{2}{kg} \\
%   \cutext{12}{kg} \\
%   \Cutext{12}{kg} \\
%   \cutext{13}{kg} \\
%   \cutext{13}{kg} \\
%   \Cutext{14}{kg} 
% \end{cuexamplecode}
% \cusetup{print-numerals=false}
% 
%   \begin{cunote}
%     \opt{use-fmtcount-numerals} is a package option as it needs to load
%     \pkg{fmtcount} which is not loaded by default.
%   \end{cunote}
%
%   \begin{cunote}
%   Please note the keys \opt{one(m)}, \opt{one(f)}
%   and \opt{one(n)} to change the printed \enquote{one} (as
%   \enquote{one} is in many languages dependent on the gender of the
%   following word. E.g in German:  Masculine: ein Baum,
%   Feminin: eine Pflanze, Neutrum: ein Auto).
%   \end{cunote}
%
% \begin{cunote}
%   You can always change the functions used to print numerals with
%  \opt{numeral-function} and \opt{Numeral-function}. 
% \end{cunote}
%
% \subsection{Normal options}
%
% Options in this subsection can only be set as local options or using
% \lstinline|\cusetup|, but \emph{not}  as load time options.
% 
%
% \subsubsection{Unit Specific options} 
% \label{sec:opt:unit-spec}
%
% \begin{function}{<unit>}
%   \begin{syntax}
%     \meta{unit-key-1} = \meta{unit-key-2}
%  \end{syntax}
%  Change \meta{unit-key-1} to \meta{unit-key-2} (see
%  \cref{sec:defining-opt} to define new options).
% \end{function}
%
% \begin{function}{<group>}
%   \begin{syntax}
%     \meta{group} = \meta{unit-key}
%  \end{syntax}
%  Changes each unit contained in \meta{group} to \meta{unit-key} (\meta{unit-key}
%  must be part of \meta{group}).
%
%  \begin{center}
%  \begin{tabular}{ll}
%    \toprule
%    \meta{group} & default \meta{unit-key}s \\ \midrule
%    \PrintGroup{weight}  \\ 
%    \PrintGroup{length} \\ 
%    \PrintGroup{volume} \\ 
%    \PrintGroup{temperature} \\ 
%    \PrintGroup{energy} \\ 
%    \PrintGroup{time} \\  \bottomrule
%  \end{tabular}
%  \end{center}
% \end{function}
%
% \begin{cuexamplecode}
%  \cusetup{weight=g} @
%  \cunum{1}{kg} \\
%  \cunum{1}{dag} \\
%  \cunum{1}{g} \\
%  \cunum{1}{oz} \\
%  \cunum{1}{lb} \\
%  \cunum{1}{stick} \\
% \end{cuexamplecode}
%
% You can define new groups using \mycs{cudeclareunitgroup}:
% \begin{function} {\cudeclareunitgroup}
%   \begin{syntax}
%     \mycs{cudeclareunitgroup} \marg{group-name} \marg{unit-list}
%   \end{syntax}
%   Defines the group \meta{group-name} containing the list \meta{unit-list}.
%   This allows the usage of |\meta{group-name}=\meta{unit-key}| to
%   change all units in the group \meta{group-name} to \meta{unit-key}
%   (which has to be part of \meta{unit-list}).
% \end{function}
%
% \begin{cuexample}
%   Define the group \enquote{weight}:
%    \begin{lstlisting}
%      \cudeclareunitgroup {weight} { kg , dag, g, oz, lb, stick }
%    \end{lstlisting}
% Now \lstinline|\cusetup{weight=dag}| can be used to change all units
% contained in |weight| to |dag|.
% \end{cuexample}
%
%
% \begin{function}{\cuaddtounitgroup}
%   \begin{syntax}
%     \mycs{cuaddtounitgroup}\marg{group}\marg{unit-list}
%   \end{syntax}
%    Adds \meta{unit-list} to an already existing \meta{group} (both need to exist).
% \end{function}
% \begin{cuexample}
%  Adding \myunit{st} to the group \mygroup{weight}
% \begin{cuexamplecode}
%   \cuaddtounitgroup {weight} {st} @
%   \cusetup{weight = g } @
%  \cunum{1}{kg} \\
%  \cunum{1}{dag} \\
%  \cunum{1}{g} \\
%  \cunum{1}{oz} \\
%  \cunum{1}{lb} \\
%  \cunum{1}{stick} \\
%  \cunum{1}{st} 
% \end{cuexamplecode}
% \end{cuexample}
%
%
% \begin{function}{add-unit-to-group}
%   \begin{syntax}
%     add-unit-to-group = 
%     \  \{
%     \    \meta{group1} = \marg{unit-key-list}, 
%     \    \meta{group2} = \marg{unit-key-list}, 
%     \    \dots 
%     \  \}
%  \end{syntax}
%  Adds each \meta{unit-key} in \meta{unit-keys-list} to \meta{group}.
% The key-val equivalent of \mycs{cuaddtounitgroup}.
% \end{function}
% \begin{cuexample}
% The same as above: 
%   This example adds the unit \myunit{st} to the group \mygroup{weight}
%   and \myunit{Ro} to \mygroup{temperature}.
% \begin{lstlisting}
%  \cusetup 
%    { 
%      add-unit-to-group = { weight = {st} , temperature = {Ro} }
%    }
% \end{lstlisting}
%
%  \cusetup{ add-unit-to-group = { weight = {st} } }
%
% \begin{cuexamplecode}
%  \cusetup{weight=g} @
%  \cunum{1}{kg} \\
%  \cunum{1}{dag} \\
%  \cunum{1}{g} \\
%  \cunum{1}{oz} \\
%  \cunum{1}{lb} \\
%  \cunum{1}{stick} \\
%  \cunum{1}{st} 
% \end{cuexamplecode}
% \end{cuexample}
%
%
% 
% \begin{function}{set-option-for-<unit-key>,add-option-for-<unit-key>}
%   \begin{syntax}
%     set-option-for-\meta{unit-key} = \marg{ key1 = value1, \dots\ }
%     add-option-for-\meta{unit-key} = \marg{ key1 = value1, \dots\ }
%  \end{syntax}
%  Sets and adds \meta{key1=value1,\dots} to a specific
%  \meta{unit-key},
%  \opt{erase-all-options} (see below) is used to erase all options for all
%  \meta{unit-key}s.
%  
% The less flexible key-value version of \mycs{cusetoptionfor} and
% \mycs{cuaddoptionfor}.
%
%
%^^A  You may want to attach some options to a special
%^^A  \meta{unit-key}. Those options are automatically activated if (and
%^^A  only if) the specific \meta{unit-key} is used (or changed into this
%^^A  unit). Setting options overwrites old options. Adding options, well
%^^A  \dots\ adds the options to the old ones.
%  
%^^A You can \enquote{delete} the  options by setting
%^^A an empty value for a specific \meta{unit-key} (or use
%^^A \opt{erase-all-options} (or \opt{erase-all-options-for} )
%^^A (see below) to erase all options for all \meta{unit-key}s)
%  
% \end{function}
% 
% \begin{cuexample}
%  The following rounds the values to integers for \myunit{F}, \myunit{C}, 
%  \myunit{K} and \myunit{Re}:
% \begin{lstlisting}
%  \cusetup 
%    { 
%      set-option-for-F  = { round-precision = 0 } ,
%      set-option-for-C  = { round-precision = 0 } ,
%      set-option-for-K  = { round-precision = 0 } ,
%      set-option-for-Re = { round-precision = 0 } 
%    }
% \end{lstlisting}
% although note that it would be easier to simply write
% \begin{lstlisting}
%  \cusetoptionfor {F,C,K,Re} { round-precision = 0 } 
% \end{lstlisting}
%
% \end{cuexample}
%
%
% \begin{function}{set-option-for, add-option-for}
%   \begin{syntax}
%     set-option-for = 
%     \  \{
%     \    \meta{unit-key1} = \marg{keys=vals}, 
%     \    \meta{unit-key2} = \marg{keys=vals},
%     \    \dots
%     \  \}
%     add-option-for = 
%     \  \{
%     \    \meta{unit-key1} = \marg{keys=vals}, 
%     \    \meta{unit-key2} = \marg{keys=vals},
%     \    \dots
%     \  \}
%  \end{syntax}
%  Sets/adds each \meta{keys=vals} to the specific \meta{unit-key}. Works pretty much
%  the same way their \opt{set-option-for-\meta{unit-key}} and
% \opt{add-option-for-\meta{unit-key}} counterparts.
%
% The less flexible versions of the commands \mycs{cusetoptionfor} and
% \mycs{cuaddoptionfor}.
% \end{function}
%
% \begin{cuexample}
% The following example does the same as the example above: 
% \begin{lstlisting}
%  \cusetup 
%    { 
%      set-option-for = 
%        { 
%          F  = { round-precision = 0 } ,
%          C  = { round-precision = 0 } ,
%          K  = { round-precision = 0 } ,
%          Re = { round-precision = 0 }
%        }
%    }
% \end{lstlisting}
% \end{cuexample}
%
% \begin{function}{erase-all-options, erase-all-options-for}
%   \begin{syntax}
%     erase-all-options
%     erase-all-options-for = \marg{unit-key1, unit-key2, \dots}
%   \end{syntax}
%   Erase options added to units. \opt{erase-all-options} erases all options
%   for \emph{all} \meta{unit-key}s.
%
%^^A  If you only want to erase options for specific \meta{unit-key}s, you may
%^^A  use \opt{erase-all-options-for}.
%
% \opt{erase-all-options-for} is used to remove added options from 
% the specified \meta{unit-key}s (key-value version of  \mycs{cuclearoptionfor}).
%
% \end{function}
%
% \begin{cuexample}
%  The following code erases all attached options from \myunit{C}, \myunit{F}, 
%  \myunit{K} and \myunit{Re}:
%
%   \begin{lstlisting}
%     \cusetup{ erase-all-options-for = {C, F, K, Re} }
%   \end{lstlisting}
%  It's the same as
%   \begin{lstlisting}
%     \cuclearoptionfor {C, F, K, Re}
%   \end{lstlisting}
% \end{cuexample}
%
%
%
% \subsubsection{Command behavior}
%
% \begin{function}{cutext-to-cunum}
%   \begin{syntax}
%     cutext-to-cunum = \meta{true/false}
%   \end{syntax}
%   Want to get rid of all \cCutext? Set this option to \opt{true} and all
%   \cCutext\ are changed into \mycs{cunum}.
% \end{function}
% \begin{cuexamplecode}
%   \cutext{1}{kg} \\
%   \Cutext{2}{kg} \\
%   \cutext{1/2}{kg} \\
%   \cutext{?}{kg} \\
%   \cutext[kg=g]{1--2}{kg} \\
%   \cusetup{cutext-to-cunum = true } @
%   \cutext{1}{kg} \\
%   \Cutext{2}{kg} \\
%   \cutext{1/2}{kg} \\
%   \cutext{?}{kg} \\
%   \cutext[kg=g]{1--2}{kg}
% \end{cuexamplecode}
%
%
% \begin{function}{cutext-change-unit}
%   \begin{syntax}
%     cutext-change-unit = \meta{true/false}
%   \end{syntax}
%   Set this option to \opt{false} if you do \emph{not} want the units of \cCutext\
%  to be changed. Set to \true\ by default
% \end{function}
% \begin{cuexamplecode}
%   \cutext[kg=g]{1}{kg} \\
%   \cutext[kg=g]{1/2}{kg} \\
%   \cutext[kg=g]{1--2}{kg} \\
%   \cusetup{cutext-change-unit = false } @
%   \cutext[kg=g]{1}{kg} \\
%   \cutext[kg=g]{1/2}{kg} \\
%   \cutext[kg=g]{1--2}{kg}
% \end{cuexamplecode}
%
% \begin{function}{cuam-version,cutext-version}
%   \begin{syntax}
%     cuam-version = \meta{old/new}
%     cutext-version = \meta{old/new}
%   \end{syntax}
%   Since v1.10 this package also parses and checks the input of
%   \cCutext\ and \mycs{cuam}. If you want to restore the old
%   behavior, set this option to \opt{old}, but note that then you can
%   neither change the amounts for a given number of persons nor
%   change the unit of \cCutext. Both of them are set to \opt{new} by
%   default.
% \end{function}
%
%
%
%
% \subsubsection{Hooks}
%
% \begin{function}{commands-add-hook,cunum-add-hook,cutext-add-hook,Cutext-add-hook,cuam-add-hook}
%   \begin{syntax}
%      commands-add-hook = \marg{code}
%      cunum-add-hook  = \marg{code} 
%      cutext-add-hook = \marg{code} 
%      Cutext-add-hook = \marg{code} 
%      cuam-add-hook   = \marg{code}
%   \end{syntax}
%   Adds \meta{code} to the respective command (or in case of the first key: 
%   to \emph{all} commands). The hook is executed
%   \emph{after} setting the keys, but \emph{before} parsing and processing the input.
%
%   Please be carful with spaces, they will be printed.
% \end{function}
%
% \begin{cuexample}
%   You would like to count how often all commands of this package are used.
%   Simply add:
%   \begin{lstlisting}
%     \newcounter{CookingUnitsCounter} %% or however you like it
%     \cusetup{commands-add-hook={\stepcounter{CookingUnitsCounter}}}
%        %% beware of spaces inside the add-hook keys.
%   \end{lstlisting}
%   to your preamble. The following table lists how often each command
%   is used in this documentation (with help of \pkg{totalcount}):
%
%  \begin{center}
%   \begin{tabular}{lr} 
%     \toprule
%     command & times \\ \midrule
%     \mycs{cunum} & \totalcunumCounters \\
%     \mycs{cutext} & \totalcutextCounters \\
%     \mycs{Cutext} & \totalCutextCounters \\
%     \mycs{cuam} & \totalcuamCounters  \\
%     \cmidrule{2-2}
%     total & \totalCookingUnitsCounters \\
%     \bottomrule
%   \end{tabular}
%  \end{center}
% \end{cuexample}
%
% \subsubsection{Input and Outputs}
%
%
% \begin{function}{expand-both , expand-amount, expand-unit}
%   \begin{syntax}
%     expand-both = \meta{n/o/f/x}
%     expand-amount = \meta{n/o/f/x}
%     expand-unit = \meta{n/o/f/x}
%   \end{syntax}
%   By default the commands \mycs{cunum}, \cCutext{} and \mycs{cunum}
%   do \emph{not} expand their input. You can change the expansion behavior of
%   \meta{amount} and/or \meta{unit-key} using the options specified
%   above. The meaning of the available values are the same as specified
%   in the \LaTeX3\ document \enquote{interface3}.
%
%   It is set to \texttt{n} (no expansion) by default.
%
% \end{function}
%
%
%
%
% \begin{function}{set-special-sign,add-special-sign}
%   \begin{syntax}
%     set-special-sign = \marg{character(s)}
%     add-special-sign = \marg{character(s)}
%   \end{syntax}
%   Allows \meta{character(s)} to be used in the first mandatory argument of 
%  \mycs{cunum}, \mycs{cuam}, \cCutext{} without raising an error (you can customize this
%  behavior, see \opt{set-unknown-message}). By default it is set to |?|.
%  Please note that the sign |<| is not allowed as a special sign.
% \end{function}
%
% \begin{cuexamplecode}
%   \cunum{?}{kg} \\
%   \cunum[g=kg]{10?--20?}{kg} \\
%   \cusetup{add-special-sign={xX} } @
%   \cunum{x}{kg} \\
%   \cunum{X--?}{kg} \\
%   \cusetup{set-special-sign={} } @
%   \cunum{1}{kg} \\
%   \cunum{1--2}{kg} 
% \end{cuexamplecode}
%
% \begin{function}{set-unknown-message}
%   \begin{syntax}
%     set-unknown-message = \meta{error/warning/none}
%   \end{syntax}
%   Using a special sign (\texttt{?} by default) causes a warning to
%   be raised. Set this option to \opt{error} if you want an error (as
%   an extra emphasis), \opt{warning} if you want a warning (default)
%   and \opt{none} if you don't want to know anything about it.
% \end{function}
%
% \begin{function}{set-cutext-translation-message}
%   \begin{syntax}
%     set-cutext-translation-message = \meta{error/warning/none}
%   \end{syntax}
%   If a translation for \cCutext\ is not available the commands are replaced
%   by \mycs{cunum}. Currently -- if this is happening -- a warning is shown,
%  you may change the behavior of the message (error, warning or not showing at all)
%  using this option.
% \end{function}
%
% \begin{function}{print-numerals}
%   \begin{syntax}
%     print-numerals = \meta{true/false}
%   \end{syntax}
%
%  Prints numerals for integers smaller then \opt{use-numerals-below} if
%  set to \true. If set to \false\ no numerals are printed. 
%
%  If you use the package option \opt{use-fmtcount-numerals} this option 
%  is automatically set to \true.
%
%  If you want to use another package, just set this option to \true\ and
%  use \opt{numeral-function} and \opt{Numeral-function}.
% 
%^^A   If the package option \opt{use-fmtcount-numerals} is set to \true\ you can
%^^A   deactivate the printing of numerals by setting \opt{print-numerals} to 
%^^A   \false\ and activate them by setting it to \true.
%
% \end{function}
% \begin{cuexample}
% (Using the package option \opt{use-fmtcount-numerals}:
% \cusetup{ print-numerals=true }
% \begin{cuexamplecode}
%   \cutext{1}{kg} \\
%   \cutext{2}{kg} \\
%   \cutext{12}{kg} \\
%   \cutext{13}{kg} \\
%   \cusetup{ print-numerals=false } @
%   \cutext{1}{kg} \\
%   \cutext{2}{kg} \\
%   \cutext{12}{kg} \\
%   \cutext{13}{kg} \\
% \end{cuexamplecode}
% \cusetup{ print-numerals=false }
% \end{cuexample}
%
% \begin{function}{use-numerals-below}
%   \begin{syntax}
%     use-numerals-below = \meta{integer}
%   \end{syntax}
%   If \opt{print-numerals} is \true, prints the numerals in
%   \mycs{cutext} and \mycs{Cutext} for integers smaller than
%   \meta{integer}. \meta{integer} is by default 13. 
%   You can deactivate the printing of numerals by \opt{print-numerals=false}.
% \end{function}
% \cusetup{ print-numerals=true }
% \begin{cuexamplecode}
%   \cutext{1}{kg} \\
%   \cutext{2}{kg} \\
%   \cutext{12}{kg} \\
%   \cutext{13}{kg} \\
%   \cusetup{ use-numerals-below=10 } @
%   \cutext{1}{kg} \\
%   \cutext{2}{kg} \\
%   \cutext{12}{kg} \\
%   \cutext{13}{kg} \\
%   \cusetup{ use-numerals-below=0 } @
%   \cutext{1}{kg} \\
%   \cutext{2}{kg} \\
%   \cutext{12}{kg} \\
%   \cutext{13}{kg} \\
%   \cusetup{ use-numerals-below=12001 } @
%   \cutext[kg=g]{1}{kg} \\
%   \cutext[kg=g]{2}{kg} \\
%   \cutext[kg=g]{12}{kg} \\
%   \cutext[kg=g]{13}{kg} \\
% \end{cuexamplecode}
% \cusetup{ print-numerals=false } 
%
% \begin{function}{numeral-function, Numeral-function }
%   \begin{syntax}
%     numeral-function = \meta{function}
%     Numeral-function = \meta{function}
%   \end{syntax}
%  Sets the functions used for printing numerals.
%  \opt{numeral-function} is used for lowercase, \opt{Numeral-function}
%  for capitalized cases.
% \end{function}
% \begin{cuexample}
%  Using the commands from \pkg{fmtcount} you can set the
% numeral function equal to
%  \begin{lstlisting}
%    \cusetup{
%      numeral-function = \numberstringnum ,
%      Numeral-function = \Numberstringnum
%    }
%  \end{lstlisting}
%  (this happens if you use the package option \opt{use-fmtcount-numerals})
% \end{cuexample}
%
%
%
% \begin{function}{parse-number}
%   \begin{syntax}
%     parse-number = \meta{true/false}
%   \end{syntax}
%   If set to \false\ prints the number of \lstinline!\cunum!,
%   \lstinline!\cutext!, \lstinline!\Cutext! and \mycs{cuam} as they
%   are (after some \dots\ well \dots\ parsing due to
%   \enquote{\lstinline|_|}). Is set to \true\ by default.
% \end{function}
%
% \begin{cuexamplecode}
%   \cusetup{ parse-number=false } @
%   \cunum[kg=g]{1}{kg} \\
%   \cunum{1--2}{kg} \\
%   \cunum{1----------2}{kg} \\
%   \cunum{1.2}{kg} \\
%   \cunum[kg=g]{1,2}{kg} \\
%   \cunum{1/2}{kg} \\
%   \cunum{1_2/3}{kg} \\
%   \cunum{1/2_3}{kg} \\
%   \cunum{some weird stuff}{kg} \\
%   \cutext{1}{kg} \\
%   \cutext{100}{kg} \\
%   \cutext{gjfak}{kg} \\
%   \cutext[kg=g]{12}{kg} \\
%   \cuam{1----------2} \\
%   \cuam{1,2} \\
%   \cuam{1_1/2} \\
%   \cuam{kwflk} \\
% \end{cuexamplecode}
%
%
%
% \begin{function}{range-sign}
%   \begin{syntax}
%     range-sign = \marg{string}
%     cunum-range-sign = \marg{string}
%     cutext-range-sign = \marg{string}
%   \end{syntax}
%   \opt{cunum-range-sign} sets the \emph{printed} range sign used in \mycs{cunum}
%   (and \mycs{cuam}) to \meta{string}, \opt{cutext-range-sign} sets the printed
%   range sign used in \cCutext{} to \meta{string}.
%   Using \opt{range-sign} sets the
%   range signs for both \mycs{cunum} (and \mycs{cuam}) and
%   \mycs{cutext}/\mycs{Cutext} to \meta{string}.
%
%  The default for \meta{string} is \texttt{-{}-} (for both).
% \end{function}
%
% Since version 1.45 there also exits the language symbol \opt{cutext-range-sign}
% (see \cref{sec:language}). If the \emph{option} \opt{cutext-range-sign} is set
% the language symbol will be ignored.
%
% \begin{cuexamplecode}
%   \cunum{1--2}{kg} \\
%   \cuam{1--2} \\
%   \cutext{1--2}{kg} \\
%   \Cutext{1--2}{kg} 
% \end{cuexamplecode}
% \begin{cuexamplecode}
%   \cusetup{cunum-range-sign={~to~}} @
%   \cunum{1--2}{kg} \\
%   \cuam{1--2} \\
%   \cutext{1--2}{kg} \\
%   \Cutext{1--2}{kg} 
% \end{cuexamplecode}
% \begin{cuexamplecode}
%   \cusetup{cutext-range-sign={--}} @
%   \cunum{1--2}{kg} \\
%   \cuam{1--2} \\
%   \cutext{1--2}{kg} \\
%   \Cutext{1--2}{kg} 
% \end{cuexamplecode}
% \begin{cuexamplecode}
%   \cusetup{range-sign={-to-}} @
%   \cunum{1--2}{kg} \\
%   \cuam{1--2} \\
%   \cutext{1--2}{kg} \\
%   \Cutext{1--2}{kg} 
% \end{cuexamplecode}
%
% \begin{function} {use-phrases}
%   \begin{syntax}
%     use-phrases = \meta{true/false}
%   \end{syntax}
%  Setting this option to \true\ replaces certain integers (see \cref{sec:phrases} for
%  more information) with their phrase counterpart. This option is set to \false\ by default.
% \end{function}
%
% \begin{cuexample}
%^^A \begin{myde}
% For the German language:
% \begin{cuexamplecode}
%   \selectlanguage{ngerman} @
%   \cuam{12} \\
%   \cuam{12--24} \\
%   \cuam{36} \\
%   \cusetup{use-phrases=true} @
%   \cuam{12} \\
%   \cuam{12--24} \\
%   \cuam{36} \\
%   \cusetup{use-phrases=true, print-numerals=true} @
%   \cuam{12} \\
%   \cuam{12--24} \\
%   \cuam{36} \\
% \end{cuexamplecode}
%^^A \end{myde}
% \end{cuexample}
%
%
% \subsubsection{Rounding options}
%
% \begin{function}{round-precision}
%  \begin{syntax}
%    round-precision = \meta{integer}
%  \end{syntax}
%  Rounds the amount automatically to \meta{integer} digits after the
%  colon.  Note that units like \myunit{C}, \myunit{F}, \myunit{K} and
%  \myunit{Re} are still rounded to integers due to
%  \texttt{set-option-for-<unit-key>}.
% \end{function}
%
%  
% \begin{cuexamplecode}
%   \cusetup{round-precision= 5} @
%   \cunum{1.23456789}{kg} \\
%   \cunum[g=kg]{12.587}{g} \\
%   \cunum{194}{kg} \\
%   \cunum[C=F]{200--210}{C} \\
%   \cunum[K=C]{0.0012}{K} \\
%   \cusetup{round-precision= 1} @
%   \cunum{1.23456789}{kg} \\
%   \cunum{12.58}{kg} \\
%   \cunum[g=kg]{194}{g} \\
%   \cunum[C=F]{200--210}{C} \\
%   \cunum[K=C]{0.0012}{K} 
% \end{cuexamplecode}
%
% \begin{cunote}
%  Also negative numbers are allowed.
% \begin{cuexamplecode}
%   \cusetoptionfor{C,F}{round-precision=-1} @
%   \cunum{-271,2}{C} \\
%   \cunum[K=C]{0.0012}{K} \\
%   \cunum{185}{C} \\
%   \cunum[C=F]{180--200}{C} \\
%  \end{cuexamplecode}
% \end{cunote}
%
% \begin{function}{round-to-int}
%   \begin{syntax}
%     round-to-int = \meta{true/false}
%   \end{syntax}
%   \emph{This option is deprecated.} Rounds the amount to an integer if set \true. 
%   Use \opt{round-precision=0} instead.
% \end{function}
%
%
%^^A \begin{cuexamplecode}
%^^A   \cusetup{round-to-int=true} @
%^^A   \cunum{1.23456789}{kg} \\
%^^A   \cunum{12.58}{kg} \\
%^^A   \cunum[g=kg]{194--294}{g} \\
%^^A   \cunum[kg=g]{1.23456789}{kg}
%^^A \end{cuexamplecode}
%
% \begin{function}{round-half}
%   \begin{syntax}
%     round-half = \meta{default/commercial}
%   \end{syntax} 
%   This option is only important for half-way numbers
%   (e.g. $0.005$). By setting it to \opt{default} the value will be
%   rounded to the nearest even number.  Setting it to
%   \opt{commercial} rounds the value away from zero.
%
% It is set to \opt{default} by \dots\ default.
%
%  \begin{cunote}
%    \opt{default} actually refers to the fact that it is the default
%    rounding algorithm used by \cs{fp\_eval:n \{ round( ) \}}
%    without a third argument.
%  \end{cunote}
%
% \end{function}
%
%
% \begin{cuexamplecode}
%   \cusetup{round-half=default} @
%   \cunum{0.005}{kg} \\
%   \cunum{-0.005}{kg} \\
%   \cunum{1.245}{kg} \\
%   \cusetup{round-half=commercial} @
%   \cunum{0.005}{kg} \\
%   \cunum{-0.005}{kg} \\
%   \cunum{1.245}{kg} @
% \end{cuexamplecode}
%
%
%
% \subsubsection{Fractions}
%
% \begin{function}{eval-fraction}
%  \begin{syntax}
%    eval-fraction = \meta{true/false}
%  \end{syntax}
%   This option takes \true\ or \false\ as values.
%   If set to \true\ all fractions are evaluated. Please note that divisions
%  through zero are not allowed.
% \end{function}
%
% \begin{cuexamplecode}
%   \cusetup{eval-fraction=true} @
%   \cunum{1/3}{kg} \\
%   \cunum{1/2}{kg} \\
%   \cunum[kg=g]{1/2}{kg} \\
%   \cunum{1_1/2}{kg} \\
%   \cunum[kg=g]{1_1/2}{kg} \\
%   \cunum[kg=g]{-1_1/2}{kg} \\
%   \cunum[kg=g]{1_2/?}{kg} \\
% \end{cuexamplecode}
%
%
%
% \begin{function}{convert-fraction}
%  \begin{syntax}
%    convert-fraction = \meta{true/false}
%  \end{syntax}
%  By default units of fractions are not converted into another unit. 
%  Setting this option to \true\
%  allows fractions to be evaluated when a change of units is requested
%  (and \emph{only} if a change of unit is requested).
% \end{function}
%
% \begin{cuexamplecode}
%   \cusetup{convert-fraction=true} @
%   \cunum{1/3}{kg} \\
%   \cunum[kg=g]{1/3}{kg} \\
%   \cunum{1_1/2}{kg} \\
%   \cunum[kg=g]{1_1/2}{kg} \\
%   \cunum[kg=g]{1_?/3}{kg} \\
% \end{cuexamplecode}
%
%
%
%
% \begin{function}{fraction-command}
%   \begin{syntax}
%     fraction-command = \cs{command}
%   \end{syntax}
%   Sets the command used for printing fractions equal to \cs{command}.
%   \cs{command} has to take two arguments. By default
%   it is equal to |\sfrac| from \pkg{xfrac}.
%
%   Please note that the amount is \emph{not} printed inside a math
%   environment by default.
% \end{function}
% 
% \begin{cuexamplecode}
%   \newcommand\myfrac[2]{#1/#2} @
%   \cusetup{fraction-command=\myfrac}  @
%   \cuam{1/8} \\
%   \cunum{1/2}{kg} \\
%   \cunum{4/5}{C} \\
%   \cunum{1_2/3}{kg} \\
%   \cusetup{fraction-command=\nicefrac}  @
%   \cuam{1/8} \\
%   \cunum{1/2}{kg} \\
%   \cunum{4/5}{C} \\
%   \cunum{1_2/3}{kg} 
% \end{cuexamplecode}
%
% \begin{function}{fraction-inline}
%   \begin{syntax}
%     fraction-inline = \marg{input containing \#1 and \#2}
%   \end{syntax}
%   Similar to \opt{fraction-command} only that you don't have to 
%   define a command  to alter the output of the fraction.
% \end{function}
% 
% \begin{cuexamplecode}
%   \cusetup{fraction-inline={#1/#2} }  @
%   \cuam{1/8} \\
%   \cunum{1/2}{kg} \\
%   \cunum{4/5}{C} \\
%   \cunum{1_2/3}{kg} \\
%   \cusetup{fraction-inline={\nicefrac{#2}{#1}} }  @
%   \cuam{1/8} \\
%   \cunum{1/2}{kg} \\
%   \cunum{4/5}{C} \\
%   \cunum{1_2/3}{kg} 
% \end{cuexamplecode}
%
% \subsubsection{Spaces}
%
% \begin{function}{mixed-fraction-space}
%   \begin{syntax}
%     mixed-fraction-space = \meta{length}
%   \end{syntax}
%   Sets the length between the fraction and the number in a mixed-fraction,
%   default is \texttt{0.1em} (because I said so; if someone has some literature
%   or sources to look up the space, please let me know).
% \end{function}
% \begin{cuexamplecode}
%   \cuam{1_2/3} \\
%   \cunum{1_2/3}{kg} \\
%   \cunum{10_2/3}{kg} \\
%   \cusetup{mixed-fraction-space=1em } @
%   \cuam{1_2/3} \\
%   \cunum{1_2/3}{kg} \\
%   \cunum{10_2/3}{kg} \\
%   \cusetup{mixed-fraction-space=0em } @
%   \cuam{1_2/3} \\
%   \cunum{1_2/3}{kg} \\
%   \cunum{10_2/3}{kg} 
% \end{cuexamplecode}
%
% \begin{function}{cutext-space}
%   \begin{syntax}
%     cutext-space = \marg{string}
%   \end{syntax}
%   \meta{string} is inserted between the numeral part and the unit part
%   when using \cCutext. By default it is set to \cs{space}. Use this option
%  if you want to e.g.\ insert an unbreakable space.
% \end{function}
% \begin{cuexamplecode}
%   \cutext{1}{kg}\\
%   \Cutext{10}{kg}\\ 
%   \cusetup { cutext-space = ~ } @
%   \cutext{1}{kg}\\
%   \Cutext{10}{kg}\\
%   \cusetup { cutext-space = {} } @
%   \cutext{1}{kg}\\
%   \Cutext{10}{kg}\\
%   \cusetup { cutext-space = {qwe} } @
%   \cutext{1}{kg}\\
%   \Cutext{10}{kg}\\
% \end{cuexamplecode}
%
%
% \begin{function}{phrase-space}
%   \begin{syntax}
%     phrase-space = \marg{string}
%   \end{syntax}
%   \meta{string} is inserted between the numeral part and the phrase part
%   while using \mycs{cuam}. By default it is set to \cs{space}. Use this option
%  if you want to e.g.\ insert an unbreakable space.
% \end{function}
%^^A \begin{myde}
%  \cusetup{use-phrases=true}
% (Switching to german)
% \begin{cuexamplecode}
%   \selectlanguage{ngerman} @
%   \cuam{12}\\
%   \cuam{144}\\
%   \cusetup { phrase-space = ~ } @
%   \cuam{12}\\
%   \cuam{144}\\
%   \cusetup { phrase-space = {} } @
%   \cuam{12}\\
%   \cuam{144}\\
%   \cusetup { phrase-space = {qwe} } @
%   \cuam{12}\\
%   \cuam{144}\\
% \end{cuexamplecode}
%  \cusetup{use-phrases=false}
%^^A \end{myde}
%
% \begin{function}{amount-unit-space}
%   \begin{syntax}
%     amount-unit-space = \marg{string}
%   \end{syntax}
%   Change the spacing for \mycs{cunum} between the printed amount(s) and
%   the unit. The default value is |\thinspace|.
% \end{function}
%
% \begin{cuexamplecode}
%   \cunum{1}{kg}\\
%   \cunum{1/2}{kg}\\
%   \cunum{1--2}{kg}\\
%   \cusetup { amount-unit-space = {\hspace{1em}} } @
%   \cunum{1}{kg}\\
%   \cunum{1/2}{kg}\\
%   \cunum{1--2}{kg}\\
%   \cusetup { amount-unit-space = {} } @
%   \cunum{1}{kg}\\
%   \cunum{1/2}{kg}\\
%   \cunum{1--2}{kg}\\
%   \cusetup { amount-unit-space = {qwe} } @
%   \cunum{1}{kg}\\
%   \cunum{1/2}{kg}\\
%   \cunum{1--2}{kg}\\
% \end{cuexamplecode}
%
% \subsubsection{label \& refs}
%
% \begin{function}{recalculate-amount}
%   \begin{syntax}
%     recalculate-amount = \meta{true/false}
%   \end{syntax}
%   Set this option to \opt{true} if you want to change your recipes to the given
%   number of people set by \opt{set-number-of-persons}. Note that only those
%   values who have a label are changed.
% \end{function}
%
% \begin{function}{set-number-of-persons}
%   \begin{syntax}
%     set-number-of-persons = \meta{integer}
%   \end{syntax}
%   With this option you can determine the number of people your recipes
%   are for. Note that this option only has an effect on those who have a \meta{label}
%   given. It is set to \opt{4} by default. Please also note the use of 
%   \opt{recalculate-amount}.
% \end{function}
% \begin{cuexamplecode}
%   \culabel{anotherrecipe}{2} @
%   \curef{anotherrecipe}~persons \\ 
%   \cunum<anotherrecipe>{1}{kg}\\
%   \cuam<anotherrecipe>{1}\\
%   \cutext<anotherrecipe>{10}{kg}\\
%   \cusetup{ recalculate-amount = true } @
%   \curef{anotherrecipe}~persons \\ 
%   \cunum<anotherrecipe>{1}{kg}\\
%   \cuam<anotherrecipe>{1}\\
%   \cutext<anotherrecipe>{10}{kg}\\
%   \Cutext[ref=anotherrecipe]{10}{kg}\\
% \cusetup { set-number-of-persons = 3 } @
%   \curef{anotherrecipe}~persons \\ 
%   \cunum<anotherrecipe>{1}{kg} \\
%   \cuam<anotherrecipe>{1} \\
%  \cutext<anotherrecipe>{10}{kg}\\
%   \cusetup { set-number-of-persons = 2 } @
%   \curef{anotherrecipe}~persons \\ 
%   \cunum<anotherrecipe>{1}{kg}\\
%   \cuam<anotherrecipe>{1}\\
%   \cutext<anotherrecipe>{10}{kg}\\
%   \cusetup { set-number-of-persons = 1 } @
%   \curef{anotherrecipe}~persons \\ 
%   \cunum<anotherrecipe>{1}{kg}\\
%  \cuam<anotherrecipe>{1}\\
%  \cutext<anotherrecipe>{10}{kg}\\
% \end{cuexamplecode}
% 
%
% \begin{function}{label}
%   \begin{syntax}
%     label = \{\meta{string}*\meta{integer}\}
%   \end{syntax}
%   The key-value version of \mycs{culabel}. It defines the label \meta{string}
%   which is originally for \meta{integer} people. Please note that the \texttt{*}
%   is mandatory as it separates the string from the integer. Each
%   label is defined globally and must be unique.
% \end{function}
% \begin{cuexamplecode}
%   \cusetup{label=Toast*1} @
%   \curef{Toast}~person \\
%   \cuam<Toast>{2} \\
%   \cunum<Toast>{2}{dag} \\
%   \cusetup { recalculate-amount = true } @
%   \curef{Toast}~persons \\
%   \cuam<Toast>{2} \\
%   \cunum<Toast>{2}{dag}
% \end{cuexamplecode}
%
%
% \begin{function}{get-label}
%   \begin{syntax}
%     get-label = \marg{label}
%   \end{syntax}
%   The key-value version of \mycs{curef}. Note that this key doesn't save the value
%   inside a macro but rather prints it directly into the document.
% \end{function}
% \begin{cuexamplecode}
%   \culabel{Schinken}{3} @
%   \cusetup{get-label=Schinken} \\
%   \curef{Schinken} \\
%   \cusetup { recalculate-amount = true } @
%   \cusetup{get-label=Schinken} \\
%   \curef{Schinken} 
% \end{cuexamplecode}
%
% \begin{cunote}
%   \mycs{curef} \emph{is} expendable.
% \end{cunote}
%
%
% \begin{function}{ref}
%   \begin{syntax}
%     ref = \marg{label}
%   \end{syntax}
%   Instead of using the first optional arguments of the commands in \cref{sec:commands}
%   you may use this option. It requires a valid value and throws an error if \meta{label}
%   is not defined.
% \end{function}
% \begin{cuexamplecode}
%   \culabel{Kaese}{3} @
%   \cunum<Kaese> [m=dm]{1}{m} \\
%   \cunum[ref=Kaese,m=dm]{1}{m} \\
%   \cusetup { recalculate-amount = true } @
%   \cunum<Kaese>[m=dm]{1}{m} \\
%   \cunum[ref=Kaese,m=dm]{1}{m} 
% \end{cuexamplecode}
%
%
%
% \begin{function}{curef-add-forbidden-unit, curef-remove-forbidden-unit,curef-clear-forbidden-units}
%   \begin{syntax}
%     curef-add-forbidden-unit    = \marg{unit list} 
%     curef-remove-forbidden-unit = \marg{unit list} 
%     curef-clear-forbidden-units = \meta{true/false} 
%   \end{syntax}
%^^A   How much of a specify ingredient is used generally depends on the number of folks the meal
%^^A   is for. Change the number of folks and the needed weight of an ingredient will most probably
%^^A   change, \emph{but} there are units which do not change automatically if you have $2$ instead
%^^A   of $4$ guests. Units which measure the temperature are for example one of them. So changing
%^^A   them using the label \& ref system would be accidental and should in the best case create an error. 
%^^A   Use the given options to define units which will throw an error if they are about to be changed
%^^A   by the label \& ref system. Of course, you can also remove units or clear the whole list.
%
%   There are units which do not depend on the number of folks you are cooking for, units measuring
%   the temperature are an example. Changing those units with the label \& ref
%   system would be accidental and in the best case throw an error. With the following options
%   you can add units to the \enquote{forbidden unit list}, remove them and clear the whole list
%   entirely.
%
%  By default the list contains \texttt{C}, \texttt{F}, \texttt{K} and \texttt{Re}.
% \end{function}
% \begingroup
% \DeactivateForbiddenUnitError
% \begin{cuexamplecode}
%   \culabel{check}{2} @
%   \cusetup{ recalculate-amount=true } @
%   \cunum<check>{1}{m} \\
%   \cunum<check>{1}{kg} \\
%   \cunum[ref=check]{1}{C} \\
%   \cusetup { curef-add-forbidden-unit = { m, kg } } @
%   \cunum<check>[m]{1}{m} \\
%   \cunum<check>[m]{1}{kg} \\
%   \cunum[ref=check]{1}{C}  \\
%   \cusetup { curef-remove-forbidden-unit = { C } } @
%   \cunum<check>[m]{1}{m} \\
%   \cunum<check>[m]{1}{kg} \\
%   \cunum[ref=check]{1}{C} \\
%   \cusetup { curef-clear-forbidden-units = true } @
%   \cunum<check>[m]{1}{m} \\
%   \cunum<check>[m]{1}{kg} \\
%   \cunum[ref=check]{1}{C} 
% \end{cuexamplecode}
% \endgroup
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \subsection{Weird options}
%
% \begin{function}{check-temperature}
%   \begin{syntax}
%     check-temperature = \meta{true/false}
%   \end{syntax}
%   Checks if the used temperature is below  absolute zero.
%  Currently \myunit{C}, \myunit{F}, \myunit{K} and \myunit{Re} are supported. 
%  While \lstinline|\cunum{0}{K}| is ok, \lstinline!\cunum{-1}{K}! raises an error, 
%  same for the others. Is set to \false\ by default. To add new units
%  see \opt{add-temperature-to-check}.
% \end{function}
%
% \begin{function}{add-temperature-to-check}
%   \begin{syntax}
%     add-temperature-to-check = 
%     \ \ \{ 
%     \ \ \ \ \meta{unit-key-1} = \meta{minimum-value-1} ,  
%     \ \ \ \ \meta{unit-key-2} = \meta{minimum-value-2} ,  
%     \ \ \ \ \dots
%     \ \ \}
%   \end{syntax}
%   This option adds  \meta{unit-key-1} and so on to the list of units to be checked
%   if \opt{check-temperature} is active. The argument can be a comma-separated
%   list of \meta{unit-key} = \meta{minimum-value}. This sets the allowed minimum
%   value of \meta{unit-key} to \meta{minimum-value}. 
%  
% \end{function}
%
% \begin{cuexample}
%   This package implements the allowed minimum values for the
%  temperatures \myunit{C}, \myunit{F}, \myunit{K} and \myunit{Re} to be checked if
%  \opt{check-temperature} is active using:
% \begin{lstlisting}
%   \cusetup
%     {
%       add-temperature-to-check =
%         {
%           K = 0,
%           C = -273.15 ,
%           F = -459.67 ,
%           Re = -218.52
%         } 
%     }
% \end{lstlisting}
%
% If you want to add a new value, for example degree R{\o}mer
% (which has be defined in another example) you can write:
% \begin{lstlisting}
%   \cusetup
%     {
%       add-temperature-to-check = { Ro = -135.90375 }
%     }
% \end{lstlisting}
% \end{cuexample}
%
%
%
%
% \begin{function}{convert-to-eV}
%   \begin{syntax}
%     convert-to-eV = \meta{true/false}
%   \end{syntax}
%   Converts (nearly) every unit in \cref{tab:def-units}
%   to electron volt or the respective derivative (if possible). Note that this 
%   option is:
%   a) experimental and probably will forever be and (b) just a joke, you are not 
%   supposed to use this units in a cookery book (and as you see this package
%   doesn't support the arrangement of such huge numbers). Also you may
%   want to check the values if you really want to use them, just to be sure
%   (I've checked them several times and hope they are finally correct, but mistakes
%   happen).
%
% \end{function}
%
% \begin{cuexamplecode}[\hfill]
%   \cusetup{ convert-to-eV=true } @
%   \cunum{1}{kg} \\
%   \cunum{1}{l} \\
%   \cunum{1}{J} \\
%   \cunum{1}{m} \\
%   \cunum{1}{C} \\
%   \cunum{1}{s}
% \end{cuexamplecode}
%
%
% \begin{function}{add-natural-unit}
%   \begin{syntax}
%     add-natural-unit = \meta{unit-key}
%   \end{syntax}
%   This option adds \meta{unit-key} to the list of units \opt{convert-to-eV}
%   uses to determine how a unit is transformed if set to \true.
% \end{function}
%
%
%
%
% \begin{function}{42}
%   \begin{syntax}
%     42 = \meta{true/false}
%   \end{syntax}
%   Take a good guess.
% \end{function}
% 
% \begin{cuexamplecode}[\hfill]
%   \cusetup{ 42=true } @
%   \cunum{1}{kg} \\
%   \cunum[kg=g]{1}{kg} \\
%   \cunum{1.5}{J} \\
%   \cunum{180}{C} \\
%   \cunum{15/4}{s} \\
%   \cunum{1--2}{min} \\
%   \cunum{?}{l}
% \end{cuexamplecode}
%
%
%
%
% 
%
%
%^^A \section{Notes}
%
%^^A There is a unit called \enquote{Batman}.
% 
%
%
%
%
%
% 
%
%
%
%
%
% 
% \section{Bugs \& Feedback}
% \label{sec:bug-feed}
%
% Bug reports  are always welcome. If you are sending a bug report 
% please include a minimal working example showing the bug and a short
% description. If you use mail please add  \pkg{cooking-units} 
% to the e-mail header. GMX has the habit of putting e-mails into the 
% spam account and adding  \pkg{cooking-units} to the header makes
% it easier to recognize those e-mails. It can also take longer of GitHub,
% but I hope I figured out how to get a mail if a new issue is created (by not me).
%
% Feedback and requests (commands, units, etc.) are also  welcome.  Please
% also add (if possible) an example of the desired output into the
% minimal example (and -- if by mail -- add \pkg{cooking-units} to the
% header).
%
% Furthermore, as you can see I am not able to speak too many
% languages (german and english to be precise; I managed to add french
% with the help of the internet, which is not optimal) so if you are
% able to speak a language not yet implemented and would like to help
% you can send me  the translations known to you. A list of all units
% (and their current translations) is given in \cref{sec:Translations}.
% 
%
%
%
%
%\clearpage
%
% \section{Bens Einheitensammelsurium (Bens unit Almanac)}
% \label{sec:unit-almanac}
% 
% Units are a fascinating mess. There are so many different ones which are  different and
% the few ones which are the same (in name at least) are \emph{also} different, depending on 
% geographical position, time period and probably pure spite. We can be glad that SI-units exist.
%
%
%^^A  Units are a fascinating mess. There are so many different ones that one can be glad
%^^A  that SI-units exist in this world. This section offers some units which didn't manage
%^^A  to appear in \cref{tab:def-units} and \cref{tab:some-more-units}.^^A\footnote{This somehow
%^^A ^^A reminds me of the story of \enquote{Tower of Babel} in the bible. This tower is -- according to the
%^^A ^^A story -- the reason (or the symptom) of why people speak different languages. 
%^^A ^^A I suppose what didn't make it into the story was that as even more severe punishment,
%^^A ^^A different units were created. Just my take at lest.}.
%
% So for those units which didn't make it into \cref{tab:def-units} and \cref{tab:some-more-units},
% this section exists. Please note that this list is intended to be a just-for-fun list and not a
% compilation of every unit in existence with its exact value ordered by geographical and chronological
% position. I am sadly neither a historian nor very good in regards to languages. It would sound like
% fun, but ultimately, I wouldn't have the time.
% Therefore I am only taking units into account which I either found in literature (stone, canna, etc.),
% are well known (foot) or have some other experience with them (ell) (exception: Batman). The reason I 
% am not including units which I found in the internet is that I would like to
% see those units in their \enquote{natural environment}.
%
%
% \begin{description}
%
% \unititem{unit}*in given language*[translation][abbreviation] Description, containing a 
%   quote or not. \emph{Please note that most of the units are country dependent!
%   So the translation may not have the same amount as the word it is translated to.}
%
% \unititem{Batman}
% So \dots\ You wanna be Batman? Be like Bruce Wayne? Having a secret identity?
% Then congratulations! You \emph{are} Batman! How much Batman depends on  the location,
% but Wikipedia is your friend in this matter.
%
%
% \unititem{Rotolo}*sic*[Rottel\txtupde] Around \SI{0.850}{\kg}
%   \begin{myquote}[Gattopardo][51]
%     Auf den Fußboden lagen vier ungereifte Käse zu je \emph{zwölf Rottel},
%     jeder ungefähr zehn Kilo schwer.
%   \end{myquote}
%
% \unititem{Canna}*sic*[Rute\txtupde, rod\txtupen] About \SI{2}{\m} bzw.\ about $6$ foot.
%   \begin{myquote}[Gattopardo][25]
%     \enquote{Unsinn, Stella, Unsinn; was soll mir zustoßen? Sie kennen mich alle:
%      Männer, die \emph{eine Rute} lange sind, gibt es wenige in Palermo.}
%   \end{myquote}
%
% \unititem{Stone}[][st]  \cunum[st=kg]{1}{st}. According to a fellow student 
%  this unit is still used in
%  Great Britain. I've also recently found it in a video game; in the german translation
%  of said video game to be precise. Why is the german translation using stone
%  and not kilogram (at least in braces)?
%   
%   \begin{myquote}[Sh:3][988]
%      As we had expected, the telegramm was soon followed by its sender, and the card of Mr.\ Cyril Overton, Trinity College, Cambridge, announced the arrival of an enormous young man, \emph{sixteen stone} \emph{[\cunum[st=kg]{16}{st}]} of solid bone and muscle, who spanned the doorway with his broad shoulders \emph{[\dots\!]}
%   \end{myquote} (Story \enquote{The missing Three Quarters})
%
% \unititem{Foot}[][ft] Equals exactly \cunum[ft=m,round-precision=10]{1}{ft}
%  or  \cunum[ft=in]{1}{ft}. 
% 
%   A bit of a strange unit (for me at least). Where I am from, people
%   tend to have different feet sizes. Also present in the german translation of the 
%   video game that uses \enquote{Stone}.
%
% \unititem{degree Rèamur}[][\ensuremath{{}^{\circ}}\kern-\scriptspace R\'{e}] Like degree Celsius, but instead of having the
%   water boiling at \SI{100}{\degree} (Celsius), water boils at \SI{80}{\degree}.
%   Water thankfully still freezes at \SI{0}{\degree}. Don't think that this unit
%   is used anymore. I think I learned about in physics.
%
% \unititem{Ell} Just read the Wikipedia article. 
%
%   Fun Fact: At the Stephansdom
%   in Vienna left of the main entrance are two metal bars. One is the 
%   \enquote{Tuchelle} (drapery ell, circa \SI{78}{\cm}), the other the
%   \enquote{Leinenelle} (linen ell, around \SI{89.6}{\cm}).
%
% \unititem{cup} I think the idea of having a \enquote{cup} and it not being
%   equal to \cunum{250}{ml} is a bit strange, for me at least. What other sizes can a 
%   cup have? I can imagine \cunum{500}{ml}, but are there other sizes?
% ^^A   Any person who writes \enquote{cup} and 
% ^^A  \emph{doesn't} mean
% ^^A a cup equal to \SI{250}{\ml} should be 
%^^A^^A -- in my humble opinion\footnote{Which, now that I admitted 
%^^A^^A my humbleness, is automatically
%^^A^^A more important than yours.} -- 
%^^A excommunicated by default (or incommunicated,
%^^A  if you are an atheist).
%
% \unititem{stick} A unit I've made fun of because it is quite regional and doesn't make
%  any sense for foreigners. Then I realized that I am using the unit \enquote{Packerl}
%  in my cookery book which is also quite locally\footnote{And maybe doesn't even exist 
%  outside my family} and -- even worse -- the weight changes depending 
%  the content (See \emph{Packerl}).
%  
% \unititem{Packerl}*de*[small bag] I'm a bit split on this unit as I don't actually 
%   know if it exists. The reason I have the unit \emph{Packerl} for my cookery
%   book is that in Austria you can buy baking powder, (dry) Germ, Natrium, etc.
%   in small bags (similar to \emph{stick}). The problem: Depending on the content,
%   the weight of \emph{Packerl} differs. Not only that, but it can also differ
%   between different producers (but not more than \SI{2}{\g} bzw.\ \cunum[g=oz]{2}{g}). 
%   Here is a table:
%
%   \begin{tabular}{l @{\space} l @{\space} l r l}
%    
%    1 Packerl & Backpulver & (baking powder)           & \cunum{16}{g} & (\cunum[g=oz]{16}{g}) \\
%    & Natrium &                                         & \cunum{14}{g} & (\cunum[g=oz]{14}{g}) \\
%    & Vanillin(-zucker) & (vanillin(-sugar)) & \cunum{8}{g} & (\cunum[g=oz]{8}{g}) \\
%    & Germ* &                                              & \cunum{7}{g} & (\cunum[g=oz]{7}{g}) \\
%   \end{tabular}
%
%   {\footnotesize *Tockengerm (dry Germ) to be precise}
%
%   For what kind of thing do I need \emph{Natrium} for?
% \end{description}
%
%
%
%
%
%
%
% \appendix
%
% \section{Translations} 
% \label{sec:Translations}
% This section contains the list of available translations. Each table
% shows the available translations regarding the unit symbol, the unit name
% (printed if \mycs{cutext} or \mycs{Cutext} is used)  and
% the plural form (if different from the singular form). A second table
% shows the translations used for phrases (if given).
%
% If a translation is not available a \enquote{\translationdoesnotexisttl} is
% shown.
%
% \small
%
%\clearpage
% \subsection{English}
% \begin{tabular}{ l l l l l }
%   \toprule
%   \CreateTableForLanguages{ English }
% \end{tabular}
%
%
%\clearpage
% \subsection{american}
%
% \begin{tabular}{ l l l l l }
%   \toprule
%   \CreateTableForLanguages{ american  }
% \end{tabular}
%
%\clearpage
% \subsection{German}
% \begin{tabular}{ l l l l l }
%   \toprule
%   \CreateTableForLanguages{ German }
% \end{tabular}
%
% \bigskip
%
%   \CreateTableForPhrases { German }
%
% \bigskip
% \begin{minipage}{\textwidth}
% Some further phrases, just to write them down (they are not implemented, 
% as they are barely used).
%
% \begin{tabular} { l l @{\space} l l l l }
% \toprule
%    \meta{number}  & name &  \multicolumn{2}{c}{Note} & (plural) & gender \\ \midrule
%  60 & Schock & (5 Dutzend, & $12*5$)  & & n \\
%  144 & Gros & (12 Dutzend, & $12*12$)  && n \\
%  1728 & Gro{\ss}gros  &(12 Gro{\ss}, & $12*144$) && n \\
% \bottomrule
% \end{tabular}
% \end{minipage}
%
% Note that Gro{\ss}gros has other (probably more common) synonyms.
%
%\clearpage
% \subsection{French}
% \begin{tabular}{ l l l l l }
%   \toprule
%   \CreateTableForLanguages{ French }
% \end{tabular}
%
% If the spoons should be extra full:  
% \begin{itemize}
%   \item cuill\`{e}re  \`{a}  soupe rase
%  \item cuill\`{e}re  \`{a}  caf\'{e} rase
% \end{itemize}
%
%\clearpage
%
%
%
%
%
%
%
%
% \section{US, Imperial and Other units}
% \label{sec:other-units}
%
% As source \cite{WM1985} has been used for imperial units, while \cite{Nist2006}
% and \cite{Nist2008} were used for U.S.\ units. I hope someone will find this
% bringing together useful.
%
%\begin{center}
%\begin{tabular}{ l @{ } l }
%\toprule
%  1 yard &= \SI{0.9144}{\m} (exact) \\
%  1 yard &= 3 foot \\
%  1 yard &= 36 Inch \\ \midrule
%  1 Inch &= \SI{0.0254}{\m} (also exact) \\
%  \bottomrule
%\end{tabular}
%\end{center}
%
%\begin{center}
%\begin{tabular}{r@{ }l r@{ }l} 
%\toprule
%  \multicolumn{4}{c}{  1 liter = \SI{1}{\cubic\deci\meter} } \\ \midrule
%  1 gallon &= \SI{4.54609}{liter} (exact) & 1 U.S.\ gallon &= 231\,Inch$^3$ $=$ 
%    $231\times \num{0,016387064}$ liter \\
%  1 gallon &= 4 Quart   & 1 U.S.\ gallon &= 4 Quart\US\\
%  1 gallon &= 8 Pint     & 1 U.S.\ gallon &= 8 Pint\US\\
%  1 gallon &= 32 Gill    & 1 U.S.\ gallon &= 32 Gill\US\\
%  1 gallon &= 160\,fl.\,oz & 1 U.S.\ gallon &= 128\,fl.\,oz\US \\\midrule
%  1 \,fl.\,oz&= \num{0.0284130625} liter & 1\,fl.\,oz\US & = \num{0.0295735295625} liter
%  \\ \bottomrule
%\end{tabular}\\ \footnotesize\raggedright
%\begin{cuenumnote}
%  \item I think the American fl.\,oz\US\ is more common. Maybe. Most bottles
%    have something like 10\,fl.\,oz, which they say is equal to \SI{30}{\ml}. This would
%    work really well with fl.\,oz\US.
%  \item Sometimes \enquote{fl.\,oz} is written without the dot. I am also not sure what
%    kind of spacing has to be between \enquote{fl.} and \enquote{oz} (currently
%    using \cs{thinspace}).
%  \item This maybe sounds stupid, but could we introduce something like
%    \enquote{flouz}, \enquote{floiz} and \enquote{floez}? \enquote{flouz} would be
%    \enquote{fl.\,oz\US}, \enquote{floiz} would be \enquote{Imperial fl.\,oz} and
%    \enquote{floez} would simply be equal to \SI{30}{\ml}?
%\end{cuenumnote}
%\end{center}
%
%
% For \enquote{stick} see \cite{StickSource}.
%\begin{center}
%\begin{tabular} { l @{ } l }
%  \toprule
%  1\,lb &= \SI{0.453 592 37}{\kg} (exact) \\
%  1\,lb &= 16\,oz  \\
%  1\,lb &= \sfrac{1}{14}\,st  \\
%  1\,lb &= \sfrac{175}{12}\,ounce~troy \\
%  1\,lb &= 4 stick \\
%  \bottomrule
%\end{tabular}
%\end{center}
%
%
%
%\begin{center}
%\begin{tabular} { r @{ } l @{ }l r @{ } l }
%  \toprule
% 1 cup &$\approx$  \num{0.25} litre &= \SI{250}{\ml} &1 cup\US &= 8\, fl.\,oz\US \\
% 1 tablespoon &$\approx$  \num{0.015} litre&= \SI{15}{\ml} & 1 tablespoon\US &= \sfrac{1}{2}\, fl.\,oz\US \\
% 1 teaspoon &$\approx$  \num{0.005} litre &= \SI{5}{\ml} & 1 teaspoon\US&= \sfrac{1}{6}\, fl.\,oz\US \\
% \bottomrule
%\end{tabular} \footnotesize \\  \raggedright
%\begin{cuenumnote}
%  \item I tested the approximation for tablespoon   with water
%    ($\SI{1}{\mg} \approx \SI{1}{\mg}$) and the approximation looks good enough.
%    It of course depends on how full you fill your spoon.
%\end{cuenumnote}
%\end{center}
%
%
% If you ever encounter in a german cookery book the word \enquote{Packerl}, 
% check out its entry in \cref{sec:unit-almanac}.
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \begin{comment}
%^^A \section{Notes and other stuff}
%^^A This section contains stuff which might or might not be interesting.
%^^A
%^^A \subsection{More or less FAQ}
%^^A
%^^A \num{624150912.6 +- 3.9 e+10}
%^^A \num{6.241509126 +- 0.000000039 e+18}
%^^A
%^^A \num{8.6173303 +- 00000.0000050 e-5}
%^^A
%^^A \subsection{Calculation}
%^^A This subsection deals with some regarding the conversion to certain units.
%^^A Mostly to (I like to call them) \enquote{electron volt units} (or natural units).
%^^A Let's begin.
%^^A
%^^A We start with the easiest one: conversion of joule into electron volt.
%^^A Easy because Wikipedia and nearly every physics book knows the answer. 
%^^A And according to Wikipedia
%^^A \begin{align}
%^^A  \SI{1}{\eV} &= \SI{1.6021766208(98)e-19}{\joule} \\
%^^A  \SI{1}{\joule} &= \SI{6.241509126 +- 0.000000039 e+18}{\eV}
%^^A \end{align}
%^^A Adding this is no problem: 
%^^A \begin{lstlisting}
%^^A   \cuaddtokeys {J} {eV} { 1.6021766208e-19 }
%^^A \end{lstlisting}
%^^A
%^^A
%^^A Great, next Temperature (kelvin) to electron volt. Also no problem at all
%^^A because joule and kelvin are related by the boltzmann constant $k_B$ with
%^^A \begin{equation}
%^^A   energy (\si{\joule}) = k_B \cdot temperature (\si{\kelvin})
%^^A \end{equation}
%^^A as $[k_B]= \sfrac{\si{\joule}}{\si{\kelvin}}$ and 
%^^A $k_B= \SI{1.38064852(79)e-23}{\joule\per\kelvin}$. Now using the power
%^^A of (more or less basic, but somehow annoying) mathematics we get:
%^^A \begin{align}
%^^A  [k_B] &= \SI{1.38064852(79)e-23}{\joule\per\kelvin} = \\
%^^A &= \num{1.38064852(79)e-23} \cdot \SI{6.241509126 +- 0.000000039 e+18 }{\eV\per\K} = \\
%^^A &= \SI{8.6173303 +- 0.0000050 e-5 }{\eV\per\K} 
%^^A \end{align}
%
%
%^^A \section{Notes and other stuff}
%^^A \subsection{Some details to electron volts}
%^^A This section explains how I calculated the values for conversion into electron volt
%^^A or the respective derivative. Let's begin with some constants (from Wikipedia), note that
%^^A \begin{equation*}
%^^A   \num{1.23456(78)e-9} = \num[separate-uncertainty = true]{1.23456(78)e-9}
%^^A \end{equation*}
%^^A just for info.
%^^A
%^^A \begin{align}
%^^A   \SI{1}{\eV} &= \SI{1.6021766208(98)e-19}{\J} \\
%^^A   \hbar &= \SI{1.054571800(13)e-34}{\J\s} \\
%^^A   k_B &= \SI{1.38064852(79)e-23}{\J\per\K} = \SI{8.6173303(50)e-5}{\eV\per\K}\\
%^^A   c &= \SI{299792458}{\m\per\s} 
%^^A \end{align}
%^^A
%^^A Note that all those and following values are rounded to the second relevant figure of the 
%^^A uncertainty of the value.
%^^A
%^^A Well then, next are temperatures.
%^^A
%^^A Temperatures are fairly easy. Just convert the temperature of your choice to kelvin
%^^A and multiplicate it with $k_B$:
%^^A \begin{align}
%^^A   \SI{1}{\K} * k_B &= \SI{8.6173303(50)e-5}{\eV}
%^^A \end{align}
%^^A
%^^A Next is more complicated. To compute the resulting unceartanity I using
%^^A \enquote{Gauß'sches Fehlerfortpflanzungsgesetz} (I don't know if this has 
%^^A a translation). Anyway.  We know that
%^^A \begin{align*}
%^^A    \frac{\SI{1}{\eV}}{c^2} &= \frac{\SI{1.6021766208e-19}{\J}}{(\SI{299792458}{\m\per\s})^2}
%^^A    = \frac{\SI{1.6021766208e-19}{\kg\m\squared\per\s\squared}}{\SI{8,98755178736818E16}{\m\squared\per\s\squared}} = \\
%^^A &\frac{\SI{1.6021766208e-3}{\kg}}{\num{8,98755178736818}} =
%^^A \SI{1782661906,94091624922088}{\kg}
%^^A \end{align*}
%^^A
%^^A Great, now we have to calucalte the unceartinity:
%^^A \begin{align}
%^^A   f(\si{\eV},c) &= \frac{\si{\eV}}{c^2} \\
%^^A   df(\si\eV,c) &= \sqrt{ (\frac{\partial f}{\partial \si\eV})^2 * (\Delta \si\eV)^2 +  (\frac{\partial f}{\partial c})^2  * (\Delta c)^2 } = \\
%^^A &= \sqrt{  (\frac{1}{c^2})^2 * (\Delta \si\eV)^2 + (-2\frac{eV}{c^{-3}})^2  * (\Delta c)^2 }  
%^^A \end{align}
%^^A
%^^A Now we know that $\Delta c = 0$:
%^^A \begin{align}
%^^A   df(\si\eV,c) &= \sqrt{  (\frac{1}{c^2})^2 * (\Delta \si\eV)^2 }  = 
%^^A \sqrt{ \frac{1}{(\SI{299792458}{\m\per\s} )^2} * (\SI{0.0000000098e-19}{\J})^2 } \\
%^^A &= 
%^^A \end{align}
% \end{comment}
%
%
%
%
%
%
%\end{documentation}
%
%
%
%
%
%
%
%
%
%
% \begin{implementation}
%
% \section{Implementation}
%
% \subsection{Beginning}
%
%    \begin{macrocode}
%<@@=cookingunits>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*package> 
%    \end{macrocode}
%
%
%
% Na dann, auf gehts!
%
%    \begin{macrocode}
\@ifpackageloaded {xparse} 
  { } 
  { \RequirePackage {xparse} }
\@ifpackageloaded {expl3} 
  { } 
  { \RequirePackage {expl3} }
%    \end{macrocode}
%
%: Package
%    \begin{macrocode}
\ProvidesExplPackage
  {cooking-units}
  {2020/01/13}
  {1.46} 
  {Ein Paket fuer Kocheinheiten}
%    \end{macrocode}
%
% Checking if \pkg{expl3} is up-to-date, otherwise abort the loading of the package.
%    \begin{macrocode}
\@ifpackagelater { expl3 } { 2020/08/07 }
  { }
  {
    \PackageError { cooking-units } { Support~package~expl3~too~old }
      {
        You~need~to~update~your~installation~of~the~bundles~'l3kernel'~and~
        'l3packages'.\MessageBreak
        Loading~cooking-units~will~abort!
      }
    \tex_endinput:D
  }
%    \end{macrocode}
% Loading some needed packages.
%    \begin{macrocode}
\@ifpackageloaded { translations } { } { \RequirePackage { translations } }
\@ifpackageloaded { xfrac } { } { \RequirePackage { xfrac } }
\@ifpackageloaded { l3keys2e } { } { \RequirePackage { l3keys2e } }
%    \end{macrocode}
%
% Checking if \pkg{translations} is up-to-date, otherwise abort the loading of the package.
%    \begin{macrocode}
\@ifpackagelater { translations } { 2020/04/28 }
  { }
  {
    \PackageError { cooking-units } { Support~package~translations~too~old }
      {
        You~need~to~update~your~installation~of~the~package~'translations'.\MessageBreak
        Loading~cooking-units~will~abort!
      }
    \tex_endinput:D
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Option-deprecated } 
  { 
   The \ option \ '#1' \ is \ deprecated \ and \ should \ be \
   replaced \ by \ '#2'.
  }{ 
    Please \ replace \ the \ option.
    \msg_see_documentation_text:n { cooking-units } 
  }
\msg_new:nnnn { cooking-units } { key-unknown }
  { The~key~'#1'~is~unknown~and~is~being~ignored. }
  {
    The~module~'#2'~does~not~have~a~key~called~'#1'.\\
    Check~that~you~have~spelled~the~key~name~correctly.
  }
%    \end{macrocode}
%    \begin{macrocode}
\bool_new:N \g_@@_opt_numeral_bool
\keys_define:nn { cooking-units }
  {
    use-numerals .code:n = 
      { 
        \msg_warning:nnnn { cooking-units } { Option-deprecated } { use-numerals } { use-fmtcount-numerals } 
        \keys_set:nn { cooking-units } { use-fmtcount-numerals = #1 }
      } ,
    use-numerals .default:n = { false },
    use-fmtcount-numerals .bool_gset:N = \g_@@_opt_numeral_bool ,
    use-fmtcount-numerals .default:n = { false },
    unknown .code:n = { \msg_error:nnxx { cooking-units } { key-unknown }
      { \l_keys_path_str } { cooking-units }
     }
  }
%    \end{macrocode}
% Now process the package options \dots
%    \begin{macrocode}
\ProcessKeysOptions { cooking-units }
\bool_if:NT \g_@@_opt_numeral_bool
  {
    \@ifpackageloaded { fmtcount } { } { \RequirePackage { fmtcount } }
  }
%    \end{macrocode}
% \dots\ and redefine the package option such that it cannot be used elsewhere.
%    \begin{macrocode}
\keys_define:nn { cooking-units }
  {
    use-numerals .code:n = 
      { 
        \msg_warning:nnnn { cooking-units } { Option-deprecated } { use-numerals } { use-fmtcount-numerals }
        \msg_error:nnn { cooking-units } { load-time-option } { use-fmtcount-numerals } 
      } ,
    use-fmtcount-numerals .code:n = { \msg_error:nnn { cooking-units } { load-time-option } { use-fmtcount-numerals } } ,
  }
%    \end{macrocode}
% 
%
%
% \subsection {Defining Variables}
%
% \begin{macro} { cs variants }
% Some variations of commands we will need later.
%    \begin{macrocode}
\cs_generate_variant:Nn \msg_redirect_name:nnn { nnV }
\cs_generate_variant:Nn \tl_replace_all:Nnn { NVn }
\cs_generate_variant:Nn \tl_replace_once:Nnn { NVn }
\cs_generate_variant:Nn \tl_if_in:nnTF { nV }
\cs_generate_variant:Nn \tl_if_in:NnTF { NVTF  }
\cs_generate_variant:Nn \tl_if_in:NnT { NVT }
\cs_generate_variant:Nn \fp_compare:nNnT { vNnT }
\cs_generate_variant:Nn \prop_get:NnN { cVc, Nnc }
\cs_generate_variant:Nn \prop_get:NnNF {  Nnc }
\cs_generate_variant:Nn \tl_set_rescan:Nnn { NnV }
\cs_generate_variant:Nn \msg_error:nnnn { nnnV }
\cs_generate_variant:Nn \msg_error:nnn { nnV }
\cs_generate_variant:Nn \msg_warning:nnn { nnV }
\cs_generate_variant:Nn \prop_put:Nnn { cnx }
\cs_generate_variant:Nn \seq_remove_all:Nn { NV }
\cs_generate_variant:Nn \prop_gput:Nnn { Nnv, Nxv }
\cs_generate_variant:Nn \prop_get:NnN { cnc }
\cs_generate_variant:Nn \prg_new_conditional:Npnn { c }
\cs_generate_variant:Nn \text_uppercase:n { x }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_frac:nn}
% This command is used to print fractions and can be changed
% accordingly.
%    \begin{macrocode}
\cs_new_eq:NN \@@_frac:nn \sfrac
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_@@_unit_argument_spec_tl , \l_@@_unit_argument_spec_tl }
% Allows for potential parsing of amount and or unit.
%    \begin{macrocode}
\tl_new:N \l_@@_unit_argument_spec_tl
\tl_new:N \l_@@_expand_amount_tl
\tl_set:Nn \l_@@_unit_argument_spec_tl { n }
\tl_set:Nn \l_@@_expand_amount_tl { n }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_set_amount:Nn , \@@_set_unit:Nn  , \@@_to_unit:n }
% Definitions to set the amount and the unit. Made so that it can be changed globally.
% By default, the amount is just taken as is while the unit is changed into a string.
%    \begin{macrocode}
\cs_new_eq:NN \@@_set_amount:Nn \tl_set:Nn
\cs_new_eq:NN \@@_set_unit:Nn \str_set:Nn
\cs_new_eq:NN \@@_to_unit:n \tl_to_str:n
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_print_numeral:n , \@@_print_Numeral:n}
% Commands to print numerals. Either use default or set yourself.
%    \begin{macrocode}
\cs_new:Npn \@@_print_numeral:n #1 
  { \msg_error:nnn {cooking-units} { define-numeral-function } }
\cs_new:Npn \@@_print_Numeral:n #1 
  { \msg_error:nnn {cooking-units} { define-Numeral-function } }
\bool_if:NT \g_@@_opt_numeral_bool
  {
    \cs_set_eq:NN \@@_print_numeral:n \numberstringnum
    \cs_set_eq:NN \@@_print_Numeral:n \Numberstringnum
  }
\cs_generate_variant:Nn \@@_print_numeral:n { V }
\cs_generate_variant:Nn \@@_print_Numeral:n { V }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \l_@@_change_unit_prop }
% Conversions of units are stored within this property list.
% If someone requests that \myunit{kg} should be changed into \myunit{g},
% \myunit{kg} is stored as a key with the value \myunit{g}. If someone
% then uses the unit \myunit{kg} the value \myunit{g} is restored and  the unit
% is changed accordingly.
%    \begin{macrocode}
\prop_new:N \l_@@_change_unit_prop
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro} { \g_@@_master_changer_prop }
%   Similar to |\l_@@_change_unit_prop|, but doesn't store the requested
%  unit change, but the values needed for conversion. Either a numerical
%  value is stored or a formula (using |#1| to insert the original value).
%
%  Put and get values via \cs{\@@_prop_gput_master:nnn}
%  and \cs{@@_prop_get_master:nnNTF}.
%    \begin{macrocode}
\prop_new:N \g_@@_master_changer_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \g_@@_convert_bonkers_remember_prop , \g_@@_convert_to_eV_remember_prop }
% If the unit is changed in a \enquote{not normal} way, store
% some things in one of the two lists. They are just used as shortcuts
% to remember which unit is changed into which. They are one level above
% |\g_@@_master_changer_prop|.
%    \begin{macrocode}
\prop_new:N \g_@@_convert_to_eV_remember_prop
\prop_new:N \g_@@_convert_bonkers_remember_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%  {
%    , \l_@@_number_tmpa_tl
%    , \l_@@_number_tmpb_tl
%    , \l_@@_mixed_fraction_tl
%    , \l_@@_original_amount_tl
%    , \l_@@_original_unit_tl
%    , \l_@@_option_unit_tl
%    , \l_@@_language_tl
%    , \l_@@_cunum_range_sign_tl
%    , \l_@@_cutext_range_sign_tl
%    , \l_@@_value_unit_space_tl
%    , \l_@@_input_digits_tl 
%    , \l_@@_input_decimal_mark_tl
%    , \l_@@_input_value_signs_tl
%    , \l_@@_input_allowed_special_signs_tl 
%    , \g_@@_input_str_hash_one_tl 
%    , \l_@@_input_range_sign_tl
%    , \l_@@_cutext_space_tl
%    , \l_@@_cutext_numeral_space_tl
%    , \l_@@_cuphrase_space_tl
%    , \l_@@_translation_tmpa_tl
%    , \l_@@_cutext_last_value_tl
%    , \l_@@_phantom_tl
%    , \l_@@_phrase_text_tl
%    , \l_@@_unit_letter_not_allowed_tl
%    , \l_@@_input_fraction_sign_tl
%    , \l_@@_input_mixed_fraction_sign_tl
%    , \l_@@_list_of_units_tl
%    , \l_@@_list_of_values_tl
%    , \l_@@_allwed_integer_math_operators_tl
%    , \l_@@_curr_group_tl
%    , \l_@@_curr_unit_tl
%    , \l_@@_cmd_hook_tl
%    , \l_@@_cunum_hook_tl
%    , \l_@@_cutext_hook_tl
%    , \l_@@_Cutext_hook_tl
%    , \l_@@_cuam_hook_tl
%    , \l_@@_new_key_base_tl
%    , \l_@@_decided_unit_tl
%    , \l_@@_stored_units_tl
%    , \l_@@_stored_formula_tl
%  }
% Quite a lot of tl's.
%    \begin{macrocode}
\tl_new:N \l_@@_number_tmpa_tl
\tl_new:N \l_@@_number_tmpb_tl
\tl_new:N \l_@@_mixed_fraction_tl
\tl_new:N \l_@@_original_amount_tl
\tl_new:N \l_@@_original_unit_tl
\tl_new:N \l_@@_option_unit_tl
\tl_new:N \l_@@_language_tl
\tl_new:N \l_@@_cunum_range_sign_tl
\tl_new:N \l_@@_cutext_range_sign_tl
\tl_new:N \l_@@_value_unit_space_tl
\tl_new:N \l_@@_input_digits_tl 
\tl_new:N \l_@@_input_decimal_mark_tl
\tl_new:N \l_@@_input_value_signs_tl
\tl_new:N \l_@@_input_allowed_special_signs_tl 
\tl_new:N \g_@@_input_str_hash_one_tl 
\tl_new:N \l_@@_input_range_sign_tl
\tl_new:N \l_@@_cutext_space_tl
\tl_new:N \l_@@_cutext_numeral_space_tl
\tl_new:N \l_@@_cuphrase_space_tl
\tl_new:N \l_@@_translation_tmpa_tl
\tl_new:N \l_@@_cutext_last_value_tl
\tl_new:N \l_@@_phantom_tl
\tl_new:N \l_@@_phrase_text_tl
\tl_new:N \l_@@_unit_letter_not_allowed_tl
\tl_new:N \l_@@_input_fraction_sign_tl
\tl_new:N \l_@@_input_mixed_fraction_sign_tl
\tl_new:N \l_@@_list_of_units_tl
\tl_new:N \l_@@_list_of_values_tl
\tl_new:N \l_@@_allwed_integer_math_operators_tl
\tl_new:N \l_@@_curr_group_tl
\tl_new:N \l_@@_curr_unit_tl
\tl_new:N \l_@@_new_key_base_tl
\tl_new:N \l_@@_decided_unit_tl
\tl_new:N \l_@@_stored_units_tl
\tl_new:N \l_@@_stored_formula_tl
%    \end{macrocode}
%    \begin{macrocode}
\tl_new:N \l_@@_cmd_hook_tl
\tl_new:N \l_@@_cunum_hook_tl
\tl_new:N \l_@@_cutext_hook_tl
\tl_new:N \l_@@_Cutext_hook_tl
\tl_new:N \l_@@_cuam_hook_tl
%    \end{macrocode}
% \end{macro}
%
%
% Setting some token lists to their default value.
% \cs{c_@@_input_str_hash_one_tl} is used for defining single keys.
% (As you will see, I didn't have a better idea)
%    \begin{macrocode}
\tl_set:Nn \l_@@_input_digits_tl { 0123456789 }
\tl_set:Nn \l_@@_input_range_sign_tl { -- }
\tl_set:Nn \l_@@_input_fraction_sign_tl { / }
\tl_set:Nn \l_@@_input_mixed_fraction_sign_tl { _ }
\tl_set:Nn \l_@@_input_decimal_mark_tl { . , }
\tl_set:Nn \l_@@_input_value_signs_tl { + - }
\tl_set:Nn \l_@@_input_allowed_special_signs_tl { ? }
\tl_gset_rescan:Nnn \g_@@_input_str_hash_one_tl
  { \char_set_catcode_letter:N \# } {#1}
\tl_set:Nn \l_@@_allwed_integer_math_operators_tl { +-()*/ }
%    \end{macrocode}
%    \begin{macrocode}
\tl_set:Nn \l_@@_cunum_range_sign_tl { -- }
\tl_set:Nn \l_@@_cutext_range_sign_tl { }
\tl_set:Nn \l_@@_value_unit_space_tl { \thinspace }
\tl_set:Nn \l_@@_cutext_space_tl { ~ }
\tl_set:Nn \l_@@_cutext_numeral_space_tl { \space }
\tl_set:Nn \l_@@_cuphrase_space_tl { \space }
\tl_set:Nn \l_@@_unit_letter_not_allowed_tl { , / }
%    \end{macrocode}
%
% \begin{macro}{\c_@@_minus_tl}
% Flat out stolen from \pkg{siunitx}.
%    \begin{macrocode}
\AtBeginDocument {
  \cs_if_free:cT { T@TS1 }
    {
      \DeclareFontEncoding { TS1 } { } { }
      \DeclareFontSubstitution { TS1 } { cmr } { m } { n }
    }
}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareTextSymbolDefault \c_@@_minus_tl { TS1 }
\DeclareTextSymbol \c_@@_minus_tl { TS1 } { 61 }
\AtBeginDocument {
  \@ifpackageloaded { fontspec }
    {
      \@ifpackageloaded { eulervm }
        { }
        {
          \int_const:Nn \c_@@_minus_int { 8722 }
          \tl_set:Nn \c_@@_minus_tl
            { \tex_char:D \c_@@_minus_int }
        }
    }
    { }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \l_@@_mixed_frac_dim }
%   The dimension between the fraction and the mixed fraction part is
%   stored within this macro. There is no real reason why I have
%   chosen this distance to be 0.1em, I just thought that it looks
%   best.  But if someone has some ideas of how large this distance
%   should be I am happy to listen.
%    \begin{macrocode}
\dim_new:N \l_@@_mixed_frac_dim
\dim_set:Nn \l_@@_mixed_frac_dim { 0.1 em }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \l_@@_round_precision_int }
%   Stores the round-precision inside. Can also take negative values.
%    \begin{macrocode}
\int_new:N \l_@@_round_precision_int
\int_set:Nn \l_@@_round_precision_int { 2 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \l_@@_print_numerals_below_int }
%   Used if option \opt{use-numerals} is active. Uses numerals for
%   integers smaller than this number. I learned this number
%   at school.
%    \begin{macrocode}
\int_new:N \l_@@_print_numerals_below_int
\int_set:Nn \l_@@_print_numerals_below_int { 13 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \l_@@_local_number_of_persons_int }
% Each recipe defined by \cs{culabel} defines a counter to
% store the number of persons the recipe is for. For calculation
% the value is retrieved and stored inside this temporal integer variable.
%    \begin{macrocode}
\int_new:N \l_@@_local_number_of_persons_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \l_@@_wanted_number_of_persons_int }
%   Not only the number of persons are recipe is for is needed
%   for calculation, but also the number of persons you want
%   the recipe to be. This information is stored here.
%    \begin{macrocode}
\int_new:N \l_@@_wanted_number_of_persons_int
\int_set:Nn \l_@@_wanted_number_of_persons_int { 4 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \l_@@_phrase_number_tl , \l_@@_phrase_gender_tl }
%   Stores the current \enquote{phrase number} (and gender). 
%   For \enquote{Dutzend} this would
%   be \enquote{12}, etc. The second stores the gender (m, f or n)
%    \begin{macrocode}
\int_new:N \l_@@_phrase_number_tl
\int_new:N \l_@@_phrase_gender_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \l_@@_list_of_defined_keys_clist , \g_@@_list_of_defined_units_clist }
%  Sequence of defined units and keys. Units are defined
%  globally as they create new commands, keys do not do that
%  (I think). Could be my mistake.
%    \begin{macrocode}
\seq_new:N \l_@@_list_of_defined_keys_seq
\seq_new:N \g_@@_list_of_defined_units_seq
%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro} { \g_@@_allowed_special_keys_seq }
%   \changes {2016/06/12} {New: \cs{g_@@_allowed_unit_phrases_tl}}
% Used for the keys 'one(m)', 'one(f)', etc. Those are special keys
% which cannot be used as units, but are processed by the commands in
% the language section as such.
%    \begin{macrocode}
\seq_new:N \g_@@_allowed_special_keys_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \l_@@_phrase_numbers_seq }
% Inside this list the numbers for which a phrase is defined
% is stored in. As this is language specific, the list is stored
% inside a language-sensitive command and retrieved when needed.
%    \begin{macrocode}
\seq_new:N \l_@@_phrase_numbers_seq 
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{
%    , \g_@@_stored_derived_unit_symbol_seq
%    , \g_@@_stored_derived_formula_seq
%    , \g_@@_stored_derived_unit_print_seq
% }
% Variables used in \mycs{declarecookingderivatives}.
%    \begin{macrocode}
\seq_new:N \g_@@_stored_derived_unit_symbol_seq
\seq_new:N \g_@@_stored_derived_formula_seq
\seq_new:N \g_@@_stored_derived_unit_print_seq
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\l_@@_nr_of_units_int, \l_@@_depth_int}
%   Also some variables used in \mycs{declarecookingderivatives}.
%    \begin{macrocode}
\int_new:N \l_@@_nr_of_units_int
\int_new:N \l_@@_depth_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\g_@@_natural_units_seq }
%   Remembers which unit foes to which natural unit.
%    \begin{macrocode}
\seq_new:N \g_@@_natural_units_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \l_@@_temperatures_to_check_seq }
%   \changes {1.02h} {New.}
% Stores units which should be tested if \opt{check-temperature} equals true.
%    \begin{macrocode}
\seq_new:N \l_@@_temperatures_to_check_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \l_@@_curef_do_not_change_seq }
% This contains the units which shouldn't be changed.
%    \begin{macrocode}
\seq_new:N \l_@@_curef_do_not_change_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \l_@@_phrase_prop }
% Stores the number and he respective phrase. For example
% if \enquote{12} has the phrase \enquote{Dutzend}, this
% key-value pair is stored inside.
%    \begin{macrocode}
\prop_new:N \l_@@_phrase_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \l_@@_derived_units_prop }
%  Stores \emph{via} key-value all defined derived units as keys
%  and the formula to calculate the derived unit as value..
%    \begin{macrocode}
\prop_new:N \l_@@_derived_units_prop
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}
%   {
%    , \l_@@_pckopt_eval_fractions_bool
%    , \l_@@_pckopt_convert_fractions_bool
%    , \l_@@_pckopt_draft_bool
%    , \l_@@_pckopt_round_to_int_bool
%    , \l_@@_pckopt_check_temperature_bool
%    , \l_@@_pckopt_convert_to_eV_bool
%    , \l_@@_pckopt_cuam_old_bool
%    , \l_@@_pckopt_recalculate_amount_bool
%    , \l_@@_pckopt_cutext_to_cunum_bool
%    , \l_@@_pckopt_cutext_old_bool
%    , \l_@@_pckopt_cutext_keep_unit_bool
%    , \l_@@_pckopt_round_commercial_bool
%    , \l_@@_pckopt_use_phrases_bool
%    , \l_@@_pckopt_round_precision_negative_bool
%    , \l_@@_pckopt_fourty_two_bool
%    , \l_@@_pckopt_bonkers_bool
%    , \l_@@_minus_bool
%    , \l_@@_round_number_bool
%    , \l_@@_single_key_bool
%    , \l_@@_cutext_uppercase_word_bool
%    , \l_@@_reference_given_bool
%    , \l_@@_lokal_recalc_for_people_bool
%    , \l_@@_lokal_phrase_bool
%    , \l_@@_lokal_change_unit_bool
%    , \l_@@_pckopt_print_numeral_bool
%    , \l_@@_lokal_numeral_bool
%    , \l_@@_phrase_negative_bool
%    , \l_@@_cutext_last_amount_equ_one_bool
%    , \l_@@_symbol_was_set_by_key_bool
%    , \l_@@_contains_valid_key_bool
%    , \l_@@_check_decimal_bool
%    , \l_@@_unit_error_bool
%   }
% Some booleans we need later.
%    \begin{macrocode}
\bool_new:N \l_@@_pckopt_eval_fractions_bool
\bool_new:N \l_@@_pckopt_convert_fractions_bool
\bool_new:N \l_@@_pckopt_draft_bool
\bool_new:N \l_@@_pckopt_round_to_int_bool
\bool_new:N \l_@@_pckopt_check_temperature_bool
\bool_new:N \l_@@_pckopt_convert_to_eV_bool
\bool_new:N \l_@@_pckopt_cuam_old_bool
\bool_new:N \l_@@_pckopt_recalculate_amount_bool
\bool_new:N \l_@@_pckopt_cutext_to_cunum_bool
\bool_new:N \l_@@_pckopt_cutext_old_bool
\bool_new:N \l_@@_pckopt_cutext_keep_unit_bool
\bool_new:N \l_@@_pckopt_round_commercial_bool
\bool_new:N \l_@@_pckopt_use_phrases_bool
\bool_new:N \l_@@_pckopt_round_precision_negative_bool
\bool_new:N \l_@@_pckopt_fourty_two_bool
\bool_new:N \l_@@_pckopt_bonkers_bool
\bool_new:N \l_@@_minus_bool
\bool_new:N \l_@@_round_number_bool
\bool_new:N \l_@@_single_key_bool
\bool_new:N \l_@@_cutext_uppercase_word_bool
\bool_new:N \l_@@_reference_given_bool
\bool_new:N \l_@@_lokal_recalc_for_people_bool
\bool_new:N \l_@@_lokal_phrase_bool
\bool_new:N \l_@@_lokal_change_unit_bool
\bool_new:N \l_@@_pckopt_print_numeral_bool
\bool_new:N \l_@@_lokal_numeral_bool
\bool_new:N \l_@@_phrase_negative_bool
\bool_new:N \l_@@_cutext_last_amount_equ_one_bool
\bool_new:N \l_@@_symbol_was_set_by_key_bool
\bool_new:N \l_@@_contains_valid_key_bool
\bool_new:N \l_@@_check_decimal_bool
\bool_new:N \l_@@_unit_error_bool
%    \end{macrocode}
% \end{macro}
%
%
%
% Setting some of them to \true\ or another boolean respectively.
%    \begin{macrocode}
\bool_set_false:N \l_@@_pckopt_cutext_keep_unit_bool
\bool_set_eq:NN \l_@@_pckopt_print_numeral_bool \g_@@_opt_numeral_bool
%    \end{macrocode}
%
%
% \begin{macro}{ \q_@@_range }
% Replacing the sign \enquote{-{}-} with \lstinline|\q_@@_range| for testing.
%    \begin{macrocode}
\quark_new:N \q_@@_range
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ \q_@@_no_translation }
%  Checking value if a translation is avaiable.
%    \begin{macrocode}
\quark_new:N \q_@@_no_translation
%\cs_new:Npn \q_@@_no_translation { asdasd\ewhkerhjkwejhk } 
%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro}{
%    , \l_@@_scrap_tl
%    , \l_@@_tmpa_tl
%    , \l_@@_tmpb_tl
%    , \l_@@_tmp_unit_tl
%    ,  \l_@@_tmpa_fp
%    , \l_@@_tmpa_clist
%    , \l_@@_tmpa_prop
%    , \l_@@_tmpb_prop
%    , \l_@@_tmpa_seq
%    , \l_@@_tmpb_seq
%    , \l_@@_tmpa_int
%    , \l_@@_tmpb_int
%    , \l_@@_tmpa_bool
%    , \l_@@_tmpb_bool
%  }
% Some temporal stores which are used throughout the code.
%    \begin{macrocode}
\tl_new:N \l_@@_scrap_tl
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmp_unit_tl
\fp_new:N \l_@@_tmpa_fp
\clist_new:N \l_@@_tmpa_clist
\prop_new:N \l_@@_tmpa_prop
\prop_new:N \l_@@_tmpb_prop
\seq_new:N \l_@@_tmpa_seq
\seq_new:N \l_@@_tmpb_seq
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\bool_new:N \l_@@_tmpa_bool
\bool_new:N \l_@@_tmpb_bool
%    \end{macrocode}
%\end{macro}
%
%
%
% \subsection {Keys}
%
%
% Let's define some keys.
%    \begin{macrocode}
\keys_define:nn { cooking-units }
  {
%    \end{macrocode}
%
%
% \begin{macro}{ add-unit-to-group }
%    \begin{macrocode}
    add-unit-to-group .code:n = 
      { 
        \keyval_parse:NNn 
          \@@_add_to_unit_group_error:n 
          \@@_add_to_unit_group:nn 
          {#1} 
      } ,
    add-unit-to-group .default:n = {} ,
%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{ set-option-for }
%  Setting options.
%    \begin{macrocode}
    set-option-for .code:n = 
      { 
        \keyval_parse:NNn 
          \@@_set_options_for_error:n 
          \@@_set_options_for:nn
          {#1}
      },
%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{ add-option-for }
%  Setting options.
%    \begin{macrocode}
    add-option-for .code:n = 
      { 
        \keyval_parse:NNn 
          \@@_add_options_for_error:n
          \@@_add_options_for:nn
          {#1}
      },
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ erase-all-options }
%  Erasing all preset options. Again not the best approach \dots\ maybe I need a lower
% level \enquote{clear} option.
%    \begin{macrocode}
    erase-all-options .code:n = 
      { 
        \clist_set_from_seq:NN \l_@@_tmpa_clist \g_@@_list_of_defined_units_seq
        \@@_clear_options_for:V \l_@@_tmpa_clist
      },
    erase-all-options .value_forbidden:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{ erase-all-options-for }
%  Erasing options. As this simply clears the unit options the argument |#1|
% is simply a clist, as such no keyval parsing is needed.
%    \begin{macrocode}
    erase-all-options-for .code:n = 
      { 
        \@@_clear_options_for:n {#1}
      },
    erase-all-options-for  .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{ cutext-to-cunum }
% Don't want any \mycs{cutext} (or \mycs{Cutext}) in your
% document? Use this option!
%    \begin{macrocode}
    cutext-to-cunum .bool_set:N = \l_@@_pckopt_cutext_to_cunum_bool ,
    cutext-to-cunum .default:n = { false } ,
    cutext-to-cunum .groups:n = { change-command } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ cutext-change-unit }
% Do not wanna change units in \mycs{cutext}? Use this option.
%    \begin{macrocode}
    cutext-change-unit .bool_set_inverse:N = \l_@@_pckopt_cutext_keep_unit_bool ,
    cutext-change-unit .default:n = { true } ,
    cutext-change-unit .groups:n = { change-unit } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ cuam-version  , cutext-version}
% Some keys with horrible option names. Reverts 
% the respective command back to its older state (pre v1.10).
%    \begin{macrocode}
    cuam-version .choices:nn = 
      { new , old }
      {
        \int_case:nn { \l_keys_choice_int }
          {
            { 1 } { \bool_set_false:N \l_@@_pckopt_cuam_old_bool }
            { 2 } { \bool_set_true:N \l_@@_pckopt_cuam_old_bool }
          }
      } ,
    cuam-version .default:n = { new } ,
    cuam-version .groups:n = { parse } ,
    cutext-version .choices:nn = 
      { new , old }
      {
        \int_case:nn { \l_keys_choice_int }
          {
            { 1 } { \bool_set_false:N \l_@@_pckopt_cutext_old_bool } 
            { 2 } { \bool_set_true:N \l_@@_pckopt_cutext_old_bool }
          }
      } ,
    cutext-version .default:n = { new } ,
    cutext-version .groups:n = { parse } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ expand-both , expand-amount, expand-unit }
%    \begin{macrocode}
    expand-both .choices:nn =
      { n , o , f , x }
      {
        \tl_set_eq:NN \l_@@_unit_argument_spec_tl \l_keys_choice_tl
        \tl_set_eq:NN \l_@@_expand_amount_tl \l_keys_choice_tl
      } ,
    expand-both .default:n = { n } ,
    expand-both .groups:n = { parse } ,
%    \end{macrocode}
%    \begin{macrocode}
    expand-amount .choices:nn =
      { n , o , f , x }
      {
        \tl_set_eq:NN \l_@@_expand_amount_tl \l_keys_choice_tl
      } ,
    expand-amount .default:n = { n } ,
    expand-amount .groups:n = { parse } ,
%    \end{macrocode}
%    \begin{macrocode}
    expand-unit .choices:nn =
      { n , o , f , x }
      {
        \tl_set_eq:NN \l_@@_unit_argument_spec_tl \l_keys_choice_tl
      } ,
    expand-unit .default:n = { n } ,
    expand-unit .groups:n = { parse } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%\begin{macro}{ set-special-sign }
% Setting allowd special signs. Note that |<| is not allowed.
%    \begin{macrocode}
    set-special-sign .code:n = 
      { 
        \tl_map_inline:nn {#1} 
          {
            \str_if_eq:nnT {##1} { < }
              { 
                \msg_error:nn { cooking-units } { <-not-allowed-as-special-sign }
                \tl_map_break:n { \use_none:nn }
              }
          }
        \use:n { \tl_set:Nn  \l_@@_input_allowed_special_signs_tl {#1} }
      } ,
    set-special-sign .groups:n = { parse } ,
%    \end{macrocode}
%\end{macro}
%\begin{macro}{ add-special-sign }
% Adding a (some) special sign(s) which is (are)  allowed in the input.
%    \begin{macrocode}
    add-special-sign .code:n = 
      { 
        \tl_map_inline:nn {#1} 
          {
            \str_if_eq:nnTF {##1} { < }
              { 
                \msg_error:nn { cooking-units } { <-not-allowed-as-special-sign }
              }{
                \tl_put_right:Nn  \l_@@_input_allowed_special_signs_tl {##1}
              }
          }
      } ,
    add-special-sign .default:n = { } ,
    add-special-sign .groups:n = { parse } ,
%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro}{ set-unknown-message }
%   Sets the message for a special-sign to error, warning or none.
%    \begin{macrocode}
    set-unknown-message .choices:nn =
      { error , warning , none }
      {
        \msg_redirect_name:nnV { cooking-units } { amount-not-known } 
          \l_keys_choice_tl
      } ,
    set-unknown-message .default:n = { warning } ,
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ set-cutext-translation-message }
%   Sets the message for a special-sign to error, warning or none.
%    \begin{macrocode}
    set-cutext-translation-message .choices:nn =
      { error , warning , none }
      {
        \msg_redirect_name:nnV { cooking-units } { cutext-no-translation-available } 
          \l_keys_choice_tl
      } ,
    set-cutext-translation-message .default:n = { warning } ,
%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro}{ print-numerals }
% A not very good name, but I couldn't think of a better name.
%    \begin{macrocode}
    print-numerals .bool_set:N = \l_@@_pckopt_print_numeral_bool ,
    print-numerals .default:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ use-numerals-below }
%   Use numerals if the integer is below the integer set by this option.
%    \begin{macrocode}
    use-numerals-below .int_set:N = \l_@@_print_numerals_below_int ,
    use-numerals-below .default:n = { 13 } ,
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{ parse-number }
% Parse the input? If no the input is printed as is (after some safety parsing).
%    \begin{macrocode}
    parse-number .bool_set_inverse:N = \l_@@_pckopt_draft_bool , 
    parse-number .default:n= { true } ,
    parse-number .groups:n = { parse } ,
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{ range-sign }
%  Setting the printed range sign and make a difference between cunum
%  and c(C)utext.
%    \begin{macrocode}
    range-sign .meta:n = 
      {  
        cunum-range-sign = {#1} ,
        cutext-range-sign = {#1}
      } ,
    range-sign .default:n = { -- } ,
    cunum-range-sign .tl_set:N = \l_@@_cunum_range_sign_tl ,
    cunum-range-sign .default:n = { -- } ,
    cutext-range-sign .tl_set:N = \l_@@_cutext_range_sign_tl ,
    cutext-range-sign .default:n = { -- } ,
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ use-phrases }
% Do not wanna use phrases in \mycs{cuam}? Use this option!
%    \begin{macrocode}
    use-phrases .bool_set:N = \l_@@_pckopt_use_phrases_bool ,
    use-phrases .default:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%\begin{macro}{ round-precision }
%  Setting the round-precision. Setting those two at once to 
%  not calculate it every time.
%    \begin{macrocode}
    round-precision .code:n = 
      {
        \int_set:Nn \l_@@_round_precision_int {#1}
        \int_compare:nNnTF {#1} < { 0 }
          { \bool_set_true:N  }
          { \bool_set_false:N  }
        \l_@@_pckopt_round_precision_negative_bool
      } ,
    round-precision .default:n = { 2 } ,
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{ round-to-int }
%  Rounding the results to an integer.
%    \begin{macrocode}
    round-to-int .bool_set:N = \l_@@_pckopt_round_to_int_bool ,
    round-to-int .choices:nn = 
      { true , false }
      {
        \msg_error:nnnn { cooking-units } { Option-deprecated }  { round-to-int } { round-precision = 0 }
        \int_compare:nNnTF { \l_keys_choice_int } = { 1 }
          {
            \int_set:Nn \l_@@_round_precision_int { 0 }
          }{
          
          }
        \use:c { bool_set_ \l_keys_choice_tl :N } \l_@@_pckopt_round_to_int_bool
      } ,
    round-to-int .default:n = { false } ,
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ round-half }
%  Choosing between \enquote{normal} rounding to even 
%  and commercial rounding and sets the boolean accordingly.
%    \begin{macrocode}
% TODO: uodate doch und so
    round-half .choices:nn =
      { default , commercial , up }
      {
        \int_case:nn { \l_keys_choice_int }
          {
            { 1 } { \bool_set_false:N \l_@@_pckopt_round_commercial_bool }
            { 2 } { \bool_set_true:N \l_@@_pckopt_round_commercial_bool }
            { 3 } { \bool_set_true:N \l_@@_pckopt_round_commercial_bool }
          }
      },
    round-half .default:n = { default },
%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{ eval-fraction }
% If set to true the fractions are evaluated.
%    \begin{macrocode}
    eval-fraction .bool_set:N = \l_@@_pckopt_eval_fractions_bool ,
    eval-fraction .default:n = { false } ,
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{ convert-fraction }
% If set to true the fractions are evaluated \emph{if} the unit is transformed!
%    \begin{macrocode}
    convert-fraction .bool_set:N = \l_@@_pckopt_convert_fractions_bool ,
    convert-fraction .default:n = { true } ,
%    \end{macrocode}
%\end{macro}
%
%
%\begin{macro}{ fraction-command }
%  Setting the fraction command
%    \begin{macrocode}
    fraction-command .code:n = { \cs_set_eq:NN \@@_frac:nn #1 } ,
    fraction-command .default:n = { \sfrac } ,
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{ fraction-inline }
% Setting the code inline.
%    \begin{macrocode}
    fraction-inline .code:n = { \cs_set:Npn \@@_frac:nn ##1##2 {#1} } ,
    fraction-inline .default:n = { \sfrac {#1} {#2} } ,
%    \end{macrocode}
%\end{macro}
%
%
%
%
%
%
%\begin{macro}{ mixed-fraction-space }
% Setting the space between the mixed fraction part and the fraction.
%    \begin{macrocode}
    mixed-fraction-space .dim_set:N = \l_@@_mixed_frac_dim ,
    mixed-fraction-space .default:n = { 0.1 em } ,
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ cutext-space }
% The space used in \mycs{cutext} between the \emph{number} 
% and unit.
%    \begin{macrocode}
    cutext-space .tl_set:N = \l_@@_cutext_space_tl ,
    cutext-space .default:n = { ~ } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ cutext-space }
% The space used in \mycs{cutext} between the \emph{numeral}
% and unit.
%    \begin{macrocode}
    cutext-numeral-space .tl_set:N = \l_@@_cutext_numeral_space_tl ,
    cutext-numeral-space .default:n = { space } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ phrase-space }
% Same as before, but for phrases
%    \begin{macrocode}
    phrase-space .tl_set:N = \l_@@_cuphrase_space_tl ,
    phrase-space .default:n = { \space } ,
%    \end{macrocode}
% \end{macro}
%
%\begin{macro}{ amount-unit-space }
%  Setting the space between the value and the printed unit.
%    \begin{macrocode}
    amount-unit-space .tl_set:N = \l_@@_value_unit_space_tl ,
    amount-unit-space .default:n = { \thinspace } ,
%    \end{macrocode}
%\end{macro}
%
%
%
%
%
%
% \begin{macro}{ recalculate-amount }
% Setting the number of persons your recipes should be for
% is not enough; it is also needed to tell the package to
% recalculate the amounts.
%    \begin{macrocode}
    recalculate-amount .bool_set:N = \l_@@_pckopt_recalculate_amount_bool ,
    recalculate-amount .default:n = { false } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ set-number-of-persons }
% Setting the number of persons the recipe should be for.
%    \begin{macrocode}
    set-number-of-persons .int_set:N = \l_@@_wanted_number_of_persons_int ,
    set-number-of-persons .default:n = { 4 } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ label }
% Defines a label. Is \mycs{culabel} in key form.
%    \begin{macrocode}
    label .code:n = \@@_label_and_persons:n {#1} ,
    label .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ get-label }
% \mycs{curef} as a key.
%    \begin{macrocode}
    get-label .code:n = \@@_curef:n {#1} ,
    get-label .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ ref }
% The |<>| option for keys.
%    \begin{macrocode}
    ref .code:n = \@@_reference_label_and_persons:n {#1} ,
    ref .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%\begin{macro}{ check-temperature }
%  Weird option. Checking the temperature, if the temperature is below the absolute zero temperature
%  it raises an error.
%    \begin{macrocode}
    check-temperature .bool_set:N = \l_@@_pckopt_check_temperature_bool ,
    check-temperature .default:n = { true } ,
%    \end{macrocode}
%
%\begin{macro}{ add-temperature-to-check }
%  Adds a temperature to check for \texttt{check-temperature}.
% It uses the \cs{keyval\_parse:NNn} command as this
% macro is used to parse keys (which is what I need).
%    \begin{macrocode}
    add-temperature-to-check .code:n = 
      { 
        \keyval_parse:NNn
          \@@_temperature_to_check_print_error:n
          \@@_temperatures_to_check_define:nn
          {#1}
      } ,
    temperature-to-check .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro} 
%
%\begin{macro}{ convert-to-eV }
%  Another weird option, converts pretty much any unit defined by this
%  package to electron volt or the respective derivative.
% As this is a unit transformation, it needs to be inside the
% group.
%    \begin{macrocode}
    convert-to-eV .bool_set:N = \l_@@_pckopt_convert_to_eV_bool ,
    convert-to-eV .default:n = { true } ,
%    convert-to-eV .groups:n = { change-unit } ,
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ add-natural-unit }
%    \begin{macrocode}
    add-natural-unit .code:n = 
      {
        \seq_set_from_clist:Nn \l_@@_tmpa_seq {#1}
        \seq_map_inline:Nn \l_@@_tmpa_seq
          {
            \@@_error_if_unit_not_defined:nNF {##1} \l_@@_curr_unit_tl
              {
                \seq_if_in:NVF \g_@@_natural_units_seq \l_@@_curr_unit_tl
                  { \seq_gput_right:NV \g_@@_natural_units_seq \l_@@_curr_unit_tl }
              }
          }
      } ,
    add-natural-unit .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ 42 }
%    \begin{macrocode}
    42 .choice: ,
    42 / true .code:n = { \bool_set_true:N \l_@@_pckopt_fourty_two_bool } ,
    42 / false .code:n = { \msg_fatal:nnn { cooking-units } { 42-is-...-wrong? } } ,
    42 .default:n = { true } ,
    42 .groups:n = { parse } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \begin{macro}{ input-range-sign }
% Don't wanna use \verb|--| as a range sperator in \mycs{cunum}? 
% Use this option.
%    \begin{macrocode}
    input-range-sign .tl_set:N = \l_@@_input_range_sign_tl ,
    input-range-sign .default:n = { -- } ,
    input-range-sign .groups:n = { parse } ,
%    \end{macrocode}
%\end{macro}
%
% \begin{macro}{ numeral-function , Numeral-function }
%    \begin{macrocode}
    numeral-function .code:n = { \cs_set_eq:NN \@@_print_numeral:n #1 } ,
    Numeral-function .code:n = { \cs_set_eq:NN \@@_print_Numeral:n #1 } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{
%   commands-add-hook ,
%   cunum-add-hook ,
%   cutext-add-hook , Cutext-add-hook , 
%   cuam-add-hook ,
% }
%    \begin{macrocode}
    commands-add-hook .meta:n = 
      { 
        cunum-add-hook =  {#1} ,
        cutext-add-hook =  {#1} ,
        Cutext-add-hook =  {#1} ,
        cuam-add-hook =  {#1} ,
      } , 
    cunum-add-hook .code:n = { \tl_put_right:Nn \l_@@_cunum_hook_tl {#1} } , 
    cutext-add-hook .code:n = { \tl_put_right:Nn \l_@@_cutext_hook_tl {#1} } , 
    Cutext-add-hook .code:n = { \tl_put_right:Nn \l_@@_Cutext_hook_tl {#1} } , 
    cuam-add-hook .code:n = { \tl_put_right:Nn \l_@@_cuam_hook_tl {#1} } , 
    cunum-add-hook .groups:n = { parse } ,
    cutext-add-hook .groups:n = { parse } ,
    Cutext-add-hook .groups:n = { parse } ,
    cuam-add-hook .groups:n = { parse } ,
    commands-add-hook .groups:n = { parse } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \begin{macro}{
%    curef-add-forbidden-unit, 
%    curef-remove-forbidden-unit, 
%    curef-clear-forbidden-units
% }
%    \begin{macrocode}
  curef-add-forbidden-unit .code:n = { \@@_add_forbidden_unit:n {#1} } ,
  curef-add-forbidden-unit .default:n = { } ,  
  curef-remove-forbidden-unit .code:n = { \@@_remove_forbidden_unit:n {#1} } ,
  curef-remove-forbidden-unit .default:n = { } ,  
%  
  curef-clear-forbidden-units .choice: ,
  curef-clear-forbidden-units/true .code:n = { \@@_clear_forbidden_unit: } ,
  curef-clear-forbidden-units/false .code:n = { } ,
  curef-clear-forbidden-units .value_required:n = true,
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{symbol}
%  To be implemented. Key used during definition of new units.
%  Defines the printed symbol of the unit (both do the same).
%    \begin{macrocode}
  definition / symbol .code:n = 
    { 
      \bool_set_true:N \l_@@_contains_valid_key_bool
      \bool_set_true:N \l_@@_symbol_was_set_by_key_bool
      \tl_set:cn { l_@@_default_unit_ \l_@@_original_unit_tl _tl } {#1} 
    },
  definition / symbol .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{gender}
%  To be implemented. Key used during definition of new units.
%  Defines the gender of the unit.
%    \begin{macrocode}
  definition / gender .code:n = 
    {
      \bool_set_true:N \l_@@_contains_valid_key_bool
      \@@_if_gender_error:nTF {#1}
        { \@@_culang_def_base:nVn { gender } \l_@@_original_unit_tl { m } }
        { \@@_culang_def_base:nVn { gender } \l_@@_original_unit_tl {#1} }
    },
  definition / gender .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{set-option}
%  To be implemented. Key used during definition of new units.
%  Adds options to a specific key during definition of unit.
%    \begin{macrocode}
  definition / set-option .code:n = 
    { 
      \bool_set_true:N \l_@@_contains_valid_key_bool
      \@@_set_options_for:Vn \l_@@_original_unit_tl {#1} 
    },
  definition / set-option .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{add-to-group}
%  To be implemented. Key used during definition of new units.
%  Adds unit to given group.
%    \begin{macrocode}
  definition / add-to-group .code:n = 
    {  
      \bool_set_true:N \l_@@_contains_valid_key_bool
      \@@_add_to_unit_group:nV {#1} \l_@@_original_unit_tl
    },
  definition / add-to-group .value_required:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{natural-unit}
%  To be implemented. Key used during definition of new units.
%  Defines this unit as a natural unit.
%    \begin{macrocode}
  definition / natural-unit .code:n = 
    {  
      \bool_set_true:N \l_@@_contains_valid_key_bool
      \seq_if_in:NVF \g_@@_natural_units_seq \l_@@_original_unit_tl
        { \seq_gput_right:NV \g_@@_natural_units_seq \l_@@_original_unit_tl }
    },
  definition / natural-unit .default:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{unit-names}
%  To be implemented. Key used during definition of new units.
%  Defines written out unit name for \cCutext for given language.
%  Also suspended. Would need to give language and it would be too
%  complicated (I think)
%    \begin{macrocode}
%  definition / unit-names .code:n = {  },
%    \end{macrocode}
% \end{macro}
%
%
% You get here during the definition of a new unit if you use the optional 
% argument. As symbols cannot contain |=| the argument |#1| is going
% to be empty. I also assume that none of the above keys are used as an
% unit-symbol. If |#1| is non-empty (aka.\ the key has a value) throw an error.
%    \begin{macrocode}
  definition / unknown .code:n = 
    {  
      \tl_if_empty:nF {#1}
        {
          \msg_error:nnxx 
            { cooking-units } 
            { definition-key-mistyped? } 
            \l_keys_key_str
            {#1}
        }
    },
%    \end{macrocode}
%
%
%
% \begin{macro}{nothing-special}
%  Stage 0 of being bonkers. Do nothing special in this one. Reset everything.
%    \begin{macrocode}
   nothing-special .code:n = 
    {  
      \prop_gclear:N \g_@@_master_changer_prop
      \prop_gclear:N \g_@@_convert_bonkers_remember_prop
      \bool_set_false:N \l_@@_pckopt_bonkers_bool
      \tl_set_eq:NN \l_@@_bonkers_state_tl \c_@@_bonkers_state_normal_tl
    },
  nothing-special .value_forbidden:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{going-bonkers}
%  Stage 1 of being bonkers. 
%    \begin{macrocode}
   going-bonkers .code:n = 
    {  
      \prop_gclear:N \g_@@_convert_bonkers_remember_prop
      \bool_set_true:N \l_@@_pckopt_bonkers_bool
      \tl_set_eq:NN \l_@@_bonkers_state_tl \c_@@_bonkers_state_going_tl
    },
  going-bonkers .value_forbidden:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{fully-bonkers}
%  Stage 2 of being bonkers. 
%    \begin{macrocode}
   fully-bonkers .code:n = 
    {  
      \prop_gclear:N \g_@@_master_changer_prop
      \prop_gclear:N \g_@@_convert_bonkers_remember_prop
      \bool_set_true:N \l_@@_pckopt_bonkers_bool
      \tl_set_eq:NN \l_@@_bonkers_state_tl \c_@@_bonkers_state_fully_tl
    },
  fully-bonkers .value_forbidden:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{xD-lol}
%  Stage 3 of being bonkers. 
%    \begin{macrocode}
   xD-lol .code:n = 
    {  
      \prop_gclear:N \g_@@_master_changer_prop
      \prop_gclear:N \g_@@_convert_bonkers_remember_prop
      \bool_set_true:N \l_@@_pckopt_bonkers_bool
      \tl_set_eq:NN \l_@@_bonkers_state_tl \c_@@_bonkers_state_xD_tl
    },
  xD-lol .value_forbidden:n = { true } ,
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% Ending the definition of keys.
%    \begin{macrocode}
  }

%\keys_set:nn { cooking-units } {#2}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection {Messages}
%
% Defining messages. 
%
% \begin{macro} {Messages}
% I do not allow fractions and ranges  in the same input. Maybe I will
% change this.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { fraction-not-allowed-with-range }
  { 
    You \ cannot \ use \ '/' \ ( and  \ '_' )\ in \ combination \
    with \ '\l_@@_input_range_sign_tl' \ in \  '#1'.
  }{ 
    You \ cannot \ use \ fractions \ with \ a \ range.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% Do not allow a \_ without a /.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { missing-slash }
  { 
    You \ cannot \ use \ '_'  \ without \
    '/' \ in \  '#1'.
  }{ 
    You \ cannot \ have \ a \ mixed \ fraction \ ('_') \ without \
    a \ normal \ fraction \ ('/').
    \msg_see_documentation_text:n { cooking-units } 
  }
\msg_new:nnnn { cooking-units } { fraction-wrong-order }
  { 
    You \ cannot \ use \ '/'  \ before \ '_' \ in \ '#1'.
  }{ 
    You \ can \ only \ use \ '_' \ before \ '/'.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
% Error message if unit is not known to this package.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { unknown-unit }
  { 
    The \ unit \ '#1' \ is \ not \ defined. \ Use \ 
    \newcookingunit (or \ one \ of \ the \ others) \ to \ 
    define \ new \ units.
  }{ 
    Define \ units \ before \ using \ or \ check \ if \ the \
    unit-key \ is \ written \ correctly.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
% Error if unit is already defined.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { unit-already-defined } 
  { The\ unit \ '#1' \ is \ already \ defined. } 
  { 
    The \ unit-key \ is \ already \ defined. \ Please \ use \ a \ different \
    key \ for \ a \ new \ unit.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { character-not-allowed } 
  { 
    Unit-keys \ are \ not \ allowed \ to \ either \ contain \ ',' \ or \ '/' \ 
    in \ '#1'. 
  }{ 
    The \ unit-key \ is \ not \ allowed \ to \ contain \ ',' \ or \ '/'. \
    Due \ to \ internal \ reasons.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% 
% Missing argument in \lstinline|\cudefinesymbols| (et all).
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { missing-argument } 
  { There \ is \ a \ missing \ argument. } 
  { 
    You \ probably \ have \ forgotten \ a \ curly-brace \ pair.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% 
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { symbol-and-special-keys-error } 
  { You \ cannot \ use \ special-key \ '#1' \ with \ symbol \ '#2' \ definitions. } 
  { 
    You \ cannot \ redefine \ a \ symbol \ of \ a \ special-key.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
%
%
% If fractions are evaluated division by zero is not allowed.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Division-by-zero } 
  { Division\ by \ zero \ is \ not \ allowed \ in \ '#1'. } 
  { See \ a \ math \ book \ of \ your \ choice \ or \ for \ example \ Wikipedia. }
%    \end{macrocode}
% Showing the not allowed token in the input. Hope this helps.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Token-not-allowed } 
  { The \ token \ '#1' \ is \ not \ allowed \ in \ '#2'. } 
  { 
    The \ command \ accepts \ only \ a \ fixed \ number \ of \ tokens. 
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% A second decimal sign is not allowed (No na net).
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Second-decimal-sign-not-allowed } 
  { A \ second \ decimal \ sign \ is \ not \ allowed \ in \ '#1'. } 
  { 
    Perhaps \ you \ didn't \ type \ it \ correctly.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Second-fraction-sign-not-allowed } 
  { A \ second  \ fraction \ sign \ is \ not \ allowed \ in \ '#1'. } 
  { 
    Perhaps \ you \ didn't \ type \ it \ correctly.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Second-mixed-fraction-sign-not-allowed } 
  { A \ second  \ mixed \ fraction \ sign \ is \ not \ allowed \ in \ '#1'. } 
  { 
    Perhaps \ you \ didn't \ type \ it \ correctly.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% Error message for an undefined key.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Key-not-defined } 
  { 
    The \ key \ '#1' \ is \ not \ defined. \ Use \ \cudefinekeys or \
    \cudefinesinglekey to \ define \ keys. 
  } 
  { 
    This \ key \ is \ not \ defined, \ perhaps \ you  \ misspelled \ it.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
%
% If the temperature is too low print this error message.
% Now prints all units for which a zero-point is defined.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Temperature-too-low } 
  { 
    The \ temperature \ '#1' \ is \ too \ low.\ It \ cannot \ be \
    below \ the \ absolute \ zero - point \ of \ '#2'. \ Note \ that \ 
    the \ temperatures \ 
    '\@@_seq_use_msg:N \l_@@_temperatures_to_check_seq' \
    are \ rounded \ to \ integers \ by \ default. 
    \\\\
    You \ can \ disable \ the \ option \ 'check-temperature' \ to \
    disable \ this \ error.
  } 
  { See \ for \ example \ Wikipedia. }
%    \end{macrocode}
% If for an unit-key the value is wrong the following error message is shown.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { key-choice-unknown } 
  { 
    The \ key \ '#1' \ only \ accepts \ only \ 
    '#3' \ as \ a \ set \ of \ choices \ and \ '#2' \ is \ non \ of \ these.
  }{ 
    The \ key \ accepts \ only \ a \ fixed \ set \ of \ choices. \
    You \ can \ add \ new \ choices \ via \ \token_to_str:N \cuaddkeys, ~ 
    \token_to_str:N \cuaddsinglekeys ~ and \ \token_to_str:N \cuaddtokeys.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% If for an unit-key the value is wrong the following error message is shown.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { key-no-knows-value } 
  { 
    It \ appears \ that \ the \ key \ '#1' \ does \ not \ accept \ the \ value
    '#2'. \ Are \ you \ sure \ it \ is \ in \ the \ same \ key-chain?
  }{ 
    The \ key \ accepts \ only \ a \ fixed \ set \ of \ choices. \
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
% Adding a message for unit-groups.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { group-choice-not-allowed } 
  { 
    The \ group \ key \ '#1' \ accepts \ only \ 
    '#3' \ as \ a \ set \ of \ choices \ and \ '#2' \ is \ non \ of \ these.
  }{ 
    The \ key \ accepts\ only \ a \ fixed \ set \ of \ choices. \
    You \ can \ add \ new \ choices \ via \ option \ 'add-unit-to-group'.
    \msg_see_documentation_text:n {cooking-units} 
  }
%    \end{macrocode}
%
%\changes {v0.98a} {2016/06/11} {New option: 'value-not-known'.}
%\changes {v0.99} {2016/06/12} {Renamed option: 'amount-not-known'.}
% An info message for unknown messages.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { amount-not-known } 
  { 
    The \ amount \  '#1' \ is \ not \ known \ at \ line \ 
    \msg_line_number: .
  }{
    You \ used\  a\  special\  sign\  indicating\  that\  the\  true\  amount\  of\  the\ 
    specific\  ingredient\  is\  (was) \ not\  known\  to\  you. This\  message\ 
    reminds\  you\  about\  that\  fact.
    \msg_see_documentation_text:n {cooking-units}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { group-key-unknown }
  { 
    The \ group \ key \ '#1' \ is \ not \ defined. \ Perhaps
    \ you \ misspelled \ it?
  }{ 
    The \ group \ key \ is \ not \ defined.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% If a load time option is not used as a package option,  this
% message is shown.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { load-time-option } 
  { 
    The \ option \ '#1' \ is \ only \ available \ as \ a \ load-time-option. \
    Please \ set \ it \ as \ a \ package \ option.
  }{ 
    You \ cannot \ set \ this \ option \ using \ \cusetup ~
    but \ only \ as \ a \ package \ option.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% Messages for obsolete commands.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { obsolete-command } 
  { 
    Command \ #1 is \ obsolete. \ Please \ use \ #2 instead.
  }{ 
    Don't \ use \ this \ old \ command \ ... 
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { No-Value-given } 
  { 
    Please \ input \ a \ value \ for \ the \ key-value \ list \ in \ '#1'
  }{ 
    Each \ element \ of \ the \ list \ needs \ a \ value.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Adding-single-to-multi-key-or-vice-verca } 
  { 
    You \ are \ trying \ to \ add \ a \ single-key \ to \ a \ multi-key \
    or \ vice-versa.
  }{ 
    This \ is \ not \ allowed!
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Value-not-allowed } 
  { 
    The \ key-list \ in \ '#1' \ does \ not \ take \ a \ value.
  }{ 
    This \ key-list \ does \ not \ take \ a \ value. \ The \
    given \ value \ will \ be \ ignored.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% Error message if a zero-point temperature is already defined.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Minimum-already-defined } 
  { 
    A \ minimum \ for \ '#1' \ has \ already \ been \  defined.
  }{ 
    You \ cannot \ redefine \ it.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
% 
% Using the key version of \mycs{culabel} one needs to give the number of
% people the recipe is for after a \enquote{*}.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Number-of-persons-missing } 
  { 
    Please \ add \ the \ number \ of \ persons \ this \ recipe \ is \ for \ in \ '#1'. \
    Note \ that\ the \ number \ must \ be \ given \ after \ a \ '*'.
  }{ 
    Write \ 'Schweinsbraten*4' \ to \ create \ the \ label \ 'Schweinsbraten' \
    which \ is \ initially \ for \ 4 \ persons.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% The number of persons, must be an integer \dots\ 
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Number-of-persons-is-not-an-integer } 
  { 
    The \ number \ of \ persons \ the \ recipe \ is \ for \ must \ be \ an \
    integer. \ '#1' \ is \ not \ allowed.
  }{ 
    The \ number \ '#1' \ is \ not \ allowed.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% Each label defined by \mycs{culabel} needs to be new.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { label-already-defined } 
  { 
    The \ label \ '#1' \ has \ already \ been \ defined.
  }{ 
    Each \ label \ must \ be \ unique.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% Message if a label is not defined.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { label-not-defined } 
  { 
    The \ label \ '#1' \ is \ not \ defined. \ Please \ note \ that \ a \ label
    \ has \ to \ defined \ before \ it \ is \ referenced.
  }{ 
    Define \ the \ label \ before \ using \ it.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% If an unit is already defined and redefined by an \mycs{declarecookingunit}.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { redefine-unit } 
  { 
    The \ unit \ '#1' \ is \ redefined \ by \ \declarecookingunit ~ at \ 
    \msg_line_context: . 
  }{ 
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% A \enquote{phrase} must be an integer.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { phrase-unit-not-an-integer } 
  { 
    A \ phrase \ must \ be \ an \ integer,  \ '#1' \ is \ not \ allowed.
  }{ 
    You \ can \ only \ use \ integers.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
% A translation for \cs{cutext} or \cs{Cutext} is not available. For this case
% -- instead of printing the key-name (see  \pkg{translations}) -- we fall back
% to \cs{cunum}.
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { cutext-no-translation-available }
  { 
    For \ the \ unit \ '#1' \ there \ exists \ no \ translation \ to \ be \ used \
    for \ \cutext ~ and \ \token_to_str:N \Cutext. \
    You \ can \ define \ new \ translations \ for \ a \ given \ language \ using \
    \cudefinename.
  }{ 
    \cunum ~ is \ used \ instead.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { Translation-not-available }
  { 
    The \ translation \ for \ #1 \ does \ not \ exist. 
    Please \ define \ it \ using \ \token_to_str:N\cudefinename.
  }{ 
    And \ you \ may \ send \ me \ the \ translation \ as \ it \ is \
    not \ available \ yet.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { formula-in-non-singlekeys }
  { 
    The \ conversion \ value \ '#1' \ seems \ to \ be \ a \ formula. \
    This \ is \ not \ allowed \ for \ NON-\ singlekeys!
  }{ 
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { <-not-allowed-as-special-sign } 
  { 
    Currently \ (and \ probably \ forever) \ the \ sign \ '<' \
    is \ not \ allowed \ to \ be \ used \ as \ a \ special \ sign.
  }{ 
    I \ apologize \ for \ the \ inconvenience.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { unknown-gender } 
  { 
    '#1' \ is \ not \ allowed \ to \ be \ used \ as \ a \ gender-specification.
    Only \ 'm', \ 'f' \ or \ 'n' \ are \ allowed.
  }{ 
    Please \ remove \ spaces \ if \ there \ are \ some.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { no-natural-unit-known } 
  { 
    It \ seems\ that \ I \ cannot \ convert \ '#1' \ in \ a \ natural \
    unit \ as \ there \ is \ no \ conversion-factor \ defined.
  }{ 
    Not \ converting \ the \unit.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { curef-not-inside-list } 
  { 
   '#1' \ cannot \ be \ removed \ from \ the \ 'forbidden \ unit' \ list \ because
   \ it \ is \ not \ inside \ the \ list.
  }{ 
    Currently \ the \ list\ contains \ '#2'.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { curef-forbidden-unit } 
  { 
   The \ amount \  of \ '#1' \ cannot \ be \ changed \ using \ cooking-units` 
   \ label \ and \ ref \ feature.
  }{ 
    You \ can \ remove \ the \ unit \ using \ 'curef-remove-forbidden-unit'.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { define-numeral-function } 
  { 
   You \ are \ using \ numerals \ (lowercase) \ without \ the \ load-time \ option \
   'use-fmtcount-numerals' \ as \ such \ you \ need \ to \ define \ 
   which \ function \ is \ to \ be \ used \ for \ numerals. \ You \ can
   \ do \ that \ via \ 'numeral-function' \ and \ 'Numeral-function'
  }{ 
    Please \ specify\ which \ function \ should \ be \ used \ to \ print \
    numerals (lowercase \ and \ uppercase).
    \msg_see_documentation_text:n { cooking-units } 
  }
\msg_new:nnnn { cooking-units } { define-Numeral-function } 
  { 
   You \ are \ using \ numerals \ (capitalized) \ without \ the \ load-time \ option \
   'use-fmtcount-numerals' \ as \ such \ you \ need \ to \ define \ 
   which \ function \ is \ to \ be \ used \ for \ numerals. \ You \ can
   \ do \ that \ via \ 'numeral-function' \ and \ 'Numeral-function'
  }{ 
    Please \ specify\ which \ function \ should \ be \ used \ to \ print \
    numerals (lowercase \ and \ uppercase).
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { 42-is-...-wrong? } 
  { 
   You \ requested \ to \ set  \ 42 \ to \ 'false'. \ This \ doesn't \ make
   \ any \ sense! \ It \ cannot \ be \ 'false', \ it \ is \ the \ answer \ to \ the
   \ question \ of \ life, \ universe \ and \ everything. \ For \ the \ sake \ of \
   the \ world \ I \ cannot \ allow \ you \ to \ set \ it \ to \ 'false', \ the \ universe
   \ might \ explode \ otherwise. \\
   The \ run \ will \ be \ aborted.
  }{ 
    Phew ... \ this \ might \ have \ ended \ disastrous.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode} 
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { empty-amount } 
  { 
    The \ amount \ given \ is \ empty \ ( spaces \ are \ removed ).
  }{ 
    The \ amount \ given \ is \ empty.
    \msg_see_documentation_text:n { cooking-units } 
  }
%
\msg_new:nnnn { cooking-units } { unknown-unit-option } 
  { 
    The \ unit-option \ '#1' \ is \ not \ defined.
  }{ 
    Please \ define \ the \ key \ '#1' \ via \ \newcukeysadd \ and \ friends.
    \msg_see_documentation_text:n { cooking-units } 
  }
\msg_new:nnnn { cooking-units } { unknown-option } 
  { 
    The \ option \ '#1' \ is \ not \ defined.
  }{ 
    Perhaps \ you \ misspelled \ the \ option.
    \msg_see_documentation_text:n { cooking-units } 
  }
\msg_new:nnnn { cooking-units } { unknown-choice } 
  { 
    The \ choice \ '#2' \ for \ key \ '#1' \ is \ not \ defined.
  }{ 
    Perhaps \ you \ misspelled \ the \ choice.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { internal-error } 
  { 
   This \ error \ shouldn't \ show. \ This \ means \ I
   \ (the \ package \ author) \  screwed
   \ up. \ The \ error \ code \ is \ '#1'. \
   Addition \ is \ '#2'.
  }{ 
    Please \ send \ me \ a \ bug \ report.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { cooking-units } { definition-key-mistyped? } 
  { 
    This \ message \ shows \ during \ the \ definition \ of \ unit-keys. \
    You \ may \ have \ mistyped \ the \ key \ '#1'. \ You \ may \ see \
    this \ message \ because \ you \ have \ used \ a \ '=' \ sign \ in \ the \
    optional \ argument. \ If \ this \ is \ the \ case \ and \ you \ still \ want
    \ to \ use \ '=' \ in \ a \ symbol, \ please \ wrap \ the \ symbol
    \ in \ two \ braces: \ {{#1=#2}}.
  }{ 
    Or \ try \ using \ the \ 'symbol' \ option.
    \msg_see_documentation_text:n { cooking-units } 
  }
%    \end{macrocode}
% \end{macro}
%
% \section {Helper Macros}
%
% The name says it all.
%
%
%
%
%\begin{macro}
%  {
%    \@@_if_unit_defined:nN,
%    \@@_error_if_unit_not_defined:nNTF,
%    \@@_error_if_unit_not_defined:nTF,
%    \@@_error_if_unit_not_defined:VTF,
%  }
% A little helper macro. Checks if the unit is defined, if not raise an error.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_unit_defined:nN #1 #2 { TF , T }
  {
    \@@_set_unit:Nn #2 {#1}
    \seq_if_in:NVTF \g_@@_list_of_defined_units_seq #2
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_new_protected_conditional:Npnn \@@_error_if_unit_not_defined:nN #1#2 { TF, T, F }
  {
    \@@_if_unit_defined:nNTF {#1} #2
      { \prg_return_false: }
      { 
        \msg_error:nnn { cooking-units } { unknown-unit } {#1} 
        \prg_return_true:
      }
  }
\prg_new_protected_conditional:Npnn \@@_error_if_unit_not_defined:n #1 { TF, T, F }
  {
    \@@_error_if_unit_not_defined:nNTF {#1} \l_@@_scrap_tl
      { \prg_return_true: }
      { \prg_return_false: }
  }
\cs_generate_variant:Nn \@@_error_if_unit_not_defined:nTF { V }
%    \end{macrocode}
%\end{macro}
%
%
%
% \begin{macro} { \@@_if_unit_has_a_key:n, \@@_if_unit_has_a_key:V }
% A little helper macro. Checks if the unit is defined, if not raise an error.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_unit_has_a_key:n #1 { T , F, TF }
  {
    \keys_if_exist:nnTF { cooking-units } {#1}
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \@@_if_unit_has_a_key:n { V } { T, TF }
%    \end{macrocode}
%\end{macro}
%
%
% \begin{macro} { \@@_seq_use_msg:N, \@@_seq_use_msg:c }
%  Used in error messages for units. Prints the units in a comma-seperated list.
%    \begin{macrocode}
\cs_new:Npn \@@_seq_use_msg:N #1
  { \seq_use:Nnnn #1 { ' , ~ ' } { ' , ~ ' } { ' ~ and ~ ' } }
\cs_generate_variant:Nn \@@_seq_use_msg:N { c }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_if_integer:n , \@@_if_integer:V , \@@_if_evaluation_is_integer:nN }
%   Checking if the input consists only of numbers; or only of numbers and
%   the allowed math operators 
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_integer:n #1 { TF , F }
  {
    \tl_map_inline:nn {#1} 
      {
        \tl_if_in:NnF \l_@@_input_digits_tl {##1}
          { 
            \tl_map_break:n { \use_i:nn \prg_return_false: } 
          }
      }
    \prg_return_true: 
  }
\cs_generate_variant:Nn \@@_if_integer:nTF { V }
\prg_new_protected_conditional:Npnn \@@_if_evaluation_is_integer:n #1 { TF , T , F }
  {
    \tl_concat:NNN \l_@@_tmpa_tl
      \l_@@_input_digits_tl \l_@@_allwed_integer_math_operators_tl
    \bool_set_true:N \l_@@_tmpa_bool
    \tl_map_inline:nn {#1}
      {
        \tl_if_in:NnF \l_@@_tmpa_tl {##1}
          { \tl_map_break:n { \bool_set_false:N \l_@@_tmpa_bool } }
      }
    \bool_if:NTF \l_@@_tmpa_bool 
      { \prg_return_true:  }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{ \@@_if_integers:NNTF }
%   Checking if the input consists only of numbers, which works correctly for ranges. 
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_integers:NN #1#2 { TF }
  {
    \@@_if_integer:VTF #1
      {
        \@@_if_print_type_equal:nTF { range } 
          {
            \@@_if_integer:VTF #2
              { \prg_return_true: }
              { \prg_return_false: }
          }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_if_contains_decimal:NTF , \@@_check_for_decimal:w }
%  A fast check if |#1| contains a decimal point. This is only
%  used for already parsed input, so the input is already safe to check.
%  
%  If |#1| does not contain a decimal point, |\@@_check_for_decimal:w|
%  |#2| is equal to |\q_nil|, the test is true and the false branch is executed.
%
%  If |#1| does contain a decimal point, |#2| is going equal to |<...>.\q_nil|
%  where |<...>| is the stuff after the decimal point. The test is false, thus the
%  true branch is ignored (ignoring all other tokens in |#2|).  
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_contains_decimal:N #1 { TF }
  {
    \exp_after:wN \@@_check_for_decimal:w #1 . \q_nil . \q_stop
  }
\cs_new:Npn \@@_check_for_decimal:w #1 . #2 . \q_stop
  { 
    \if_meaning:w \q_nil #2 
      \exp_after:wN \prg_return_false:
    \else:
      \exp_after:wN \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_if_contain_decimals:NNTF}
%  Same as |\@@_if_integers:NNTF| only for decimal points.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_contain_decimals:NN #1#2 { TF }
  {
%    \@@_if_contains_decimal:NTF #1
%      {
%        \@@_if_print_type_equal:nTF { range }
%          {
%            \@@_if_contains_decimal:NTF #2
%              { \prg_return_true: }
%              { \prg_return_false: }
%          }
%          { \prg_return_true: }
%      }
%      { \prg_return_false: }
    \@@_if_contains_decimal:NTF #1
      { \prg_return_true: }
      { 
        \@@_if_print_type_equal:nTF { range }
          {
            \@@_if_contains_decimal:NTF #2
              { \prg_return_true: }
              { \prg_return_false: }
          }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{ \@@_if_gender_error:n }
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_gender_error:n #1 { TF, F , T }
  {
    \str_case:nnTF {#1}
      {
        { m } { }
        { f } { }
        { n } { }
      } 
      { \prg_return_false: }
      {
        \msg_error:nnn { cooking-units } { unknown-gender } {#1} 
        \prg_return_true:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\@@_error_if_group_not_defined:nN, \@@_error_if_group_not_defined:n}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_error_if_group_not_defined:nN #1#2 { F, T , TF }
  {
    \@@_set_unit:Nn #2 {#1}
    \seq_if_exist:cTF { l_@@_group_ #2 _seq } 
      { \prg_return_false: }
      { 
        \msg_error:nn { cooking-units} { group-key-unknown } 
        \prg_return_true:
      }
  }
\prg_new_conditional:Npnn \@@_error_if_group_not_defined:n #1 { F }
  {
    \seq_if_exist:cTF { l_@@_group_ \@@_to_unit:n {#1} _seq } 
      { \prg_return_false: }
      { 
        \msg_error:nn { cooking-units} { group-key-unknown } 
        \prg_return_true:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_define_clear_unit_group:n}
%    \begin{macrocode}
\cs_new:Npn \@@_define_clear_unit_group:n #1
  {
    \@@_set_unit:Nn \l_@@_tmpa_tl {#1}
    \seq_clear_new:c { l_@@_group_ \l_@@_tmpa_tl _seq }
    \keys_define:nn { cooking-units }  
      { 
        #1 .code:n = { \@@_unit_group_convert_units:nn {#1} {##1} } ,
        #1 .groups:n = { change-unit } ,
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_unit_group_convert_units:nn}
%    \begin{macrocode}
\cs_new:Npn \@@_unit_group_convert_units:nn #1#2
  {
    \bool_set_true:N \l_@@_tmpa_bool
    \@@_error_if_group_not_defined:nNT {#1} \l_@@_curr_group_tl
      { \bool_set_false:N \l_@@_tmpa_bool }
    \@@_error_if_unit_not_defined:nNT {#2} \l_@@_curr_unit_tl
      { \bool_set_false:N \l_@@_tmpa_bool }
    \bool_if:NT \l_@@_tmpa_bool    
      {
        \seq_if_in:cVTF { l_@@_group_ \l_@@_curr_group_tl _seq } \l_@@_curr_unit_tl
          {
            \seq_map_inline:cn { l_@@_group_ \l_@@_curr_group_tl _seq }
              { \@@_keys_set:nnn { cooking-units } {##1} {#2} }
          }{
            \msg_error:nnxxx 
              { cooking-units } 
              { group-choice-not-allowed }
              { \l_@@_curr_group_tl } { \l_@@_curr_unit_tl }
              { \@@_seq_use_msg:c { l_@@_group_ \l_@@_curr_group_tl _seq } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_add_to_unit_group_error:n ,  \@@_add_to_unit_group:nn }
%    \begin{macrocode}
\cs_new:Npn \@@_add_to_unit_group_error:n #1 
  { \msg_error:nnn { cooking-units } { No-Value-given } { add-unit-to-group } }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_add_to_unit_group:nn #1#2
  {
    \@@_error_if_group_not_defined:nNF {#1} \l_@@_curr_group_tl
      {
        \clist_map_inline:nn {#2}
          {
            \@@_error_if_unit_not_defined:nNF {##1} \l_@@_curr_unit_tl
              {
                \seq_if_in:cVF { l_@@_group_ \l_@@_curr_group_tl _seq } \l_@@_curr_unit_tl
                  {
                    \seq_put_right:cV
                      { l_@@_group_ \l_@@_curr_group_tl _seq }
                      \l_@@_curr_unit_tl
                  }
              }
          }
      }
  }
\cs_generate_variant:Nn \@@_add_to_unit_group:nn { nV }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\@@_convert_to_eV:}
%   Still work in progress. Will probably forever be. Changes all
%   predefined units into natural units (except for those who cannot
%   be changed, like |Msp.| for example). 
%
%    \begin{macrocode}
\cs_new:Npn \@@_seq_get_overlap:NNTF #1#2 #3#4
  {
    \seq_map_inline:Nn #1
      {
        \seq_if_in:NnT #2 {##1}
          { #3 \seq_map_break:n { \use_none:nn } }
      }
    \use:n {#4}
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_keys_set:nnn #1#2#3
  { \keys_set:nn {#1} { #2 = #3 } }
\cs_generate_variant:Nn \@@_keys_set:nnn { nVV , nVn }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_convert_to_eV:N #1
  {
    \prop_get:NVNTF \g_@@_convert_to_eV_remember_prop 
      #1 \l_@@_tmpa_tl
      { \@@_keys_set:nVV { cooking-units } #1 \l_@@_tmpa_tl }
      {
%      #1 is already a string
        \@@_if_unit_has_a_key:VTF #1
          {
            \tl_set_eq:Nc \l_@@_tmp_unit_tl { l_@@_base_key_unit_ #1 _tl }
            \prop_get:cnNT { l_@@_new_cukeys_ \l_@@_tmp_unit_tl _prop } 
              { Liste } \l_@@_tmpa_seq
              {
                \@@_seq_get_overlap:NNTF \g_@@_natural_units_seq \l_@@_tmpa_seq
                  {
                    \prop_gput:NVn \g_@@_convert_to_eV_remember_prop #1 {##1}
                    \@@_keys_set:nVn { cooking-units } #1 {##1}
                  }
                  { \msg_warning:nnx { cooking-units } { no-natural-unit-known } {#1} }
              } 
          }
          { \msg_warning:nnx { cooking-units } { Key-not-defined } {#1} }
      }
  }
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
\cs_new:Npn \@@_changing_unit_bonkers:N #1
  {
    \prop_get:NVNTF \g_@@_convert_bonkers_remember_prop 
      #1 \l_@@_tmpa_tl
      { \@@_keys_set:nVV { cooking-units } #1 \l_@@_tmpa_tl }
      {
        \tl_case:NnF \l_@@_bonkers_state_tl
          {
            \c_@@_bonkers_state_going_tl { \@@_convert_going_bonkers:N #1 }
            \c_@@_bonkers_state_fully_tl { \@@_convert_fully_bonkers:N #1 }
            \c_@@_bonkers_state_xD_tl { \@@_convert_xD_bonkers:N #1 }
          }
          { \@@_create_internal_error:nN { going-bonkers } \l_@@_bonkers_state_tl }
      }
  }
\cs_new:Npn \@@_convert_going_bonkers:N #1
  {
    \@@_if_unit_has_a_key:VT #1
      {
        \@@_prepare_going_bonkers:N #1 
        \keys_set:nn { cooking-units } { eval-fraction = true }
        \@@_keys_set:nVV { cooking-units } #1 \l_@@_tmpa_tl
        \prop_gput:NVV \g_@@_convert_bonkers_remember_prop #1 \l_@@_tmpa_tl
      }
  }
\cs_new:Npn \@@_convert_fully_bonkers:N #1
  {
    \@@_if_unit_has_a_key:VT #1
      {
        \@@_prepare_going_bonkers:N #1
        \keys_set:nn { cooking-units } 
          { eval-fraction = true , curef-clear-forbidden-units = true }
        \prop_put:NVV \l_@@_change_unit_prop {#1} \l_@@_tmpa_tl
        \@@_cukeys_calculate_change_value:VVV #1 \l_@@_tmpa_tl \l_@@_tmp_unit_tl
      }
  }
\cs_new:Npn \@@_prepare_going_bonkers:N #1
  {
    \tl_set_eq:Nc \l_@@_tmp_unit_tl { l_@@_base_key_unit_ #1 _tl }
    \prop_get:cnN { l_@@_new_cukeys_ \l_@@_tmp_unit_tl _prop } { Liste } \l_@@_tmpa_seq
    \bool_set_false:N \l_@@_tmpa_bool
    \bool_until_do:Nn \l_@@_tmpa_bool
      {
        \tl_set:Nf \l_@@_tmpa_tl { \seq_rand_item:N \l_@@_tmpa_seq }
        \seq_if_in:NVF \g_@@_natural_units_seq \l_@@_tmpa_tl
          { \bool_set_true:N \l_@@_tmpa_bool }
      }
  }
\cs_new:Npn \@@_convert_xD_bonkers:N #1
  {
    \keys_set:nn { cooking-units } { eval-fraction = true , curef-clear-forbidden-units = true }
    \bool_set_false:N \l_@@_tmpa_bool
    \bool_until_do:Nn \l_@@_tmpa_bool
      {
        \tl_set:Nx \l_@@_tmpa_tl { \seq_rand_item:N \g_@@_list_of_defined_units_seq }
        \@@_if_no_unit_marker:NF \l_@@_tmpa_tl
          { \bool_set_true:N \l_@@_tmpa_bool }
      }
    \prop_put:NVV \l_@@_change_unit_prop {#1} \l_@@_tmpa_tl
    \tl_set:cf { l_@@_unit_change_ #1 _tl } { \fp_eval:n { rand() * randint(255) } }
  }
%    \end{macrocode}
%
%
%
% \begin{macro}{\@@_tl_eval:Nn}
% I am using this construction often enough, so \dots\ yeah.
%    \begin{macrocode}
\cs_new:Npn \@@_tl_eval:Nn #1#2 { \tl_set:Nf #1 { \fp_eval:n {#2} } }
\cs_generate_variant:Nn \@@_tl_eval:Nn { Nv, cn }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{  }
% I am using this construction often enough, so \dots\ yeah.
% Note that if the evaluation is |true|, the path taken is the |false| one.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_change_unit: { TF }
  { 
    \@@_if_print_type_equal:nTF { fraction }
      { \prg_return_false: }
      { 
        \@@_if_state_equal:nTF { special_sign }
          { \prg_return_false: }
          { \prg_return_true:  }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_temperature_to_check_print_error:n,\@@_temperatures_to_check_define:nn}
% Commands used in the option \texttt{temperature-to-check}.
% If no value is given (first command) it raises an error. If a value
% is given the  unit is added to a check-list and a new 
% constant is defined.
%    \begin{macrocode}
\cs_new:Npn \@@_temperature_to_check_print_error:n #1
  {
    \@@_error_if_unit_not_defined:n {#1}
    \msg_error:nnn { cooking-units } { No-Value-given } { add-temperature-to-check }
  }
\cs_new:Npn \@@_temperatures_to_check_define:nn #1#2
  {
    \@@_error_if_unit_not_defined:nNF {#1} \l_@@_curr_unit_tl
      {
        \fp_if_exist:cF { l_@@_ \l_@@_curr_unit_tl _min_fp }
          {
            \seq_put_right:NV \l_@@_temperatures_to_check_seq \l_@@_curr_unit_tl
            \fp_new:c { l_@@_ \l_@@_curr_unit_tl _min_fp }
          }
        \fp_set:cn { l_@@_ \l_@@_curr_unit_tl _min_fp } {#2}      
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_set_options_for_error:n }
%    \begin{macrocode}
\cs_new:Npn \@@_set_options_for_error:n  #1
  {
    \@@_error_if_unit_not_defined:n {#1}
    \msg_error:nnn { cooking-units } { No-Value-given } { set-option-for }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_add_options_for_error:n }
%    \begin{macrocode}
\cs_new:Npn \@@_add_options_for_error:n #1
  {
    \@@_error_if_unit_not_defined:n {#1}
    \msg_error:nnn { cooking-units } { No-Value-given } { add-option-for }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_rounding_function:n}
% I think this definition is somewhat stupid, but I don't have a better idea.
%    \begin{macrocode}
\cs_new:Npn \@@_rounding_function:n #1 
  {
    #1
      , \l_@@_round_precision_int
      \bool_if:NT \l_@@_pckopt_round_commercial_bool
        { , #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_label_and_persons:n}
%    \begin{macrocode}
\cs_new:Npn \@@_label_and_persons:n #1 
  { 
    \str_if_in:nnTF {#1} { * }
      { \@@_label_and_persons_times_persons:ww #1 \q_stop }
      { \msg_error:nnn { cooking-units} { Number-of-persons-missing } {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new:Npn \@@_label_and_persons_times_persons:ww #1 * #2 \q_stop
  { 
    \@@_culabel:nn {#1} {#2}
  }
%    \end{macrocode}
%
% \begin{macro}{ \@@_culabel:nn }
%    \begin{macrocode}
\cs_new:Npn \@@_culabel:nn #1#2
  { 
    \int_if_exist:cTF { g_@@_number_of_persons_ #1 _int }
      { \msg_error:nnn { cooking-units } { label-already-defined } {#1} }
      {
        \@@_if_evaluation_is_integer:nTF {#2}
          {
            \int_set:Nn \l_@@_tmpa_int {#2}
            \int_new:c { g_@@_number_of_persons_ #1 _int }
            \int_gset_eq:cN { g_@@_number_of_persons_ #1 _int } \l_@@_tmpa_int
          }
          { \msg_error:nnn { cooking-units } { Number-of-persons-is-not-an-integer } {#2} }      
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_reference_label_and_persons:n }
%    \begin{macrocode}
\cs_new:Npn \@@_reference_label_and_persons:n #1
  { 
    \int_if_exist:cTF { g_@@_number_of_persons_ #1 _int }
      { 
        \bool_set_true:N \l_@@_reference_given_bool
        \int_set_eq:Nc \l_@@_local_number_of_persons_int
          { g_@@_number_of_persons_ #1 _int }
      }
      { \msg_error:nnn { cooking-units } { label-not-defined } {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_curef:n }
%    \begin{macrocode}
\cs_new:Npn \@@_curef:n #1
  { 
    \int_if_exist:cTF { g_@@_number_of_persons_ #1 _int }
      {
        \bool_if:NTF \l_@@_pckopt_recalculate_amount_bool
          { \int_use:N \l_@@_wanted_number_of_persons_int }
          { \int_use:c { g_@@_number_of_persons_ #1 _int } }
      }{ \msg_error:nnn { cooking-units } { label-not-defined } {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \culabel , \curef  }
%    \begin{macrocode}
\NewDocumentCommand \culabel { m m } { \@@_culabel:nn {#1} {#2} }
\NewExpandableDocumentCommand \curef { m } { \@@_curef:n {#1} }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{ \@@_check_minus_remove_and_reverse:NN }
% Can probably optimize this as the sign is always at the first place
% (this is done after cheking the input, so the assumption is safe), but yeah \dots
%    \begin{macrocode}
\cs_new:Npn \@@_check_minus_remove_and_reverse:NN #1#2
  {
    \quark_if_nil:NF #2
      {
        %% Maybe simplify by a command?
        \tl_if_in:NnT #2 { - }
          {
            \tl_remove_once:Nn #2 { - }
            \bool_if:NTF #1 { \bool_set_false:N } { \bool_set_true:N } #1
          }
        \@@_check_minus_remove_and_reverse:NN #1
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% 
%
%    \begin{macrocode}
\cs_new:Npn \@@_add_forbidden_unit:n #1
  {
    \seq_set_from_clist:Nn \l_@@_tmpa_seq {#1}
    \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \@@_error_if_unit_not_defined:nNF {##1} \l_@@_curr_unit_tl
          {
            \seq_if_in:NVF \l_@@_curef_do_not_change_seq \l_@@_curr_unit_tl
              { \seq_put_right:NV \l_@@_curef_do_not_change_seq \l_@@_curr_unit_tl }
          }
      }
  }
\cs_new:Npn \@@_remove_forbidden_unit:n #1
  {
    \seq_set_from_clist:Nn \l_@@_tmpa_seq {#1}
    \seq_map_inline:Nn \l_@@_tmpa_seq
      {
        \@@_error_if_unit_not_defined:nNF {##1} \l_@@_curr_unit_tl
          {
            \seq_if_in:NVTF \l_@@_curef_do_not_change_seq \l_@@_curr_unit_tl
              { \seq_remove_all:NV \l_@@_curef_do_not_change_seq \l_@@_curr_unit_tl }
              { 
                \msg_warning:nnnn { cooking-units } { curef-not-inside-list } {##1} 
                  { \@@_seq_use_msg:N \l_@@_curef_do_not_change_seq }
              }
          }
      }
  }
\cs_new:Npn \@@_clear_forbidden_unit:
  { \seq_clear:N \l_@@_curef_do_not_change_seq }
%    \end{macrocode}
%
%
%
%
%
%
%    \begin{macrocode}
\NewDocumentCommand \cudeclareunitgroup { m m }
  {
    \@@_define_clear_unit_group:n {#1}
    \@@_add_to_unit_group:nn {#1} {#2}
  }
\NewDocumentCommand \cuaddtounitgroup { m m }
  {
    \@@_add_to_unit_group:nn {#1} {#2}
  }
\NewDocumentCommand \cuclearunitgroup { m }
  {
    \@@_error_if_group_not_defined:nF {#1}
      { \@@_define_clear_unit_group:n {#1} }
  }
%    \end{macrocode}
%
%
%
%
%
%
%
%
% \begin{macro}{ \cusetoptionfor , \cuaddoptionfor , \cuclearoptionfor}
%  \pkg{cooking-units} allows to attach options to units. Every time the unit
%  is used, the option is executed (technically it is similar or equal to a hook).
%  Using these commands, one can set (overwrites all previous options),
%  add or clear options for a unit or a list of units.
%    \begin{macrocode}
\NewDocumentCommand \cusetoptionfor { m m }
  { \@@_set_options_for:nn {#1} {#2} }
\NewDocumentCommand \cuaddoptionfor { m m }
  { \@@_add_options_for:nn {#1} {#2} }
\NewDocumentCommand \cuclearoptionfor { m }
  { \@@_clear_options_for:n {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_options_for:nn , \@@_add_options_for:nn , \@@_clear_options_for:n}
%  These commands are quite similar, excpet for a few details.
%  First, store the unit or list of units |#1| and the list of options |#2|. 
%  At the end, for each unit in |#1| a clist will be created (if not already existing)
%  where the options will be put \emph{via} |\clist_set:cn|, |\clist_put_right:cn|
%  or will be cleared (see there).
%
%  E.g.\ |\clist_set:cn| will get something like |\clist_set:cV {...unit...clist} \clist_containing_options_clist|.
%  As |\clist_clear:c| does not take a second argument, we will eat it \emph{via}
%  |\use_i_ii:nnn|.
%    \begin{macrocode}
\cs_new:Npn \@@_set_options_for:nn #1#2
  {
    \@@_map_trough_valid_unit_options:nnn {#1} {#2} { \clist_set:cV }
  }
\cs_new:Npn \@@_add_options_for:nn #1#2
  {
    \@@_map_trough_valid_unit_options:nnn {#1} {#2} { \clist_put_right:cV }
  }
\cs_new:Npn \@@_clear_options_for:n #1
  {
    \@@_map_trough_valid_unit_options:nnn {#1} { \q_no_value } { \clist_clear:c }
  }
\cs_generate_variant:Nn \@@_set_options_for:nn { V }
\cs_generate_variant:Nn \@@_clear_options_for:n { V }
%    \end{macrocode}
% \end{macro}
%  
%  \begin{macro}{\@@_map_trough_valid_unit_options:nnn}
%  The first thing is command does is to map through the given unit list |#1|
%  and check if the unit(s) exist or not. If they exist, store them in the sequence
%  |\l_@@_tmpa_seq| for later use. Else, ignore it and print a warning.
%
%  If |#2| is a |\q_no_value| we know that there is no need to map through |#2|.
%  Whatever the command |#3| does, it does so only to the clist
%  |l_@@_unit_option_ <unit> _clist|.
%
%  If |#2| is anything else, follow the |else| branch. After veryfing that |#2|
%  is non-empty map through the option list given in |#2|. All valid keys
%  (and their agrument) is stored in |\l_@@_tmpa_clist|. 
%  Afterwards, the clist for each unit in |\l_@@_tmpa_seq| is modified by the command
%  in |#3| and is given the list of options |\l_@@_tmpa_clist| as an argument.
%  (Note: |\l_@@_tmpa_clist| can be empty).
%    \begin{macrocode}
\cs_new:Npn \@@_map_trough_valid_unit_options:nnn #1#2 #3
  {
    \seq_clear:N \l_@@_tmpa_seq
    \clist_clear:N \l_@@_tmpa_clist
    \clist_map_inline:nn {#1}
      {
        \@@_error_if_unit_not_defined:nNF {##1} \l_@@_curr_unit_tl
          { \seq_put_right:NV \l_@@_tmpa_seq \l_@@_curr_unit_tl }
      }
    \quark_if_no_value:nTF {#2}
      {
        \seq_map_inline:Nn \l_@@_tmpa_seq 
          { #3 { l_@@_unit_option_ ##1 _clist } }
      }{
        \tl_if_empty:nF {#2}
          { \@@_unit_options_check_validity:n {#2} }
        \seq_map_inline:Nn \l_@@_tmpa_seq 
          { #3 { l_@@_unit_option_ ##1 _clist } \l_@@_tmpa_clist }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{ \@@_unit_options_check_validity:n }
%  If the list of options is non-empty, we parse over them using
%  |\keyval_parse:NNn|. For this we need two commands, one for keys
%  with argument, one without arguments. All the commands do is to check
%  if the key given does exist. And if they do, store them in |\l_@@_tmpa_clist|.
%    \begin{macrocode}
\cs_new:Npn \@@_unit_options_check_validity:n #1
  {
    \keyval_parse:NNn
      \@@_unit_options_check_validity_aux_i:n
      \@@_unit_options_check_validity_aux_ii:nn
      {#1}
  }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{ \@@_unit_options_check_validity_aux_i:n , 
%    \@@_unit_options_check_validity_aux_ii:nn }
%  Check if the key exist; if it is then put it in |\l_@@_tmpa_clist| (just the key, or with the value).
%  Sadly, checking if the value |#2| can be accepted by the key is not really testable.
%    \begin{macrocode}
\cs_new:Npn \@@_unit_options_check_validity_aux_i:n #1
  {
    \keys_if_exist:nnTF { cooking-units } {#1}
      { \clist_put_right:Nn \l_@@_tmpa_clist {#1} }
      { \msg_error:nnn { cooking-units } { unknown-option } {#1} }
  }
\cs_new:Npn \@@_unit_options_check_validity_aux_ii:nn #1#2
  {
    \keys_if_exist:nnTF { cooking-units } {#1}
      { 
        \clist_put_right:Nn \l_@@_tmpa_clist { #1= {#2} }
%        \keys_if_choice_exist:nnnTF { cooking-units } {#1} {#2}
%          { \clist_put_right:Nn \l_@@_tmpa_clist { #1= {#2} } }
%          { \msg_error:nnnn { cooking-units } { unknown-choice } {#1} {#2} }
      }
      { \msg_error:nnn { cooking-units } { unknown-option } {#1} }
  }
%    \end{macrocode}
% \end{macro}
% 
%
%
%
%
%
%
%
%
%
% \subsection{Language Macros}
%
%
% The following commands are just wrapper around the commands from the
% \pkg{translations} package.
%
% \begin{macro}{ \@@_culang_def_base:nnn , \@@_culang_def_base:nnv , \@@_culang_def_base:nVn}
%    \begin{macrocode}
\cs_new:Npn \@@_culang_def_base:nnn #1#2#3
  { \declaretranslationfallback { #2 - #1 (@@) } {#3} }
\cs_generate_variant:Nn \@@_culang_def_base:nnn { nnv, nVn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_culang_def_for:nnnn, \@@_culang_def_for:VnnV , \@@_culang_def_for:Vnnn }
%    \begin{macrocode}
\cs_new:Npn \@@_culang_def_for:nnnn #1#2#3#4
  { \declaretranslation {#1} { #3 - #2  (@@) } {#4} }
\cs_generate_variant:Nn \@@_culang_def_for:nnnn { VnnV, V  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_culang_print:nn , \@@_culang_print:nV }
%    \begin{macrocode}
\cs_new:Npn \@@_culang_print:nn #1#2
  { \GetTranslation { #2 - #1  (@@) } }
\cs_generate_variant:Nn \@@_culang_print:nn { nV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_culang_let:nnN }
%    \begin{macrocode}
\cs_new:Npn \@@_culang_let:nnN #1#2#3
  { \SaveTranslation #3 { #2 - #1 (@@) } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_culang_let_for:nnnN , \@@_culang_let_for:VnnN }
%    \begin{macrocode}
\cs_new:Npn \@@_culang_let_for:nnnN #1#2#3#4
  { \SaveTranslationFor #4 {#1} { #3-#2 (@@) } }
\cs_generate_variant:Nn \@@_culang_let_for:nnnN { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{ \@@_culang_if_translation_exists_for:nnn, \@@_culang_if_translation_exists_for:Vnn}
%    \begin{macrocode}
\cs_new:Npn \@@_culang_if_translation_exists_for:nnnTF #1#2#3
  { \IfTranslation {#1} { #3 - #2 (@@) } }
\cs_generate_variant:Nn \@@_culang_if_translation_exists_for:nnnTF { V }
%    \end{macrocode}
% \end{macro}
% 
%
%
%
%
% \begin{macro}[TF, F]{\@@_culang_unitname_let:Nn , \@@_culang_unitname_let:NV }
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_culang_unitname_let:Nn #1#2 { TF, F , T }
  {
    \@@_culang_let:nnN { name } {#2} #1
    \tl_if_eq:NNTF #1 \q_@@_no_translation
      { \prg_return_false: }
      { \prg_return_true: }
  }
\cs_generate_variant:Nn \@@_culang_unitname_let:NnTF { NV, Nx }
\cs_generate_variant:Nn \@@_culang_unitname_let:NnT {  Nx }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_culang_one_let:Nn , \@@_culang_one_let:NV , 
%   \@@_culang_one_let_by_gender:Nn , \@@_culang_one_let_by_gender:NV 
%  }
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_culang_one_let:Nn #1#2 { T }
  {
    \@@_culang_let:nnN { gender } {#2} \l_@@_tmpa_tl
    \@@_culang_one_let_by_gender:NVTF #1 \l_@@_tmpa_tl
      { \prg_return_true: }
      {
        \tl_set:Nn #1 { 1 }
        \prg_return_false:
      }
  }
\cs_generate_variant:Nn \@@_culang_one_let:NnT { NV }
\prg_new_conditional:Npnn \@@_culang_one_let_by_gender:Nn #1#2 { TF }
  {
    \@@_culang_unitname_let:NnTF #1 { one (#2) } 
      { \prg_return_true: }
      { 
        \msg_error:nnx { cooking-units } { Translation-not-available } { one (#2) }
        \prg_return_false: 
      }
  } 
\cs_generate_variant:Nn \@@_culang_one_let_by_gender:NnTF { NV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \g_@@_allowed_special_keys_seq }
%   Defining the translation for the decimal-mark. Note that those
%   'phrases' are stored inside
%   \verb|\g_@@_allowed_special_keys_seq|.
%   Furthermore some translations are defined.
%    \begin{macrocode}
\seq_gset_from_clist:Nn \g_@@_allowed_special_keys_seq
  {
    cutext-range-sign , 
    decimal-mark ,
    one (m) ,
    one (f) ,
    one (n)
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\@@_culang_def_base:nnn { name } { decimal-mark }  { . }
\@@_culang_def_base:nnn { name-pl } { decimal-mark } { \q_@@_no_translation }
\@@_culang_def_for:nnnn { German } { name-pl } { decimal-mark } { , }
%    \end{macrocode}
% Note that the plural versions just exist for completing the set.
%    \begin{macrocode}
\@@_culang_def_base:nnn { name } { one (m) } { \q_@@_no_translation }
\@@_culang_def_base:nnn { name } { one (f) } { \q_@@_no_translation }
\@@_culang_def_base:nnn { name } { one (n) } { \q_@@_no_translation }
\@@_culang_def_base:nnn { name-pl } { one (m) }  { \q_@@_no_translation }
\@@_culang_def_base:nnn { name-pl } { one (f) } { \q_@@_no_translation }
\@@_culang_def_base:nnn { name-pl } { one (n) } { \q_@@_no_translation }
%    \end{macrocode}
%    \begin{macrocode}
\@@_culang_def_for:nnnn { English } { name } { one (m) } { one }
\@@_culang_def_for:nnnn { English } { name } { one (f) } { one }
\@@_culang_def_for:nnnn { English } { name } { one (n) } { one }
%    \end{macrocode}
%    \begin{macrocode}
\@@_culang_def_for:nnnn { German } { name } { one (m) } { ein }
\@@_culang_def_for:nnnn { German } { name } { one (f) } { eine }
\@@_culang_def_for:nnnn { German } { name } { one (n) } { ein }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_culang_def_base:nnn { name } { cutext-range-sign } { -- }
\@@_culang_def_base:nnn { name-pl } { cutext-range-sign } { \q_@@_no_translation }
\@@_culang_def_for:nnnn { German } { name } { cutext-range-sign } { ~bis~ }
\@@_culang_def_for:nnnn { English } { name } { cutext-range-sign } { ~to~ }
%    \end{macrocode}
%
%
% \section{General}
%
% This section collects commands which are used by all four main commands
% (\mycs{cunum}, \cCutext, \mycs{cuam}), hence the name.
% 
%
% \subsection{Enums \& States}
% 
% These variables decide what the main commands (\cs{cunum}, etc.) should do.
% Is there an error? Special-sign? Fraction? Range? Which command is used?
% This is defined here.
%
% \begin{macro}{ \@@_def_new_type:nnn , \@@_def_new_type_aux:cnn , \@@_def_new_type_aux:Nnn}
%  Defines my variants, all in one handy command (well, two commands).
%  |#1| is the base name of the new state. |#2| are the conditions for
%  |\prg_new_conditional|. |#3| are the possible states, given as a comma list.
%    \begin{macrocode}
\cs_new:Npn \@@_def_new_type:nnn #1#2#3
  {
    \tl_new:c { l_@@_ #1 _tl }
    \clist_map_inline:nn {#3}
      { \tl_const:cn { c_@@_ #1 _ ##1 _tl } {##1} }
    \@@_def_new_type_aux:cnn { l_@@_ #1 _tl } {#1} {#2}
  }
%    \end{macrocode}
%  Defines the commands |@@_set_<base name>_to:n| and (if wanted)
%  |@@_if_ <base name> _equal:n|. For maybe optimization (not sure why)
%  I decided that |#1| is the token varable which stores the state we are currently
%  in. 
%    \begin{macrocode}
\cs_new:Npn \@@_def_new_type_aux:Nnn #1#2#3
  {
    \cs_new:cpn { @@_set_ #2 _to:n } ##1
      { 
        \tl_if_exist:cF { c_@@_#2_ ##1 _tl } { \tl_show:n { ERROR-set-#2-##1 } }
        \tl_set_eq:Nc #1 { c_@@_#2_ ##1 _tl } 
      }
    \tl_if_empty:nF {#3}
      {
        \prg_new_conditional:cpnn { @@_if_ #2 _equal:n } ##1 {#3}
          {
            \tl_if_exist:cF { c_@@_#2_ ##1 _tl } { \tl_show:n { ERROR-check-#2-##1 } }
            \tl_if_eq:NcTF #1 { c_@@_#2_ ##1 _tl } 
              { \prg_return_true: }
              { \prg_return_false: }
          }
      }
  }
\cs_generate_variant:Nn \@@_def_new_type_aux:Nnn { c }
%    \end{macrocode}
% \end{macro}
%
% Defining some states.
%    \begin{macrocode}
\@@_def_new_type:nnn { state } { TF , T , F } 
  { normal , special_sign , 42 , error }
\@@_def_new_type:nnn { cmd_type } { TF , T , p } 
  { cunum , cCutext , cuam }
\@@_def_new_type:nnn { parse_and_process_type } { TF , T } 
  { number , range , fraction  }
\@@_def_new_type:nnn { print_type } { TF , T } 
  { unknown , number , range , fraction  }
\@@_def_new_type:nnn { bonkers_state } { } 
  { normal , going , fully , xD }
%    \end{macrocode}
%
% Setting a default state..
%    \begin{macrocode}
\tl_set_eq:NN \l_@@_bonkers_state_tl \c_@@_bonkers_state_normal_tl
%    \end{macrocode}
%
%
% \subsection{The main stuff}
%
% \begin{macro} { \@@_expand_unit_input:Nn , \@@_expand_amount_input:Nn }
%    \begin{macrocode}
\cs_new:Npn \@@_expand_unit_input:Nn #1#2
  {
    \cs_if_exist_use:c { exp_args:NN \l_@@_unit_argument_spec_tl } 
    \@@_set_unit:Nn #1 {#2}
  }
\cs_new:Npn \@@_expand_amount_input:Nn #1#2
  {
    \cs_if_exist_use:c { exp_args:NN \l_@@_expand_amount_tl } 
    \@@_set_amount:Nn #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{ \@@_do_the_stuff:nnnnn , \@@_do_the_stuff:nnnnn }
%   Main command shared by |\cunum|, etc.\ It reads the input
%   parses options and decides (depending on which command was used)
%   what to do with the stuff and how to print it.
%    \begin{macrocode}
\bool_new:N \l_@@_skip_first_part_bool
\cs_new:Npn \@@_do_the_stuff:nnnnnn #1#2#3#4#5#6
  {
%  #1 -- label
%  #2 -- options
%  #3 -- amount
%  #4 -- space
%  #5 -- unit
    \@@_initialice_accordingly:nnnn {#1} {#4} {#2} {#5}
    \@@_use_hook_accordingly:
    \@@_parse_the_amount:n {#3}
    \@@_general_checkups:
    \@@_if_state_equal:nTF { normal }
      { \@@_process_amount_normally:n {#2} }
      { \@@_process_amount_special: }
    \@@_new_print_amount_correctly:
    \@@_new_print_unit_correctly:
  }
\cs_generate_variant:Nn \@@_do_the_stuff:nnnnnn { nnnnV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_initialice_accordingly:nnnn , \@@_initialice_addon_cutext: }
% This cs first initializes stuff that is equal for all commands, then 
% does command-specific things. The default stuff includes checking if the
% unit is valid, setting some bools, sets options (including change of units), etc.
%
% For |\cunum| we set the space used for |\phantom|, for |\cuam| we do nothing.
%    \begin{macrocode}
\cs_new:Npn \@@_initialice_accordingly:nnnn #1#2#3#4
  {
    \@@_initialize_new_default:nnn {#1} {#3} {#4}
    \@@_initialize_new_default_units:
    \tl_case:NnF \l_@@_cmd_type_tl
      {
        \c_@@_cmd_type_cunum_tl { \tl_set:Nn \l_@@_phantom_tl {#2} }
        \c_@@_cmd_type_cCutext_tl  { \@@_initialice_addon_cutext: }
        \c_@@_cmd_type_cuam_tl { }
      }
      { \@@_create_internal_error:nN { init-acc } \l_@@_cmd_type_tl }
  }
%    \end{macrocode}
% For \cCutext\ we first check if the user wants to use \cCutext\ at all.
% If not, change it to |\cunum|. 
%    \begin{macrocode}
\cs_new:Npn \@@_initialice_addon_cutext:
  {
    \bool_if:NT \l_@@_pckopt_cutext_to_cunum_bool
      { \@@_set_cmd_type_to:n { cunum } }
    \bool_set_false:N \l_@@_cutext_last_amount_equ_one_bool
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_initialize_new_default:nnn , \@@_initialize_new_default:nnV  , 
%    \@@_intialize_new_default_units:
%  }
% Shared by all commands and (nearly) first thing done. Sets the options,
% sets the unit (and expands it if necessary), checks if unit is defined.
% For |\cuam| the unit is a special |\c_@@_no_unit_marker_tl|. I could just check
% if |\cuam| is used, but I think this is more general. If the marker is used
% we do nothing, else we we check how the units change.
%    \begin{macrocode}
\cs_new:Npn \@@_initialize_new_default:nnn #1#2#3
  {
    \tl_clear:N \l_@@_option_unit_tl
    \tl_if_empty:nF {#2} { \keys_set:nn { cooking-units } {#2} }
    \IfNoValueF {#1}
      { \@@_reference_label_and_persons:n {#1} }
    \@@_expand_unit_input:Nn \l_@@_original_unit_tl {#3}
    \@@_error_if_unit_not_defined:VTF \l_@@_original_unit_tl
      { 
        \@@_set_state_to:n { error } 
        \bool_set_true:N \l_@@_unit_error_bool
      } 
      { \@@_set_state_to:n { normal } }
    \@@_set_parse_and_process_type_to:n { number }
    \@@_set_print_type_to:n { unknown }
    \tl_clear:N \l_@@_phantom_tl
    \@@_initialize_new_default_units:
  }
%    \end{macrocode}
% First, convert the original unit to eV or a bonkers unit if necessary.
% If we have an unit-change, store the wanted unit in |\l_@@_option_unit_tl|.
%    \begin{macrocode}
\cs_new:Npn \@@_initialize_new_default_units:
  {
    \@@_if_no_unit_marker:NTF \l_@@_original_unit_tl
      { \tl_set_eq:NN \l_@@_option_unit_tl \l_@@_original_unit_tl }
      { \@@_intialize_new_default_units_aux: }
  }
\cs_new:Npn \@@_intialize_new_default_units_aux:
  {
    \bool_if:NTF \l_@@_pckopt_bonkers_bool
      { \@@_changing_unit_bonkers:N \l_@@_original_unit_tl }
      {
        \bool_if:NT \l_@@_pckopt_convert_to_eV_bool
          { \@@_convert_to_eV:N \l_@@_original_unit_tl }
      }
    \prop_get:NVNF \l_@@_change_unit_prop \l_@@_original_unit_tl \l_@@_option_unit_tl
      { \tl_set_eq:NN \l_@@_option_unit_tl \l_@@_original_unit_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_initialise_new_after_parsing:n}
% As the name suggests, this one is used \emph{after} parsing the amount.
% This is done in order to know if there is an error, if the unit needs
% to be changed and if this command needs to be called at all.
%
% It is kinda difficult to decide which unit is the correct one, as it may change
% due to unit-options. In theory this could lead to an infinite loop,
% so I decide in this place how things are printed and which unit
% is used.
%
% Well, in the end I only decide if a fraction is printed or not. The case of error or
% special signs were already sorted out.
%
% To make sure the lokal options override the unit-options, we set
% the options again after unit-options.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_initialise_new_after_parsing:n #1
  {    
    \clist_if_empty:cF { l_@@_unit_option_ \l_@@_decided_unit_tl _clist }
      {
        \keys_set_filter:nnv 
          { cooking-units } 
          { change-unit } 
          { l_@@_unit_option_ \l_@@_decided_unit_tl _clist }
        \tl_if_empty:nF {#1} { \keys_set:nn { cooking-units } {#1} }
      }
    \bool_set_eq:NN \l_@@_lokal_numeral_bool \l_@@_pckopt_print_numeral_bool
  }
\cs_new:Npn \@@_decide_unit:
  {
    \@@_change_unit:TF
      { \tl_set_eq:NN \l_@@_decided_unit_tl \l_@@_option_unit_tl }
      { \tl_set_eq:NN \l_@@_decided_unit_tl \l_@@_original_unit_tl }
  }  
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_new_setup_bools_for_process_and_prints:}
% Determines some stuff for later use in the processing/printing department.
% It checks if the amount needs to be recalculated; and if fractions should be
% printed or not.
%    \begin{macrocode}
\cs_new:Npn \@@_new_setup_bools_for_process_and_prints:
  {
    \bool_set_false:N \l_@@_lokal_recalc_for_people_bool
    \bool_lazy_and:nnT
      { \l_@@_reference_given_bool } 
      { \l_@@_pckopt_recalculate_amount_bool }
      { 
        \int_compare:nNnF 
          { \l_@@_wanted_number_of_persons_int }
          =
          { \l_@@_local_number_of_persons_int }
          { \bool_set_true:N \l_@@_lokal_recalc_for_people_bool }
      }
    \@@_if_print_type_equal:nT { fraction }
      {
        \bool_lazy_or:nnTF
          { \l_@@_pckopt_eval_fractions_bool }
          { \l_@@_lokal_recalc_for_people_bool }
          { \@@_set_print_type_to:n { number } }
          {
%          "Convert" fractions \emph{only} if a unit change is requested.
            \bool_lazy_and:nnT
              { \l_@@_pckopt_convert_fractions_bool }
              { ! \tl_if_eq_p:NN \l_@@_option_unit_tl \l_@@_original_unit_tl }              
              { \@@_set_print_type_to:n { number } }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_use_hook_accordingly: }
% Hooks are straightforward. I know which command I used and thus set the
% respective hook.
%    \begin{macrocode}
\cs_new:Npn \@@_use_hook_accordingly:
  {
    \l_@@_cmd_hook_tl
    \tl_case:NnF \l_@@_cmd_type_tl
      {
        \c_@@_cmd_type_cunum_tl { \l_@@_cunum_hook_tl }
        \c_@@_cmd_type_cCutext_tl
          {
            \bool_if:NTF \l_@@_cutext_uppercase_word_bool
              { \l_@@_Cutext_hook_tl }
              { \l_@@_cutext_hook_tl }
          }
        \c_@@_cmd_type_cuam_tl { \l_@@_cuam_hook_tl }
      }
      { \@@_create_internal_error:nN { use-hook-acc } \l_@@_cmd_type_tl }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{ \@@_general_checkups: }
% Doing some general stuff and tests which are done before further processing
% the amount.
%    \begin{macrocode}
\cs_new:Npn \@@_general_checkups: 
  {
    \tl_set_eq:NN \l_@@_print_type_tl \l_@@_parse_and_process_type_tl
    \@@_if_state_equal:nT { normal }
      { \@@_new_setup_bools_for_process_and_prints: }
    \@@_decide_unit:
    \@@_if_cmd_type_equal:nT { cCutext }
      { \@@_cutext_check_if_translation_available: }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_process_amount_normally:n}
% This command is called after parsing the amount if no special-sign, error
% or so is encountered. First, initialize some stuff that is going to be important.
% Afterwards, if \cCutext\ is used, check if a translation is available.
% Then process the input depending on which case (number, range, fraction) we had.
%    \begin{macrocode}
\cs_new:Npn \@@_process_amount_normally:n #1
  {
    \@@_initialise_new_after_parsing:n {#1}
    \tl_case:NnF \l_@@_parse_and_process_type_tl
      {
        \c_@@_parse_and_process_type_number_tl  \@@_new_process_number_in_input: 
        \c_@@_parse_and_process_type_range_tl     \@@_new_process_range_in_input:
        \c_@@_parse_and_process_type_fraction_tl  \@@_new_process_fraction_in_input:  
      }
      { \@@_create_internal_error:nN { process_the_input } \l_@@_parse_and_process_type_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
% This is called if the state is not \enquote{normal}. So the whole \enquote{process}
% part is skipped. If a special sign was detected, print a warining. If
% the 42-bool is true, change the amount accordingly. Nothing else is done.
%    \begin{macrocode}
\cs_new:Npn \@@_process_amount_special:
  {
    \@@_if_state_equal:nT { special_sign }
      { \msg_warning:nnV { cooking-units } { amount-not-known } \l_@@_original_amount_tl }
    \bool_if:NT \l_@@_pckopt_fourty_two_bool
      { \@@_prepare_fourty_two_amount: }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_prepare_fourty_two_amount: }
% Simply replaces all variables with |42|. We can change all (except for the mixed fraction tl)
% as we know if we are going to print a \enquote{number}, \enquote{range} or 
% \enquote{fraction}.
%    \begin{macrocode}
\cs_new:Npn \@@_prepare_fourty_two_amount:
  {
    \tl_set:Nn \l_@@_number_tmpa_tl { 42 }
    \tl_set:Nn \l_@@_number_tmpb_tl { 42 }
    \tl_if_empty:NF \l_@@_mixed_fraction_tl
      { \tl_set:Nn \l_@@_mixed_fraction_tl { 42 } }
    \@@_if_state_equal:nT { special_sign }
      { 
        \tl_put_right:Nn \l_@@_number_tmpa_tl { (!) } 
        \tl_put_right:Nn \l_@@_number_tmpb_tl { (!) } 
        \tl_if_empty:NF \l_@@_mixed_fraction_tl
          { \tl_put_right:Nn \l_@@_mixed_fraction_tl { (!) }  }
      }
  }  
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Process the input}
%
% \begin{macro}{ \@@_new_process_number_in_input: }
% Straightforward. The number only consists of a number. Thus
% calculate the things necessary and post process it depending on the command
% (|\cunum|, etc.)\ used.
%    \begin{macrocode}
\cs_new:Npn \@@_new_process_number_in_input:
  {
    \@@_calculate_and_store_in:N \l_@@_number_tmpa_tl
    \@@_post_process_accordingly:NN \l_@@_number_tmpa_tl \q_no_value
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_process_range_in_input: }
% Same as before, this time with two variables.
%    \begin{macrocode}
\cs_new:Npn \@@_new_process_range_in_input:
  {
    \@@_calculate_and_store_in:N \l_@@_number_tmpa_tl 
    \@@_calculate_and_store_in:N \l_@@_number_tmpb_tl 
    \@@_post_process_accordingly:NN \l_@@_number_tmpa_tl \l_@@_number_tmpb_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_process_range_in_input: }
% Here we are a bit more complicated, but not much.
% For fractions, we generally do not calculate the several numbers.
%
% First, remove the minus signs from the numbers (if any).
% Afterwards check if the printing type is a \enquote{number} (\enquote{range} is
% not possible). If a \enquote{number} is requested, convert the fraction
% to a number (simply by calculating the fraction). If we have a fraction, nothing
% else needs to be done.
%    \begin{macrocode}
\cs_new:Npn \@@_new_process_fraction_in_input:
  {
    \@@_process_and_remove_minus_in_fraction:NNNN \l_@@_minus_bool
      \l_@@_mixed_fraction_tl
      \l_@@_number_tmpa_tl
      \l_@@_number_tmpb_tl
    \@@_if_print_type_equal:nT { number }
      {
        \@@_convert_fraction_to_number_in_input:NNN
          \l_@@_mixed_fraction_tl
          \l_@@_number_tmpa_tl
          \l_@@_number_tmpb_tl
      }
  }
%    \end{macrocode}
% This command loops over each variable, removes the minus and reverses the
% bool if needed.
%    \begin{macrocode}
\cs_new:Npn \@@_process_and_remove_minus_in_fraction:NNNN #1 #2#3#4
  {
    \bool_set_false:N #1
    \@@_check_minus_remove_and_reverse:NN
      #1 #2#3#4
      \q_nil
  }  
%    \end{macrocode}
% Convert a fraction to a number. Check if the denominator is 0, if so, print an
% error. Else, simply evaluate the fraction. If the minus bool is true,
% add a minus sign on the left. Afterwards, process it as a number.
%    \begin{macrocode}
\cs_new:Npn \@@_convert_fraction_to_number_in_input:NNN #1#2#3
  {
    \fp_compare:nNnTF {#3} = { 0 }
      { \@@_create_error:n { Division-by-zero } }
      {
        \@@_tl_eval:Nn \l_@@_number_tmpa_tl { #1 + #2 / #3 }
        \bool_if:NT \l_@@_minus_bool
          { \tl_put_left:Nn \l_@@_number_tmpa_tl { - } }
        \@@_new_process_number_in_input:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_new_print_amount_correctly: }
% After parsing, processing, etc.\ it is time to print the amount.
% If an error was raised, simply print the \enquote{unparsed} original amount.
%
% Else, print the amount depending on \enquote{number}, \enquote{range}
% or \enquote{fraction}. \enquote{number} and \enquote{range} are printed
% according to the command used (|\cunum|, etc.).  Fractions are printed
% indipendently from the commands.
%    \begin{macrocode}
\cs_new:Npn \@@_new_print_amount_correctly:
  {
    \@@_if_state_equal:nTF { error }
      { \l_@@_original_amount_tl }
      {
        \tl_case:NnF \l_@@_print_type_tl
          {
            \c_@@_print_type_number_tl 
              { 
                \@@_print_number_accordingly:N 
                  \l_@@_number_tmpa_tl 
              }
            \c_@@_print_type_range_tl 
              { 
                \@@_print_range_accordingly:NN 
                  \l_@@_number_tmpa_tl 
                  \l_@@_number_tmpb_tl 
              }
            \c_@@_print_type_fraction_tl
              {
                \@@_culang_let:nnN { name } { decimal-mark } \l_@@_translation_tmpa_tl
                \tl_replace_once:Nnn \l_@@_mixed_fraction_tl { . } \l_@@_translation_tmpa_tl
                \tl_replace_once:Nnn \l_@@_number_tmpa_tl { . } \l_@@_translation_tmpa_tl
                \tl_replace_once:Nnn \l_@@_number_tmpb_tl { . } \l_@@_translation_tmpa_tl
                \@@_print_fractions:Nnn 
                  \l_@@_mixed_fraction_tl 
                  \l_@@_number_tmpa_tl 
                  \l_@@_number_tmpb_tl  
              }
          }
          { \@@_create_internal_error:nN { print_the_input } \l_@@_print_type_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_print_unit_correctly: , \@@_print_unit_in_case_of_error: }
% Prints the unit. In case of error, print the unit more or less directly.
% Even in case of error there needs to be the correct spacing, etc.
%
% Else, parse the unit depending on the command used. For |\cuam| no unit
% is printed, but a phrase can be required.
%    \begin{macrocode}
\cs_new:Npn \@@_new_print_unit_correctly:
  {
    \@@_if_state_equal:nTF { error }
      { \@@_print_unit_in_case_of_error: }
      {
        \tl_case:NnF \l_@@_cmd_type_tl
          {
            \c_@@_cmd_type_cunum_tl { \@@_cunum_print_correct_unit: }
            \c_@@_cmd_type_cCutext_tl { \@@_cutext_print_correct_unitname: }
            \c_@@_cmd_type_cuam_tl { \@@_cuam_print_correct_unitphrase: }
%            \c_@@_cmd_type_cucomp_tl { \@@_cunum_print_correct_unit: }
          }
          { \@@_create_internal_error:nN { print-unit-acc } \l_@@_cmd_type_tl }
      }
  }
%    \end{macrocode}
% Prints the unit in case of error. Make sure the unit is printed correctly
% with the correct spacing. If the unit is unknown, just print the input.
%    \begin{macrocode}
\cs_new:Npn \@@_print_unit_in_case_of_error:
  {
    \tl_if_empty:NF \l_@@_phantom_tl { \phantom { \l_@@_phantom_tl } }
    \tl_use:N \l_@@_value_unit_space_tl
    \bool_if:NTF \l_@@_unit_error_bool
      { \l_@@_original_unit_tl }
      { \@@_culang_print:nV { unit-symbol } \l_@@_original_unit_tl }
  }  
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro} { \@@_print_number_accordingly:N }
% Prints the input |#1| according to the used command. 
% This command is
% also used in ranges. 
%    \begin{macrocode}
\cs_new:Npn \@@_print_number_accordingly:N #1
  {
    \tl_case:NnF \l_@@_cmd_type_tl
      {
        \c_@@_cmd_type_cunum_tl { \@@_print_numerical_input:N #1 }
        \c_@@_cmd_type_cCutext_tl { \@@_cutext_print_input:N #1 }
        \c_@@_cmd_type_cuam_tl { \@@_cuam_print_numerical_input:N #1 }
      }
      { \@@_create_internal_error:nN { print-input-acc } \l_@@_cmd_type_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_print_range_accordingly:NN , \@@_print_range_sign: }
% Prints ranges. It simply prints the numbers twice, inbetween a range sign.
%    \begin{macrocode}
\cs_new:Npn \@@_print_range_accordingly:NN #1#2
  {
    \@@_print_number_accordingly:N #1
    \@@_print_range_sign:
    \@@_print_number_accordingly:N #2
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_print_range_sign:
  {
   \@@_if_cmd_type_equal:nTF { cunum }
     { \tl_use:N \l_@@_cunum_range_sign_tl }
     {
        \bool_lazy_or:nnTF
          { \@@_if_cmd_type_equal_p:n { cCutext } }
          { \l_@@_lokal_numeral_bool }
          {
            \bool_set_false:N \l_@@_cutext_uppercase_word_bool
            \tl_if_empty:NTF \l_@@_cutext_range_sign_tl
              { \@@_culang_print:nn { name } { cutext-range-sign } }
              { \tl_use:N \l_@@_cutext_range_sign_tl }
          }
          { \tl_use:N \l_@@_cunum_range_sign_tl }
     }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_post_process_accordingly:NN }
% After evaluating and changing the amounts (due to unit changing, rounding, etc.)
% we post process the input (only for numbers and ranges). For |\cunum| nothing
% needs to be done. For \cCutext\ and |\cuam| we post process the values accordingly
% (checking if integer, etc.)
%    \begin{macrocode}
\cs_new:Npn \@@_post_process_accordingly:NN #1#2
  {
    \tl_case:NnF \l_@@_cmd_type_tl
      {
        \c_@@_cmd_type_cunum_tl { }
        \c_@@_cmd_type_cCutext_tl { \@@_cutext_post_process_input:NN #1#2 }
        \c_@@_cmd_type_cuam_tl { \@@_cuam_post_process_input:NN #1#2 }
%        \c_@@_cmd_type_cucomp_tl { }
      }{ 
        \@@_create_internal_error:nN { post-process } \l_@@_cmd_type_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_print_numerical_input:N }
%   The base printing command for numbers. Makes sure the minus sign
%  and decimal-mark are correct.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_print_numerical_input:N #1
  {
    \tl_if_in:NnT #1 { . }
      {
        \@@_culang_let:nnN { name } { decimal-mark } \l_@@_translation_tmpa_tl
        \tl_replace_once:Nnn #1 { . } { \l_@@_translation_tmpa_tl }
      }
    \tl_replace_once:Nnn #1 { - } \c_@@_minus_tl
    #1
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_print_fractions:Nnn }
%   The name of this function is the name of the game: It prints fractions.
%   The minus sign is always put in front of the fraction.
%
%   The first argument regards the mixed fraction part. It is either empty
%   or not empty. If empty, do nothing. Else insert and add space.
%
%  The 2nd and 3rd argument are the nominator and denominator, they are
%  used in the fraction command directly.
%
%  All three arguments are currently tl varables, but only the first is a dedicated
%  \enquote{can only take one token}.
%
%  Since v.1.10(alpha) it also prints the minus sign (hopefully correct).
%    \begin{macrocode}
\cs_new:Npn \@@_print_fractions:Nnn #1#2#3
  {
    \bool_if:NT \l_@@_minus_bool { \c_@@_minus_tl }
    \tl_if_empty:NF #1
      { 
        #1 
        \skip_horizontal:N \l_@@_mixed_frac_dim
      }
    \@@_frac:nn {#2} {#3}
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \subsection {Parsing and checking numbers}
%
% This subsection contains macros for splitting and checking the input.
%
% \begin{macro}{\@@_create_error:n, \@@_create_error_and_stop:n , \@@_create_error:nn }
% Create error messages and set case to \enquote{error}.
%    \begin{macrocode}
\cs_new:Npn \@@_create_internal_error:nN #1#2
  {
    \@@_set_case_to:n { error }
    \msg_error:nnnV { cooking-units } { internal-error } {#1} #2 
  }
\cs_new:Npn \@@_create_error:n #1
  {
    \@@_set_case_to:n { error }
    \msg_error:nnV { cooking-units } {#1} \l_@@_original_amount_tl 
  }
\cs_new:Npn \@@_create_error_and_stop:n #1
  {
    \@@_create_error:n {#1}
    \use_none_delimit_by_q_nil:w
  }
\cs_new:Npn \@@_create_error:nn #1#2
  {
    \@@_set_case_to:n { error }
    \msg_error:nnnV { cooking-units } {#1} {#2} \l_@@_original_amount_tl 
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_parse_the_amount:n }
% Does what the name suggests. |#1| is the input given by the user without changes.
% It is then stored in |\l_@@_original_amount_tl| (which can be expanded, etc.).
% Afterwards we rescan the input to remove spaces and make sure \_ and ? have
% correct catcodes (last one can be active; screws some stuff up if it is so).
% Then decides what's supposed to happen next.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_the_amount:n #1
  {
    \@@_expand_amount_input:Nn \l_@@_original_amount_tl {#1}
    \tl_set_rescan:NnV \l_@@_original_amount_tl
      {
        \char_set_catcode_letter:N \_ %
        \char_set_catcode_ignore:N \ %
        \char_set_catcode_other:N ? %
      } \l_@@_original_amount_tl
    \bool_lazy_any:nTF
      {
        { \tl_if_empty_p:N \l_@@_original_amount_tl }
        { \l_@@_pckopt_draft_bool }
      }
      { \@@_prepare_just_print_input: }
      { \@@_split_and_parse_input: }
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_split_and_parse_input: }
% If the weitd option \opt{42} is used, set the state to \enquote{42}.
% Copy the original amount and prepapre to split the input.
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse_input:
  {
    \bool_if:NT \l_@@_pckopt_fourty_two_bool
      { \@@_set_state_to:n { 42 } }
    \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_original_amount_tl
    \@@_prepare_to_split_input:N \l_@@_tmpa_tl
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_prepare_just_print_input: }
% If we decide the input is just to be printed, set it to \enquote{error} 
% (because I am lazy and do not want to create another case to check).
%    \begin{macrocode}
\cs_new:Npn \@@_prepare_just_print_input:
  {
    \@@_set_state_to:n { error }
    \tl_if_empty:NT \l_@@_original_amount_tl
      { \@@_create_error:nn { cooking-units } { empty-amount } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_prepare_to_split_input:N}
% Adapts the state into \enquote{range} or \enquote{fraction} if needed.
% By default it is set to \enquote{number}. Ranges and Fractions are not allowed
% together. Afterwards, split the input. If we encounter an error, we can use
% |\use_none_delimit_by_q_nil:w| during the code to jump to this point.
% This makes bailing out from the command more easy.
%    \begin{macrocode}
\cs_new:Npn \@@_prepare_to_split_input:N #1
  {
    \tl_if_in:NVT #1 \l_@@_input_range_sign_tl
      {
        \tl_replace_once:NVn #1 \l_@@_input_range_sign_tl { \q_@@_range } 
        \@@_set_parse_and_process_type_to:n { range }
      }
    \tl_if_in:NnT #1 { / }
      { 
        \@@_if_parse_and_process_type_equal:nT { range }
          { \@@_create_error_and_stop:n { fraction-not-allowed-with-range } }
        \@@_set_parse_and_process_type_to:n { fraction }
      }
    \@@_split_and_parse:N #1
    \use_none_delimit_by_q_nil:w \q_nil
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_split_and_parse:}
%   Splits the input into fractions or ranges (or numbers).
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse:N #1
  {
    \tl_case:NnF \l_@@_parse_and_process_type_tl
      {
        \c_@@_parse_and_process_type_number_tl { \@@_split_and_parse_number:V }
        \c_@@_parse_and_process_type_range_tl { \@@_split_and_parse_range:V }
        \c_@@_parse_and_process_type_fraction_tl { \@@_split_and_parse_fraction:V }
      } 
      { \@@_create_internal_error:nN { split } \l_@@_parse_and_process_type_tl }
    #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_split_and_parse_number:n }
% Gets the input , parses it and stores it into |\l_@@_number_tmpa_tl|.
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse_number:n #1
  {
    \@@_parse_input_and_safe_in:nN {#1} \l_@@_number_tmpa_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_split_and_parse_range:n , \@@_split_and_parse_range_aux:ww }
% Splits the input along |\q_@@_range|, parses the two parts and that's it.
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse_range:n #1
  {
    \@@_split_and_parse_range_aux:ww #1 \q_stop
  }
\cs_new:Npn \@@_split_and_parse_range_aux:ww #1 \q_@@_range #2 \q_stop
  {
    \@@_parse_input_and_safe_in:nN {#1} \l_@@_number_tmpa_tl
    \@@_parse_input_and_safe_in:nN {#2} \l_@@_number_tmpb_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_split_and_parse_fraction:n , \@@_split_and_parse_fraction_mixed:ww , \@@_split_and_parse_fraction_frac:ww }
% A bit more tricky. We check first if a mixed fraction part exists. If not the function
% get's |\q_nil|. Then we read the nominator and denominator. Inbetween we check
% for errors
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse_fraction:n #1
  {
    \@@_split_and_parse_fraction_mixed:ww  
      #1 \q_stop / \q_recursion_tail _ \q_nil \q_stop
      \q_recursion_stop
  }
%    \end{macrocode}
% Gets the mixed fraction part (if it exists). If |#2| is |\q_nil| the part does not
% exist. |#1| must then be of part |a/b|. 
%
% If |#2| is \emph{not} |\q_nil| it contains the fraction part with |a/b|. 
% Parse the mixed fraction part and store it. Seperate |#2|.
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse_fraction_mixed:ww #1 _ #2 \q_stop
  {
    \quark_if_nil:nTF {#2}
      { 
        \tl_clear:N \l_@@_mixed_fraction_tl
        \@@_split_and_parse_fraction_frac:ww #1 \q_stop 
      }{ 
        \@@_parse_input_and_safe_in:nN {#1} \l_@@_mixed_fraction_tl
        \@@_split_and_parse_fraction_frac:ww #2 \q_stop
      }
  }
%    \end{macrocode}
% Seperates nominator and denominator. If |#2| is equal to |\q_recursion_tail|
% we probably had a construction like |a/b_c|, which is wrong. If so, create an error.
% If everything is correct, parse the input and store it.
%    \begin{macrocode}
\cs_new:Npn \@@_split_and_parse_fraction_frac:ww #1 / #2 \q_stop
  {
    \quark_if_recursion_tail_stop_do:nn {#2} 
      { \@@_create_error:n { fraction-wrong-order } }
    \@@_parse_input_and_safe_in:nN {#1} \l_@@_number_tmpa_tl
    \@@_parse_input_and_safe_in:nN {#2} \l_@@_number_tmpb_tl
    \use_none_delimit_by_q_recursion_stop:w
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{ \@@_split_and_parse_number:V , 
%   \@@_split_and_parse_range:V , \@@_split_and_parse_fraction:V }
% Some variants.
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_split_and_parse_number:n { V }
\cs_generate_variant:Nn \@@_split_and_parse_range:n { V }
\cs_generate_variant:Nn \@@_split_and_parse_fraction:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_input_and_safe_in:nN }
%   Parses through |#1| and makes sure it is correct. This includes checking if there
%  is only one decimal sign and other stuff. The \enquote{correct}
% parsed stuff is stored in |\l_@@_tmpa_tl|. 
%    \begin{macrocode}
\cs_new:Npn \@@_parse_input_and_safe_in:nN #1 #2
  {
    \tl_clear:N \l_@@_tmpa_tl
    \bool_set_false:N \l_@@_check_decimal_bool
    \cs_set_eq:NN \@@_parse:N \@@_start_loop:N 
    \tl_map_function:nN {#1} \@@_parse:N
    \@@_if_state_equal:nF { error }
      { \tl_set_eq:NN #2 \l_@@_tmpa_tl }
  }  
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_start_loop:N }
%   This function seperates the input into two parts with the first
%   part being the first token. This token is checked if or if not
%   it is a sign.  If it is a sign it is put into
%   \lstinline|\l_@@_tmpa_tl|, if not it is checked normally by
%   \lstinline|\@@_parse_input_loop_aux:N|.  \#2 (the other
%   tokens) is then given to \lstinline|\tl_map_function:nN|. This
%   also works if the input only consists of one token with \#2 being
%   empty (hopefully).
%    \begin{macrocode}
\cs_new:Npn \@@_start_loop:N #1 
  {
    \cs_set_eq:NN \@@_parse:N \@@_parse_input_loop_aux:N
    \tl_if_in:NnTF \l_@@_input_value_signs_tl {#1}
      { \tl_put_right:Nn \l_@@_tmpa_tl {#1} }
      { \tl_map_function:nN {#1} \@@_parse:N }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_input_loop_aux:N , \@@_check_which_error:n , \@@_check_repitition:N }
%   Parses the input. It also is more or less (more less then more) copied from
%   \texttt{siunitx}.  Checks if the input consists only of numbers,
%   one decimal-sign and the allowed special input.
%   In other cases, raise an error. Note that the state special-sign
%   can only be set if there is no error.
%  
%    \begin{macrocode}
\cs_new:Npn \@@_parse_input_loop_aux:N #1
  {
    \tl_if_in:NnTF \l_@@_input_digits_tl {#1}
      { \tl_put_right:Nn \l_@@_tmpa_tl {#1} }
      {
        \tl_if_in:NnTF \l_@@_input_decimal_mark_tl {#1}
          { 
            \@@_check_repitition:N \l_@@_check_decimal_bool
            \tl_put_right:Nn \l_@@_tmpa_tl { . }
          }{
            \tl_if_in:NnTF \l_@@_input_allowed_special_signs_tl {#1}
              {
                \@@_if_state_equal:nF { error }
                  { \@@_set_state_to:n { special_sign } }
                \tl_put_right:Nn \l_@@_tmpa_tl {#1}
              }
              { \@@_check_which_error:n {#1} }
          }
      }
  }
%    \end{macrocode}
% The idea behind this error checking is the following:
% At this point I already split the input. This means, a fraction
% is already split into nominator and denominator and as such, all allowed
% |/| in the input are already removed. The same goes for |_| (an error message
% for |_| without |/| would happen before parsing starts). Therefore
% all |/| and |_| in the input \emph{must} (hopefully) be inside a second time.
%    \begin{macrocode}
\cs_new:Npn \@@_check_which_error:n #1
  {
    \tl_if_in:NnTF \l_@@_input_fraction_sign_tl {#1}
      { \@@_create_error:n { Second-fraction-sign-not-allowed } }
      {
        \tl_if_in:NnTF \l_@@_input_mixed_fraction_sign_tl {#1}
          { 
            \@@_if_parse_and_process_type_equal:nTF { fraction }
              { \@@_create_error:n { Second-mixed-fraction-sign-not-allowed } }
              { \@@_create_error:n { missing-slash } }
          }
          { \@@_create_error:nn { Token-not-allowed } {#1} }
      }
  }
%    \end{macrocode}
%  Back then this contained more checks, but now it just checks
%  if we have a second error decimal sign.
%    \begin{macrocode}
\cs_new:Npn \@@_check_repitition:N #1
  {
    \bool_if:NTF #1
      { \@@_create_error:n { Second-decimal-sign-not-allowed } }
      { \bool_set_true:N #1 }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsection {Formatiere \& Calculiere}
%
%
%
%
% \begin{macro}{ \@@_calculate_and_store_in:N }
%   
%   \changes {v0.98a} {2016/06/11} {Added warning to show if an unknown value is used.}
%   
%  The main calculation command. The split amount is given to this
%  command. It is seperated into several smaller macros. Unit-changing
%  the amount, referencing, rounding and temperature checks are done
%  here. Note that we are only here if the state is \enquote{normal}.
%    \begin{macrocode}
\cs_new:Npn \@@_calculate_and_store_in:N #1
  {
    \@@_calculate_input_and_store_in:N #1
    \@@_calc_references_and_store_in:N #1
    \@@_round_calculated_input_and_store_in:N #1
    \@@_check_temperature_limit:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_calculate_input_and_store_in:NN }
% Well \dots\ this function calculates the input. 
%  First check if the units need to be changes at all (if no unit change
%  is wanted, |\l_@@_option_unit_tl| is set to |\l_@@_original_unit_tl| at the
%  beginning. If we are in one case were no unit change is happening
%  (\enquote{special-sign}, \enquote{error}, \enquote{fraction}) we wouldn't be
%  here in the first place, so need to worry about this.
%
%  As the input is parsed and good for evaluation, store it in
%  |\l_@@_tmpa_fp|.
%
%  If the key definition contained a |#1| (aka, is a single key), 
%  it was replaced by |\l_@@_tmpa_fp|.
%  Thus simply evaluate the tl if one or more |\l_@@_tmpa_fp| are inside.
%
%  If no |\l_@@_tmpa_fp| is found, we have a simple multiplication with the
%  current amount.
%    \begin{macrocode}
\cs_new:Npn \@@_calculate_input_and_store_in:N #1
  {
    \tl_if_eq:NNF \l_@@_decided_unit_tl \l_@@_original_unit_tl
      {
        \fp_set:Nn \l_@@_tmpa_fp {#1}
        \tl_if_in:cnTF { l_@@_unit_change_ \l_@@_original_unit_tl _tl } { \l_@@_tmpa_fp }
          { 
            \@@_tl_eval:Nv #1 { l_@@_unit_change_ \l_@@_original_unit_tl _tl }
          }{ 
            \@@_tl_eval:Nn #1 
              { \l_@@_tmpa_fp * \tl_use:c { l_@@_unit_change_ \l_@@_original_unit_tl _tl }  }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_calc_references_and_store_in:N,\@@_calc_references_and_store_in_aux:N }
% All necessary checks were already done at the beginning.
%  so we know that a reference was given and that the wanted number of
%  persons is different then the one given by |\culabel|. Before
%  evaluation, check if the unit is one of those that cannot be changed.
%    \begin{macrocode}
\cs_new:Npn \@@_calc_references_and_store_in:N #1
  {
    \bool_if:NT \l_@@_lokal_recalc_for_people_bool
      { 
        \seq_if_in:NVTF \l_@@_curef_do_not_change_seq \l_@@_decided_unit_tl
          { \msg_error:nnV { cooking-units } { curef-forbidden-unit } \l_@@_decided_unit_tl }
          { \@@_calc_references_and_store_in_aux:N #1 }
      }
  }
%    \end{macrocode}
% Just calculate the stuff
%    \begin{macrocode}
\cs_new:Npn \@@_calc_references_and_store_in_aux:N #1
  {
    \@@_tl_eval:Nn #1
      {
        #1 *
        \l_@@_wanted_number_of_persons_int /  
        \l_@@_local_number_of_persons_int 
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_round_calculated_input_and_store_in:Nn,\@@_round_calculated_input_and_store_in:NV }
%   After calculation, the numbers are rounded (if needed). 
%  If the rounding precision is negative (can be), just set the bool to true and go
%  to the rounding function.
%  Else check if the number needs rounding at all.
%  Afterwards, round if necessary
%    \begin{macrocode}
\cs_new:Npn \@@_round_calculated_input_and_store_in:N #1
  {
    \bool_if:NTF \l_@@_pckopt_round_precision_negative_bool
      { \bool_set_true:N \l_@@_round_number_bool }
      { \@@_check_number_for_rounding:V #1 }
    \bool_if:NT \l_@@_round_number_bool
      { \@@_tl_eval:Nn #1 { round ( \@@_rounding_function:n {#1} ) } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_check_number_for_rounding:n,\@@_check_number_after_dot_aux:ww}
%   Check if rounding is needed. The auxilary function splits the number into
%   the integer and non-integer part ($12.45$ to $12$ and $45$). 
%
%  Set |\l_@@_round_number_bool| to |false| in case of no decimal places found.    
%
%  If the rounding precision is positive, use the helper function to split the
%  amount.  
%    \begin{macrocode}
\cs_new:Npn \@@_check_number_for_rounding:n #1
  {
    \bool_set_false:N \l_@@_round_number_bool
    \@@_check_number_after_dot_aux:ww #1 . \q_recursion_tail .
    \q_recursion_stop
  }
\cs_generate_variant:Nn \@@_check_number_for_rounding:n { V }
%    \end{macrocode}
%  The function splitting the amount. So $a.b$ is split into $a$ and $b$.
%  If $b$ does not exist (so the amount is an integer), no rounding is needed.
%  If $b$ does exist, count how many tokens it conists of (e.g.\ $12$ = 2 tokens;
%  $1755$ = 4 tokens). If the number of tokens is larger then the wanted round precision,
%  round the input. 
%    \begin{macrocode}
\cs_new:Npn \@@_check_number_after_dot_aux:ww #1 . #2 .
  {
    \quark_if_recursion_tail_stop:n {#2}
    \int_compare:nNnT
      { \tl_count:n {#2} } >
      { \l_@@_round_precision_int }
      { \bool_set_true:N  \l_@@_round_number_bool }
    \use_none_delimit_by_q_recursion_stop:w
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
% \begin{macro}{\@@_check_temperature_limit:N}
%   If \lstinline|check_temperature_bool| is set to true it  now checks
%   if the value is below the absolute temperature. Maybe this should be done
%  before rounding?
%    \begin{macrocode}
\cs_new:Npn \@@_check_temperature_limit:N #1
  {
    \bool_if:NT \l_@@_pckopt_check_temperature_bool
      {
        \seq_if_in:NVT \l_@@_temperatures_to_check_seq \l_@@_decided_unit_tl
          { 
            \fp_compare:vNnT 
              { l_@@_ \l_@@_decided_unit_tl _min_fp } > {#1}
              {
                \msg_error:nnxx { cooking-units } 
                  { Temperature-too-low } 
                  { #1 \space \l_@@_decided_unit_tl } 
                  {  
                    \fp_use:c { l_@@_ \l_@@_decided_unit_tl _min_fp } 
                    \space \l_@@_decided_unit_tl 
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
%
% \subsection {Main commands helper}
%
% \begin{macro}{ \@@_if_arrow_grab_until_close_do:nnTF , 
%    \@@_grab_arrows_for_safety_do_afterwards:nN }
%  I really do not like this constuction, but due to catcodes it can happen
%  that the main commands are unable to get the first command inside <>.
%  In order to fix this, I use this bloody construction.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_if_arrow_grab_until_close_do:nnTF #1#2#3#4
  {
    \str_if_eq:nnTF {#1} { < }
      {
        \tl_if_in:NoT \l_@@_input_allowed_special_signs_tl { < }
          { \msg_error:nn { cooking-units } { <-not-allowed-as-special-sign } }
        \tl_clear:N \l_@@_tmpa_tl
        \tl_put_right:Nx \l_@@_tmpa_tl { \tl_to_str:N < }
        \@@_grab_arrows_for_safety_do_afterwards:nN {#3} #2
      }
      {#4}
  }
\cs_new_nopar:Npn \@@_grab_arrows_for_safety_do_afterwards:nN #1#2
  {
    \str_if_eq:nnTF {#2} { > }
      {
        \tl_put_right:Nx \l_@@_tmpa_tl { \tl_to_str:N > }
        \exp_last_unbraced:NV #1 \l_@@_tmpa_tl
      }{
        \tl_put_right:Nn \l_@@_tmpa_tl {#2}
        \@@_grab_arrows_for_safety_do_afterwards:nN {#1} 
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection {\mycs{cunum}}
%
%
% \begin{macro}{ \cunum }
% The main command of this package. 
%    \begin{macrocode}
\NewDocumentCommand \cunum { d<> O{} m O{} m }
  {
    \@@_if_arrow_grab_until_close_do:nnTF {#3} {#5}
      { \cunum }
      { 
        \group_begin:
        \@@_cunum:nnnnn {#1} {#2} {#3} {#4} {#5}
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_cunum:nnnnn }
%  The \enquote{helper} command. It essentially only sets
%  the command type to \enquote{cunum} and calls the command that does
%  everything else.
%    \begin{macrocode}
\cs_new:Npn \@@_cunum:nnnnn #1#2#3#4#5
  {
    \@@_set_cmd_type_to:n { cunum }
    \@@_do_the_stuff:nnnnnn {#1} {#2} {#3} {#4} {#5} { }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_cunum_print_correct_unit: }
%   The invisible space is added by a \lstinline|\phantom|, afterwards
%   \lstinline|value_unit_space_tl| is used (which is set to
%   \lstinline|\thinspace| by default) and if either special signs or
%   fractions are parsed the input-unit is printed else the converted
%   unit is.
%    \begin{macrocode}
\cs_new:Npn \@@_cunum_print_correct_unit:
  {
    \tl_if_empty:NF \l_@@_phantom_tl { \phantom { \l_@@_phantom_tl } }
    \tl_use:N \l_@@_value_unit_space_tl
    \@@_culang_print:nV { unit-symbol } \l_@@_decided_unit_tl
  }
%    \end{macrocode}
% \end{macro}
%
%
% \section { cutext \& Cutext }
%
%
% \begin{macro}{\cutext}
%  The other main command It is essentially similar to \mycs{cunum},
%  only that we also need to take care of uppercasing the word if necessary
%  (which it is not for this command).
%    \begin{macrocode}
\NewDocumentCommand \cutext { d<> O{} m m }
  {
    \@@_if_arrow_grab_until_close_do:nnTF {#3} {#4}
      { \cutext }
      { 
        \group_begin:
        \bool_set_false:N \l_@@_cutext_uppercase_word_bool
        \@@_cutext:nnnn {#1} {#2} {#3} {#4}
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Cutext}
%  Here we do need the uppercasing.
%    \begin{macrocode}
\NewDocumentCommand \Cutext { d<> O{} m m }
  {
    \@@_if_arrow_grab_until_close_do:nnTF {#3} {#4}
      { \Cutext }
      { 
        \group_begin:
        \bool_set_true:N \l_@@_cutext_uppercase_word_bool
        \@@_cutext:nnnn {#1} {#2} {#3} {#4}
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_cutext:nnnn }
%  Same as the \mycs{cunum} equivalent, just setting the command to 
%  \enquote{cCutext}.
%    \begin{macrocode}
\cs_new:Npn \@@_cutext:nnnn #1#2#3#4
  {
    \@@_set_cmd_type_to:n { cCutext }
    \@@_do_the_stuff:nnnnnn {#1} {#2} {#3} { } {#4} { }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro} {\@@_cutext_print_input:N , \@@_cutext_print_input_aux:Nn , \@@_cutext_print_input_aux:NV }
% \changes {2016/06/11} {0.99} {New.}
%
%  This prints the amount for the \enquote{cCutext} commands. 
%  At first, check if a numeral should be used (\enquote{1} to \enquote{one}, etc.).
%  If not, just print the number. If a numeral should be used, make sure the correct
%  unit is used and go to the next command.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cutext_print_input:N #1
  {
    \bool_if:NTF \l_@@_lokal_numeral_bool
      {
        \@@_cutext_print_input_aux:NV #1 \l_@@_decided_unit_tl
      }
      { \@@_print_numerical_input:N #1 }
  }
%    \end{macrocode}
% If a numeral is used, make sure the correct one is printed.
% If the amount is equal to \enquote{1}, get the gender correct \enquote{one}.
% Else, print the numeral either in upperacse of lowercase.
%
% As we could be in a range, we cannot check via a bool if |#1| is 1.
%
% Furthermore, make sure the translation of \enquote{1} exists. If not,
% set input it set to \enquote{1}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cutext_print_input_aux:Nn #1#2
  {
    \int_compare:nNnTF {#1} = { 1 }
      {
        \@@_culang_one_let:NnT \l_@@_translation_tmpa_tl {#2}
          {
            \bool_if:NT \l_@@_cutext_uppercase_word_bool
              {
                \text_uppercase:x { \tl_head:V \l_@@_translation_tmpa_tl }
                \tl_tail:V 
              }
          }
        \l_@@_translation_tmpa_tl
      }{
        \bool_if:NTF \l_@@_cutext_uppercase_word_bool
          { \@@_print_Numeral:V #1 }
          { \@@_print_numeral:V #1 }
      }
  }
\cs_generate_variant:Nn \@@_cutext_print_input_aux:Nn { NV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_cutext_print_correct_unitname:}
%  As the name suggests, it prints the unitname. At this point we already
%  know that a translation exists, so no bother checking again.
%    \begin{macrocode}
\cs_new:Npn \@@_cutext_print_correct_unitname:
  {
    \bool_if:NTF \l_@@_lokal_numeral_bool
      { \l_@@_cutext_numeral_space_tl }
      { \l_@@_cutext_space_tl }
    \bool_if:NTF \l_@@_cutext_last_amount_equ_one_bool
      { \@@_culang_print:nV { name } \l_@@_decided_unit_tl }
      { \@@_culang_print:nV { name-pl }  \l_@@_decided_unit_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_cutext_check_if_translation_available: }
% Checks if a unitname of the current unit exists. If yes, continue.
% here we can also decide if the unit should be kept the same or not
% as we know that we stay in \enquote{cCutext}.
% If not, change the command to \enquote{cunum}.
%    \begin{macrocode}
\cs_new:Npn \@@_cutext_check_if_translation_available:
  {
    \bool_if:NTF \l_@@_pckopt_cutext_keep_unit_bool
      { \tl_set_eq:NN \l_@@_curr_unit_tl \l_@@_original_unit_tl }
      { \tl_set_eq:NN \l_@@_curr_unit_tl \l_@@_decided_unit_tl }
    \@@_culang_unitname_let:NVTF \l_@@_scrap_tl \l_@@_curr_unit_tl
      {
        \bool_if:NT \l_@@_pckopt_cutext_keep_unit_bool
          { 
            \tl_set_eq:NN \l_@@_decided_unit_tl \l_@@_original_unit_tl 
            \tl_set_eq:NN \l_@@_option_unit_tl \l_@@_original_unit_tl
          }
      }{
        \msg_warning:nnx 
          { cooking-units } 
          { cutext-no-translation-available } 
          \l_@@_curr_unit_tl
        \@@_set_cmd_type_to:n { cunum }
        \@@_decide_unit:
      }
  }
% \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{ \@@_cutext_post_process_input:NN }
% |#1| is always a number, |#2| only is valid if we have a range.
% For later, check if either |#1| or |#2| is equal to one.
%
% Then (Than?) check if a numeral is requested. If yes, |#1| (and if range also |#2|)
% need to be integers. If they are not, numerals cannot be used. If one or both
% are integers, if they are below |\l_@@_print_numerals_below_int|.
%    \begin{macrocode}
\cs_new:Npn \@@_cutext_post_process_input:NN #1#2
  {
    \@@_if_parse_and_process_type_equal:nTF { range }
      { \@@_cutext_check_if_amount_single:N #2 }
      { \@@_cutext_check_if_amount_single:N #1 }
    \bool_if:NT \l_@@_lokal_numeral_bool
      { 
        \@@_if_contain_decimals:NNTF #1#2
          { \bool_set_false:N \l_@@_lokal_numeral_bool }
          { \@@_check_if_integer_can_be_numerals:NN #1#2 }
      }
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro} { \@@_cutext_check_if_amount_single:N }
% Check if the input is equal to |#1|. Use fp as it is not necessary an integer.
% Set the boolean according to the result.
%    \begin{macrocode}
\cs_new:Npn \@@_cutext_check_if_amount_single:N #1
  {
    \fp_compare:nNnTF {#1} = { 1.0 }
      { \bool_set_true:N  } { \bool_set_false:N }
    \l_@@_cutext_last_amount_equ_one_bool
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro} { \@@_check_if_integer_can_be_numerals:NN }
% At this point we know that we have integers, so check if they are
% below |\l_@@_print_numerals_below_int|. If they are, fine. Else,
% set the boolean to false.
%    \begin{macrocode}
\cs_new:Npn \@@_check_if_integer_can_be_numerals:NN #1#2
  {
    \@@_if_parse_and_process_type_equal:nTF { range }
      {
        \bool_lazy_all:nF
          {
            { \int_compare_p:nNn {#1} < { \l_@@_print_numerals_below_int } }
            { \int_compare_p:nNn {#2} < { \l_@@_print_numerals_below_int } }
            { \int_compare_p:nNn {#1} > { 0 } }
            { \int_compare_p:nNn {#2} > { 0 } }
          }
          { \bool_set_false:N \l_@@_lokal_numeral_bool }
      }{
        \bool_lazy_and:nnF
          { \int_compare_p:nNn {#1} < { \l_@@_print_numerals_below_int } }
          { \int_compare_p:nNn {#1} > { 0 } }
          { \bool_set_false:N \l_@@_lokal_numeral_bool }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
% \section{cuam}
%
% \begin{macro}{ \c_@@_no_unit_marker_tl , \@@_if_no_unit_marker:NTF }
% A marker used for \mycs{cuam}. It essentially tells that no unit is used.
% Define some commands to avoid some errors and add it to the unit list.
%    \begin{macrocode}
\tl_const:Nx \c_@@_no_unit_marker_tl { \@@_to_unit:n { @@_no_unit } }
\prg_new_conditional:Npnn \@@_if_no_unit_marker:N #1 { TF , F }
  {
    \tl_if_eq:NNTF \c_@@_no_unit_marker_tl #1
      { \prg_return_true: }
      { \prg_return_false: }
  }
\seq_gput_right:NV \g_@@_list_of_defined_units_seq \c_@@_no_unit_marker_tl
\tl_new:c { l_@@_unit_change_ \c_@@_no_unit_marker_tl _tl }
\tl_set:cn { l_@@_unit_change_ \c_@@_no_unit_marker_tl _tl } { 1.0 }
\clist_new:c { l_@@_unit_option_ \c_@@_no_unit_marker_tl _clist }
%    \end{macrocode}
%
% \begin{macro}{\cuam}
% Replaces and extends \mycs{cufrac}. Essentially the same as the other commands.
%    \begin{macrocode}
\NewDocumentCommand \cuam { d<> O{} m }
  {
    \@@_if_arrow_grab_until_close_do:nnTF {#3} { }
      { \cuam }
      { 
        \group_begin:
        \@@_cuam:nnn {#1} {#2} {#3}
        \group_end:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_cuam:nnn}
% Nothing really special happening here. Use |\c_@@_no_unit_marker_tl|
% to tell the internal thing that we have a valid no-unit-exists case.
%    \begin{macrocode}
\cs_new:Npn \@@_cuam:nnn #1#2#3
  {
    \@@_set_cmd_type_to:n { cuam }
    \@@_do_the_stuff:nnnnVn {#1} {#2} {#3} { } \c_@@_no_unit_marker_tl { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_cuam_post_process_input}
%
%
% Just a helper macro to tidy up the main macro.  The first thing to
% do is to check if the nummerical input consits of integers. This
% is done both both numerical values (if a range exists).
% Afterwards check if phrases are used and can be used at all. This needs
% to be done before the numeral check as it can change the input.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cuam_post_process_input:NN #1#2
  {
    \@@_if_contain_decimals:NNTF #1#2
      { \bool_set_false:N \l_@@_lokal_numeral_bool }
      {
        \bool_if:NT \l_@@_pckopt_use_phrases_bool
          { \@@_cuam_post_process_input_phrases:NN #1#2 }
        \bool_if:NT \l_@@_lokal_numeral_bool
          { \@@_check_if_integer_can_be_numerals:NN #1#2 }
      }
  }
%    \end{macrocode}
% \end{macro}
%\begin{macro}{ \@@_cuam_post_process_input_phrases:NN}
%
% I really do not like this command, but I still do not have a bette idea
% how to handle the whole thing.
% 
% Does a list of phrases exist
% for the current language? If yes, parse the input and check if phrases are used.
% It is important for ranges to check both values and then decide if phrases
% are used or not.
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_post_process_input_phrases:NN #1#2
  {
    \@@_culang_let:nnN { phrase } { phrase-prop } \l_@@_phrase_prop
    \tl_if_eq:NNT \q_@@_no_translation \l_@@_phrase_prop
      { \use_none_delimit_by_q_stop:w }
    \prop_get:NnN \l_@@_phrase_prop { seq } \l_@@_phrase_numbers_seq
%  
    \@@_cuam_post_process_input_phrases_aux:NNN 
      #1 \l_@@_tmpa_int \l_@@_phrase_number_tl
    \bool_if:NF \l_@@_lokal_phrase_bool
      { \use_none_delimit_by_q_stop:w }
%        
    \@@_if_parse_and_process_type_equal:nTF { range }
      {
        \bool_if:NT \l_@@_phrase_negative_bool
          { \use_none_delimit_by_q_stop:w }
        \@@_cuam_post_process_input_phrases_range:NN
          #2 \l_@@_tmpb_int
        \bool_if:NF \l_@@_lokal_phrase_bool
          { \use_none_delimit_by_q_stop:w }
        \tl_set:NV #1 \l_@@_tmpa_int
        \tl_set:NV #2 \l_@@_tmpb_int
        \@@_cuam_get_phrase_name:NVN 
          \l_@@_phrase_text_tl \l_@@_phrase_number_tl #2
      }{ 
        \tl_set:NV #1 \l_@@_tmpa_int 
        \@@_cuam_get_phrase_name:NVN 
          \l_@@_phrase_text_tl \l_@@_phrase_number_tl #1
      }
     \use_none_delimit_by_q_stop:w \q_stop
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_post_process_input_phrases_aux:NNN #1#2#3
  {
    \bool_set_false:N \l_@@_lokal_phrase_bool
    \seq_map_inline:Nn \l_@@_phrase_numbers_seq
      {
        \int_compare:nNnF { \int_abs:n {##1} } > {#1}
          {
            \prop_get:NnN \l_@@_phrase_prop { ##1-singlebool } \l_tmpa_tl
            \int_compare:nNnTF { \l_tmpa_tl } = { 1 }
              { \bool_set_true:N \l_@@_phrase_negative_bool }
              { 
                \bool_set_false:N \l_@@_phrase_negative_bool
                \tl_set:Nf \l_tmpa_tl { \int_div_truncate:nn {#1} {##1} } 
              }
            \int_compare:nNnT { \int_abs:n {##1} * \l_tmpa_tl } = {#1}
              {
                \tl_set_eq:NN #2 \l_tmpa_tl
                \tl_set:Nf #3 { \int_abs:n {##1} }
                \bool_set_true:N \l_@@_lokal_phrase_bool
                \seq_map_break:
              }
          }
      }
  }
\cs_new:Npn \@@_cuam_post_process_input_phrases_range:NN #1#2
  {
    \int_set:Nn \l_tmpa_int 
      { 
        \int_div_truncate:nn {#1} { \l_@@_phrase_number_tl } 
      }
    \int_compare:nNnTF { \l_@@_phrase_number_tl * \l_tmpa_int } = {#1}
      {
        \int_set_eq:NN #2 \l_tmpa_int
        \bool_set_true:N \l_@@_lokal_phrase_bool
      }{
        \bool_set_false:N \l_@@_lokal_phrase_bool
      }
  }
\cs_new:Npn \@@_cuam_get_phrase_name:NnN #1#2#3
  {
    \int_compare:nNnTF {#3} = { 1 }
      { \prop_get:NnN \l_@@_phrase_prop {#2} #1 }
      { \prop_get:NnN \l_@@_phrase_prop { #2-pl } #1 }
    \prop_get:NnN \l_@@_phrase_prop { #2-gender } \l_@@_phrase_gender_tl
  }
\cs_generate_variant:Nn \@@_cuam_get_phrase_name:NnN { NVN }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_cuam_print_numerical_input:N, \@@_cuam_print_numerical_input_aux:Nn, \@@_cuam_print_numerical_input_aux:NV }
% Printing the numerical input for \mycs{cuam}. If both phrases and numerals
% are requested, go to the helper macro. Else, just print the numerical input.
% We need both to be true or else it can happen that numerals are used
% without anything to follow it up (Instead of \enquote{zwei Dutzend} we simply would
% have \enquote{zwei}). 
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cuam_print_numerical_input:N #1
  {
    \bool_lazy_and:nnTF
      { \l_@@_lokal_phrase_bool } 
      { \l_@@_lokal_numeral_bool }
      {
        \@@_cuam_print_numerical_input_aux:NV #1\l_@@_phrase_number_tl
      }
      { \@@_print_numerical_input:N #1 }
  }
%    \end{macrocode}
% Currently \mycs{cuam} only allows for lowercase numerals.
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_print_numerical_input_aux:Nn #1#2
  {
    \int_compare:nNnTF {#1} = { 1 }
      {
        \@@_culang_one_let_by_gender:NVTF 
          \l_@@_translation_tmpa_tl \l_@@_phrase_gender_tl
          { \l_@@_translation_tmpa_tl  }
          { 
            \@@_print_numeral:V #1
            \bool_set_false:N \l_@@_lokal_numeral_bool
          }
      }
      { \@@_print_numeral:V #1 } 
  }
\cs_generate_variant:Nn \@@_cuam_print_numerical_input_aux:Nn { NV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_cuam_print_correct_unitphrase: }
% THis one is thankfully straightforward.
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_print_correct_unitphrase:
  {
    \bool_if:NT \l_@@_lokal_phrase_bool
      {
        \l_@@_cuphrase_space_tl 
        \l_@@_phrase_text_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{\mycs{cucomp}}
%
%
%    \begin{macrocode}
%\NewDocumentCommand \cucomp { d<> O{}  m m m }
%  {
%    \group_begin:
%      \@@_cucomp:nnnnn {#1} {#2} {#3} {#4} {#5}
%    \group_end:
%  }
%    \end{macrocode}
%    \begin{macrocode}
%\cs_new:Npn \@@_cucomp:nnnnn #1#2 #3#4#5
%  {
%    \group_begin:
%      \@@_set_cmd_type_to:n { cunum }
%      \@@_do_the_stuff:nnnnnn {#1} {#2} {#3} { } {#4} { }
%      /
%      \@@_do_the_stuff:nnnnnn {#1} {#4=#5} {#3} { } {#4} { }
%    \group_end:
%  }
%    \end{macrocode}
%
%    \begin{macrocode}
%\cs_new:Npn \@@_do_cucomp_stuff:nnnnn #1#2 #3#4#5
%  {
%    \group_begin:
%      \@@_set_cmd_to:n { cucomp }
%      \@@_do_the_stuff:nnnnnn {#1} {#2} {#3} { } {#4}
%      \@@_do_the_stuff:nnnnnn {#1} {#2} {#3} { } {#5}
%    \group_end:
%  }
%    \end{macrocode}
%
%    \begin{macrocode}
%\cs_new:Npn \@@_new_process_compare_in_input:
%  {
%    \tl_set_eq:NN \l_@@_number_tmpb_tl \l_@@_number_tmpa_tl
%    \tl_set_eq:NN \l_@@_tmpa_unit_tl \l_@@_option_unit_tl
%    \@@_calculate_and_store_in:N \l_@@_number_tmpa_tl
%    \@@_calculate_and_store_in:N \l_@@_number_tmpb_tl
%    \@@_post_process_accordingly:NN \l_@@_number_tmpa_tl \q_no_value
%  }
%    \end{macrocode}
%
%
%
% \section {cukeys}
%
% \subsection {Define Keys}
%
% \begin{macro}{ }
%   Defining keys.
%    \begin{macrocode}

%% To be deleted. In order to remove error messages.
%\newcommand \cudefinekeys {}
%\newcommand \cudefinesinglekey {}
%\newcommand \cuaddkeys {}
%\newcommand \cuaddsinglekeys {}
%\newcommand \cuaddtokeys {}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{ \cudefinekeys , \cudefinesinglekey }
%  Commands used for defining unit-keys. Their main differences
%  is in setting |\l_@@_single_key_bool| to the respective value
%  and for single-keys to rescan |#2| as it can contain  |#1| in its argument.
%
%  The other stuff is imply a intialization using the unit in |#1| as a base
%  and parsing the rest.
%    \begin{macrocode}
\NewDocumentCommand \cudefinekeys { m m }
  {
    \bool_set_false:N \l_@@_single_key_bool
    \@@_initialice_cukeys_define:n {#1}
    \@@_cukeys_prepare_parsing_keys:nn {#1} {#2}
  }
\NewDocumentCommand \cudefinesinglekey { m m }
  {
    \bool_set_true:N \l_@@_single_key_bool
    \@@_initialice_cukeys_define:n {#1}
    \tl_set_rescan:Nno \l_@@_tmpa_tl
      { \char_set_catcode_letter:N \# } {#2}
    \@@_cukeys_prepare_parsing_keys:nV {#1} \l_@@_tmpa_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_initialice_cukeys_define:n }
%   Using |#1| as the base unit for the following keys we set some variables.
%  |\l_@@_tmpa_seq| will contain the parsed units; |\l_@@_tmpb_seq| the values.
%  We also make sure the unit |#1| is defined, else create an error. 
%  Also of importance is to set |\l_@@_new_key_base_tl| to $1$. This variable
%  is important while adding keys as it sets the base conversion value so to speak.
%    \begin{macrocode}
\cs_new:Npn \@@_initialice_cukeys_define:n #1
  {
    \seq_clear:N \l_@@_tmpa_seq
    \seq_clear:N \l_@@_tmpb_seq
    \prop_clear:N \l_@@_tmpa_prop
    \@@_set_state_to:n { normal }
    \@@_error_if_unit_not_defined:nNT {#1} \l_@@_original_unit_tl
      { \@@_set_state_to:n { error } }
    \tl_set:Nn \l_@@_new_key_base_tl { 1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \newcukeysadd , \newcukeysaddto , \newcusinglekeysadd }
%  Thanks to rewriting the code the |add| commands and the |define|
%  commands share a lot of code. The difference is the initialicing, which is a bit
%  different.
%    \begin{macrocode}
\NewDocumentCommand \cuaddkeys { m m }
  {
    \bool_set_false:N \l_@@_single_key_bool
    \@@_initialice_cukeys_add:n {#1}
    \@@_cukeys_prepare_parsing_keys:nn {#1} {#2}
  }
\NewDocumentCommand \cuaddtokeys { m m m }
  {
    \bool_set_false:N \l_@@_single_key_bool
    \@@_initialice_cukeys_add:n {#1}
    \tl_set:Nn \l_@@_tmpa_tl { {#2} { \fp_eval:n { 1.0 / (#3) } } }
    \@@_cukeys_prepare_parsing_keys:nV {#1} \l_@@_tmpa_tl
  }
\NewDocumentCommand \cuaddsinglekeys { m m }
  {
    \bool_set_true:N \l_@@_single_key_bool
    \@@_initialice_cukeys_add:n {#1}
    \tl_set_rescan:Nno \l_@@_tmpa_tl
      { \char_set_catcode_letter:N \# } {#2}
    \@@_cukeys_prepare_parsing_keys:nV {#1} \l_@@_tmpa_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_initialice_cukeys_add:n }
%  This one is quite different compared to |\@@_initialice_cukeys_define:n| as it
%  needs a bit more stuff to do.
%
%  The beginning is checking if |#1| exists and later if |#1| is a key at all.
%  If it not a key already we cannot add keys, in either case print an error and 
%  go to the end.
%
%  If the checks passed without error we go to the \enquote{retrieving} step.
%  As we are adding (potentially) new keys to existing ones we need to retrive 
%  the values we stored and got during the definition of keys.
%
%  First, get the |\l_@@_original_unit_tl|. This one is the unit given in the first argument
%  of either |\cudefinekeys| or |\cudefinesinglekey|. It is the base unit
%  for those keys. Afterwards retrieve the other values. Get the property list
%  which stores the unit-value pairs, get the list of units we can transform the unit to
%  and -- to make sure -- make sure a single key is only added to a single key and vice versa.
%
% Afterwards, this cs is done.
%    \begin{macrocode}
\cs_new:Npn \@@_initialice_cukeys_add:n #1
  {
    \seq_clear:N \l_@@_tmpa_seq
    \seq_clear:N \l_@@_tmpb_seq
    \@@_set_state_to:n { normal }
    \@@_error_if_unit_not_defined:nNT {#1} \l_@@_curr_unit_tl
      { 
        \@@_set_state_to:n { error } 
        \use_none_delimit_by_q_stop:w
      }
    \@@_if_unit_has_a_key:nF {#1}
      { 
        \msg_error:nnx { cooking-units } { Key-not-defined } \l_@@_curr_unit_tl
        \@@_set_state_to:n { error } 
        \use_none_delimit_by_q_stop:w
      }
    \tl_set_eq:Nc \l_@@_original_unit_tl { l_@@_base_key_unit_ \l_@@_curr_unit_tl _tl }
    \prop_set_eq:Nc \l_@@_tmpa_prop { l_@@_new_cukeys_ \l_@@_original_unit_tl _prop }
    \prop_get:NnN \l_@@_tmpa_prop {#1} \l_@@_new_key_base_tl
    \prop_get:NnN \l_@@_tmpa_prop { Liste } \l_@@_tmpa_seq
    \prop_get:NnN \l_@@_tmpa_prop { single } \l_@@_tmpa_tl
    \int_compare:nNnF { \l_@@_single_key_bool } = { \l_@@_tmpa_tl }
      { 
        \msg_error:nn { cooking-units } { Adding-single-to-multi-key-or-vice-verca } 
        \@@_set_state_to:n { error }
      }
    \use_none_delimit_by_q_stop:w \q_stop
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_cukeys_prepare_parsing_keys:nn }
%  After initialising the variables we go to this command.
%  At first it seperates the input in |#2| into unit-value pairs via |\@@_cukeys_parse_keys|.
%  If no error happened, we go to the definition of keys.
%
%  As we add new keys and potentially change the values of old ones we need
%  to globally clear |\g_@@_master_changer_prop|.
%    \begin{macrocode}
\cs_new:Npn \@@_cukeys_prepare_parsing_keys:nn #1#2
  {
%    %% ToDo: Add keval system?
%    \cudefinekeys { kg }
%      {
%        dag= 100,
%        g= 1000,
%        kg= 1,
%      }
    \@@_cukeys_parse_keys:nn {#1} {#2}
    \@@_if_state_equal:nF { error }
      {
        \prop_gclear:N \g_@@_master_changer_prop
        \@@_cukeys_prepare_lists:N \l_@@_original_unit_tl
        \@@_new_cukeys_create_keys:V \l_@@_original_unit_tl
      }
  }
\cs_generate_variant:Nn \@@_cukeys_prepare_parsing_keys:nn { nV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_cukeys_parse_keys:nn , \@@_cukeys_parse_keys_aux:nn}
%  Seperates the input into key-value pairs. This cs doesn't do much as the main
%  stuff is done in |\@@_cukeys_parse_keys_aux:nn|.
%    \begin{macrocode}
\cs_new:Npn \@@_cukeys_parse_keys:nn #1#2
  {
    \@@_cukeys_parse_keys_aux:nn {#1} { 1.0 } #2
      \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
%    \end{macrocode}
%  
% Note for the beginning:     
% Keys used for definining (#1) are converted into strings!
% No need to keep catcodes. Just string everything!
%
%  This command does a lot. The first is the stopping condition, then two
%  checks for error messages. Either a \enquote{missing-argument} or a \enquote{unit
%  not defined} thingy.
%
%  The value is stored in |\l_@@_tmpb_tl|. Afterwards check if a |##1| is found inside.
%  If it is, replace |##1| by  |\l_@@_tmpa_fp|. So we do not store a command with an
%  argument, but rather a formula with a variable inside, which we can set.
%  If on ther other side it contains a |##1|, but is not a single key, we raise an error.
%
%  Afterwards -- if nor error -- we calculate the value in |\l_@@_tmpb_tl| if we have no
%  single key. Here |\l_@@_new_key_base_tl| comes into play. The idea is the following:
%  the base key is \enquote{kg} with \enquote{1}, furthermore we have the key
%  \enquote{dag} with value \enquote{100}. Now we add \enquote{g} to \enquote{dag}
%  with \enquote{10} ($1$ dag equals 10 g). In order to have the correct relation betwen
%  the base key \enquote{kg} and \enquote{g}, we set |\l_@@_new_key_base_tl| during
%  the initialization to \enquote{100}. Then the relation between \enquote{kg} and
%  \enquote{g} is correct with \enquote{(10)*100=1000}.
%  
%  Add the unit to the list of units; add the unit-value to the propery-list.
%    \begin{macrocode}
\cs_new:Npn \@@_cukeys_parse_keys_aux:nn #1#2
  {
    \quark_if_recursion_tail_stop:n {#1} 
    \quark_if_recursion_tail_stop_do:nn {#2} 
      { 
        \msg_error:nn { cooking-units } { missing-argument } 
        \@@_set_state_to:n { error }
      }
    \@@_error_if_unit_not_defined:nNT {#1} \l_@@_option_unit_tl
      { \@@_set_state_to:n { error } }
%
    \tl_set:Nn \l_@@_tmpb_tl {#2}
    \tl_if_in:NVT \l_@@_tmpb_tl \g_@@_input_str_hash_one_tl 
      { 
        \bool_if:NTF \l_@@_single_key_bool
          { \tl_replace_all:NVn \l_@@_tmpb_tl \g_@@_input_str_hash_one_tl { \l_@@_tmpa_fp } }
          {
            \msg_error:nnx { cooking-units } { formula-in-non-singlekeys } \l_@@_tmpb_tl
            \@@_set_state_to:n { error }
          }
      }
    \@@_if_state_equal:nF { error }
      {
        \bool_if:NF \l_@@_single_key_bool
          { \@@_tl_eval:Nn \l_@@_tmpb_tl { (\l_@@_tmpb_tl) * \l_@@_new_key_base_tl } }
        \seq_if_in:NVF \l_@@_tmpa_seq \l_@@_option_unit_tl
          { \seq_put_right:NV \l_@@_tmpa_seq \l_@@_option_unit_tl }
        \prop_put:NnV \l_@@_tmpa_prop {#1} \l_@@_tmpb_tl
      }
    \@@_cukeys_parse_keys_aux:nn
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_cukeys_prepare_lists:N }
%  At this point we can assume everything to be correct.
%  |#1| the main unit aka.\ the \enquote{original unit} or \enquote{base unit}.
%
%  First we clear/create new the property list which will contains the conversion values for
%  for each unit. There we will safe the the values we collected in the last step,
%  the list of units in this set and if the key is single or not.
%
%  For simplification, each unit in the key-list always points to the \enquote{base unit},
%  so \enquote{g}, \enquote{kg}, \enquote{dag}, etc.\ will all show to \enquote{kg}.
%  This is not needed if we have a single-key (due to how single-keys work).
%  Furhtermore, if no single-key, set the default transformation value to \enquote{1};
%  not sure if the last step is necessary, but eh.
%    \begin{macrocode}
\cs_new:Npn \@@_cukeys_prepare_lists:N #1
  {
    \prop_clear_new:c { l_@@_new_cukeys_ #1 _prop }
    \prop_set_eq:cN { l_@@_new_cukeys_ #1 _prop } \l_@@_tmpa_prop
    \prop_put:cnV { l_@@_new_cukeys_ #1 _prop } { Liste } \l_@@_tmpa_seq
    \prop_put:cnV { l_@@_new_cukeys_ #1 _prop } { single } \l_@@_single_key_bool
    \tl_set:cn { l_@@_unit_change_ #1 _tl } { 1 }
    \tl_set_eq:cN { l_@@_base_key_unit_ #1 _tl } #1
    \bool_if:NF \l_@@_single_key_bool
      {
        \seq_map_inline:Nn \l_@@_tmpa_seq
          {
            \tl_set_eq:cN { l_@@_base_key_unit_ ##1 _tl } #1
            \tl_set:cn { l_@@_unit_change_ ##1 _tl } { 1 }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_cukeys_create_keys:n , \@@_new_cukeys_create_keys:V }
%  Here we start creating the keys. If seperate into two cases: 
%  Do we have a single-key or not. If yes, just create the key |#1|
%  and do what needs to be done. If not, we need to create a bunch of
%  keys for each unit in the list.
%    \begin{macrocode}
\cs_new:Npn \@@_new_cukeys_create_keys:n #1
  {
    %% #1: original_unit
    \clist_set_from_seq:NN \l_@@_tmpa_clist \l_@@_tmpa_seq
    \bool_if:NTF \l_@@_single_key_bool
      { 
        \@@_new_cukeys_define_key:nVn
           {#1} \l_@@_tmpa_clist {#1}
      }{  
        \seq_map_inline:Nn \l_@@_tmpa_seq
          {
            \@@_new_cukeys_define_key:nVn 
               {##1} \l_@@_tmpa_clist {#1}
          }
      }
  }
\cs_generate_variant:Nn \@@_new_cukeys_create_keys:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_cukeys_define_key:nnn , \@@_new_cukeys_define_key:nVn }
%  Now we define some key(s). |#1| is the unit and key-to-be-defined.
%  As |#1| is not expanded, this can contain control sequences, etc. not need for worry
%  here.
%
%  We define the key |#1| with a list of choices |#2| (which is the list of units
%  collected in the parse step). |#3| plays an important role as it is the
%  \enquote{base unit}. We mainly need this to do some shortcuts later on.
%  So instead of getting the the base unit for \enquote{g} \emph{via}
%  |l_@@_base_key_unit_g_tl| (which would be \enquote{kg}), we give \enquote{kg}
%  directly as the argument |#3|. It was made sure that |#3| \emph{not} a
%  control sequence, but text.
%
%  In order to remind the user which choices each key have, define an error
%  message for unknown keys.
%    \begin{macrocode}
\cs_new:Npn \@@_new_cukeys_define_key:nnn #1#2#3
  {
    \@@_if_unit_has_a_key:nF {#1} 
      { \seq_put_right:Nn \l_@@_list_of_defined_keys_seq {#1} }
    \keys_define:nn { cooking-units }
      {
        #1 .choices:nn =
          {#2}
          { \@@_change_unit_from_to:nVn {#1} \l_keys_choice_tl {#3} } ,
        #1 / unknown .code:n= 
          { 
%            %% seq_use:N... as it needs to be expandable
            \seq_set_split:Nnn \l_tmpa_seq { , } {#2}
            \msg_error:nnxxx
              { cooking-units } 
              { key-choice-unknown }
              {#1} 
              {##1} 
              { \@@_seq_use_msg:N \l_tmpa_seq }
          } ,
         #1 .default:n = {#1} ,
         #1 .groups:n = { change-unit }
      }
  }
\cs_generate_variant:Nn \@@_new_cukeys_define_key:nnn { nVn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_change_unit_from_to:nnn }
%  Our main \enquote{get the conversion value} command.
%  |#1| is the current unit, |#2| is the unit it is converted into,
%  |#3| is the \enquote{base unit}, given in order to make some shortcuts.
%
%  |\l_@@_change_unit_prop| stores which unit should be converted into which by
%  a key-value list. If the unit is later used we restore the value from this property list.
%
%  Now to the calculation. |\g_@@_master_changer_prop| stores the the conversion values
%  globally in a | <old-unit> ~->~ <new-unit>| way. If we already have a conversion
%  from |#1| to |#2| we simply restore this value and store it in |l_@@_unit_change_ #1_tl|.
%
%  If the unit-change is requested for the first time we need to calculate the
%  conversion value first. Afterwards, store it (globally) into |\g_@@_master_changer_prop|
%  to not recalculate it in the future.
%    \begin{macrocode}
\cs_new:Npn \@@_change_unit_from_to:nnn #1#2#3
  {
    \prop_put:Nnn \l_@@_change_unit_prop {#1} {#2}
    \prop_get:NncF 
      \g_@@_master_changer_prop 
      { #1 ~->~ #2 }
      { l_@@_unit_change_ #1_tl }
      {
        \@@_cukeys_calculate_change_value:nnn {#1} {#2} {#3}
        \prop_gput:Nnv \g_@@_master_changer_prop 
          { #1 ~->~ #2 } 
          { l_@@_unit_change_ #1 _tl }
      }
  }
\cs_generate_variant:Nn \@@_change_unit_from_to:nnn { nVn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_cukeys_calculate_change_value:nnn }
%  Great, an unit-change is requested for the first time, thus calculate
%  the conversion value.
%
%  First we check if the old unit |#1| is the same as the \enquote{base unit}
%  |#3|. This is a nice shortcut, as the property list is stored with |#3| as a base,
%  so direct retrival of the value is possible in this case.
%
%  If |#1| and |#3| are different, we need to do some work. First, get the list
%  of key-values |l_@@_new_cukeys_ #3 _prop| and store it in |\l_@@_tmpa_prop|.
%  Now eval. 
%
%  Having unit |a| and wanting unit |b|, we need the value to go from |a| to |b|
%  which is done by the realtion $|b|/|a|$. This is checked easily as $|a|*|b|/|a|=|b|$.
%  Replace this by |#1| and |#2| and we get: |#2|=|#1|*|#2|/|#1|, which we
%  evaluate and store in |l_@@_unit_change_ #1 _tl|.
%    \begin{macrocode}
\cs_new:Npn \@@_cukeys_calculate_change_value:nnn #1 #2 #3
  {
    \str_if_eq:nnTF {#1} {#3}
      {
        \prop_get:cnc { l_@@_new_cukeys_ #1 _prop } {#2} { l_@@_unit_change_ #1 _tl }
      }{
        \prop_set_eq:Nc \l_@@_tmpa_prop { l_@@_new_cukeys_ #3 _prop }
        \@@_tl_eval:cn { l_@@_unit_change_ #1 _tl }
          {
            ( \prop_item:Nn \l_@@_tmpa_prop {#2} ) /
            ( \prop_item:Nn \l_@@_tmpa_prop {#1} )
          }
      }
  }
\cs_generate_variant:Nn \@@_cukeys_calculate_change_value:nnn { VVV }
%    \end{macrocode}
% \end{macro}
%
%
% \section {Creating New Units}
%
%
%\begin{macro}{ \declarecookingunit , \newcookingunit , \providecookingunit }
%  Defining new units. Defining an unit is split into two parts: defining
%  the necassary tl's and clist's and seq's; and setting them. Depending on which
%  command is used, things are handled differently.
%
%  We always make sure that the unit |#1| is first converted into a string.
%    \begin{macrocode}
\NewDocumentCommand \declarecookingunit { o m }
  {
    \@@_if_unit_defined:nNTF {#2} \l_@@_original_unit_tl
      { \msg_info:nnx { cooking-units } { redefine-unit } { \l_@@_original_unit_tl } }
      { \@@_new_cooking_unit:V \l_@@_original_unit_tl }
    \@@_set_cooking_unit:nnV {#1} {#2} \l_@@_original_unit_tl
  }
\NewDocumentCommand \newcookingunit { o m }
  {
    \@@_if_unit_defined:nNTF {#2} \l_@@_original_unit_tl
      { \msg_error:nnV { cooking-units } { unit-already-defined } \l_@@_original_unit_tl }
      { 
        \@@_new_cooking_unit:V \l_@@_original_unit_tl 
        \@@_set_cooking_unit:nnV {#1} {#2} \l_@@_original_unit_tl
      }
  }
\NewDocumentCommand \providecookingunit { o m }
  {
    \@@_if_unit_defined:nNT {#2} \l_@@_original_unit_tl
      {
        \@@_new_cooking_unit:V \l_@@_original_unit_tl 
        \@@_set_cooking_unit:nnV {#1} {#2} \l_@@_original_unit_tl
      }
  }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{ \@@_new_cooking_unit:n }
%  Creates the token and other lists for the unit |#1| (which at this point is a string).
%  Nothing really expectional here.
%    \begin{macrocode}
\cs_new:Npn \@@_new_cooking_unit:n #1
  {
    \tl_map_inline:nn {#1}
      {
        \tl_if_in:NnT \l_@@_unit_letter_not_allowed_tl {##1}
          { \msg_error:nnn { cooking-units } { character-not-allowed } {#1} }
      }
    \seq_gput_right:Nn \g_@@_list_of_defined_units_seq {#1}
    \tl_new:c { l_@@_unit_change_ #1 _tl }
    \tl_new:c { l_@@_base_key_unit_ #1 _tl }
    \tl_new:c { l_@@_default_unit_ #1 _tl }
    \clist_new:c { l_@@_unit_option_ #1 _clist } 
    \tl_set:cn { l_@@_unit_change_ #1 _tl } { 1 }
    \keys_define:nn { cooking-units }
      {
        set-unit-hook-#1 .code:n =  { \@@_set_options_for:nn {#1} {##1} } ,
        add-unit-hook-#1 .code:n = { \@@_add_options_for:nn {#1} {##1} },
        set-option-for-#1 .meta:n = { set-unit-hook-#1 = {##1} } ,
        add-option-for-#1 .meta:n = { add-unit-hook-#1 = {##1} } ,
      }
  }
\cs_generate_variant:Nn \@@_new_cooking_unit:n { V }
%    \end{macrocode}
%  \end{macro}
%
%\begin{macro}{ \@@_set_cooking_unit:nnn , \@@_set_cooking_unit:nnV }
%  Here we set the in the last step defined lists to their respective value.
%  |#3| is the unit-string; |#2| is the unit given by the user (as it can be a command
%  like |/%]; |#1| is either the wanted unit-symbol \emph{or} a key-val
%  list. Depending on that, we either set the printed symbol to |#1| or parse the
%  key-val list. 
%
%  This is done in a three step procedure (if |#1| is a value): First, check if
%  the head of |#1| is a group. This happens if the user embraces |#1| in two 
%  curly brace pairs (e.g.\ |{{Test}}|). This is only needed if the user really wants
%  the symbol to contain |=|.
%
%  If |#1| is not protected by braces it is parsed as key(s)
%    \begin{macrocode}
\cs_new:Npn \@@_set_cooking_unit:nnn #1#2#3
  {
    \@@_set_cooking_unit_base_translation:n {#3}
    \bool_set_false:N \l_@@_symbol_was_set_by_key_bool
    \bool_set_false:N \l_@@_contains_valid_key_bool
    \IfNoValueF {#1}
      { 
        \tl_if_head_is_group:nF {#1}
          { \keys_set:nn { cooking-units / definition } {#1} }
      }
    \bool_if:NF \l_@@_symbol_was_set_by_key_bool
      {
        \IfNoValueTF {#1}
          { \tl_set:cn { l_@@_default_unit_ #3 _tl } {#2} }
          {
            \bool_if:NTF \l_@@_contains_valid_key_bool
              { \tl_set:cn { l_@@_default_unit_ #3 _tl } {#2} }
              { \tl_set:cn { l_@@_default_unit_ #3 _tl } {#1} }
          }
      }
    \@@_culang_def_base:nnv { unit-symbol } {#3} { l_@@_default_unit_ #3 _tl }
  }
\cs_generate_variant:Nn \@@_set_cooking_unit:nnn { nnV }
%    \end{macrocode}
%  \end{macro}
%
%\begin{macro}{ \@@_set_cooking_unit_base_translation:n }
%  Just an auxilary command. Sets the base translations to their default value.
%    \begin{macrocode}
\cs_new:Npn \@@_set_cooking_unit_base_translation:n #1
  {
    \@@_culang_def_base:nnn { name } {#1} \q_@@_no_translation
    \@@_culang_def_base:nnn { name-pl } {#1} \q_@@_no_translation
    \@@_culang_def_base:nnn { gender } {#1} { m }
  }
%    \end{macrocode}
%  \end{macro}
% 
%
%
% \begin{macro}{\declarecookingderivatives}
% Now this is an experimental command. The idea is simple: Combine units
% (like meter and second giving meter per second or in any way possible).
% The first argument contains a list of the units that should be connected, one of every type is enough.
% Second is the unit-key, containing |#1|, \dots\ |#(number of units in first argument)|. 
% Third is the calculation. The formula for the new unit should be written in here.
% And last, but not least: The last argument contains the unit-symbol.
%
% Now this command simply defines a bunch of units, declaring them makes things easier.
%    \begin{macrocode}
\NewDocumentCommand \declarecookingderivatives { m m m m }
  {
    \@@_declare_cooking_derivative:nnnn {#1} {#2} {#3} {#4}
  }
%    \end{macrocode}
% \end{macro}
% 
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
% This command has the following parts:
% \begin{enumerate}
%   \item Get list of units in |#1|, check if they are defined, 
%      count their number and store in |\l_@@_nr_of_units_int|
%   \item Use |\cs_generate_from_arg_count:NNnn| to create the commands
%      that store the final parsed unit-keys, unit-symbols und unit-formulas inside.
%   \item Prepare for the following loop.
%   \item The main part: Do the loop.
%   \item Declare keys and store their formula relation into a property-list.
%   \item Clean up.
% \end{enumerate}
%    \begin{macrocode}
\cs_new:Npn \@@_declare_cooking_derivative:nnnn #1#2#3#4
  {
    \seq_clear:N \l_@@_list_of_units_seq
    \@@_set_state_to:n { normal }
    \clist_map_inline:nn {#1}
      {
        \@@_if_unit_defined:nNTF {##1} \l_@@_tmpa_tl
          { 
            \@@_if_unit_has_a_key:VTF \l_@@_tmpa_tl
              { \seq_put_right:NV \l_@@_list_of_units_seq \l_@@_tmpa_tl }
              { 
                \tl_show:n { Error-no-key-defined } {##1}
                \@@_set_state_to:n { error } 
              }
          } { \@@_set_state_to:n { error } }
      }
   \@@_if_state_equal:nT { error }
     { \use_none_delimit_by_q_recursion_stop:w }
    \int_set:Nn \l_@@_nr_of_units_int { \seq_count:N \l_@@_list_of_units_seq }
%    \end{macrocode}
%  Now we generate the functions. The first takes the unit-keys and plugs it into
%  the formula |#2| (unit-key) and |#4| (unit-symbol).
%  The second function get's the nummerical values and stores it in a sequcence.
%  Example: \\
%    Assuming |kg|, |m| and |s| with unit key |#1*#2-#3|, formula |#1*#2/#3|
%    and symbol |#1\,\sfrac{#2}{#3}|. Looping through the units, the first
%  function creates |kg*m-s|, |kg*m-min|, \dots, |oz*in-h|; and |kg\,\sfrac{m}{s}|,
%  \dots, |oz\,\sfrac{in}{h}|.
%
%  The second function creates their nummerical relation: for |kg|, |m| and |s|
%  this would be |1*1/86400|. |kg|, |in|, |s| would be |1*(36/0.9144)/86400|.
%  If we then transform the first ones |kg*m-s| into the second one |kg*in-s|
%  we will later calculate $ \frac{1*(36/0.9144)/86400}{1*1/86400} $ which will get
%  us the correct transformation. May explanation my not be very good, 
%  but it makes sense (later).
%    \begin{macrocode}
   \cs_generate_from_arg_count:NNnn \@@_create_unit:w \cs_set:Npn
     { \l_@@_nr_of_units_int } 
     { 
       \seq_gpush:Nn \g_@@_stored_derived_unit_symbol_seq {#2} 
       \seq_gpush:Nn \g_@@_stored_derived_unit_print_seq {#4}
     }
   \cs_generate_from_arg_count:NNnn \@@_create_formula:w \cs_set:Npn
     { \l_@@_nr_of_units_int } 
     { 
       \seq_gpush:Nn \g_@@_stored_derived_formula_seq {#3}
     }
%    \end{macrocode}
%  Preparing and startidoingng the loop.
%    \begin{macrocode}
    \@@_prepare_sequence_loop:
    \@@_step_loop_start:n { }
%    \end{macrocode}
%  Now we create new cooking-units with the unit-keys and unit-symbols
%  we created \emph{via} loop. As we need a \enquote{master unit} we use
%  the most right unit in the derived unit list. This is because the most right one
%  is created by the other base units.
%    \begin{macrocode}
    \seq_get_right:NN \g_@@_stored_derived_unit_symbol_seq \l_@@_curr_unit_tl
    \seq_map_inline:Nn \g_@@_stored_derived_unit_symbol_seq
      {
        \seq_pop:NN \g_@@_stored_derived_formula_seq \l_@@_tmpb_tl
        \prop_put:NnV \l_@@_derived_units_prop {##1} \l_@@_tmpb_tl
        \seq_pop:NN \g_@@_stored_derived_unit_print_seq \l_@@_tmpa_tl
%    \end{macrocode}
%  First create the unit, \emph{then} set the reference to the base unit.
%  (Else it is not yet defined)
%    \begin{macrocode}
        \exp_args:NNx \declarecookingunit  [ {symbol={\l_@@_tmpa_tl}} ] {##1}
        \tl_set_eq:cN { l_@@_base_key_unit_ ##1 _tl } \l_@@_curr_unit_tl
      }
%    \end{macrocode}
%  Clean-up. Do not know if this is necessary, but eh.
%    \begin{macrocode}
   \seq_gclear:N \g_@@_stored_derived_unit_symbol_seq
   \seq_gclear:N \g_@@_stored_derived_unit_print_seq
   \seq_gclear:N \g_@@_stored_derived_formula_seq
    \cs_undefine:N \@@_create_unit:w
    \cs_undefine:N \@@_create_formula:w
%    \end{macrocode}
%  If we had an error beforehand, we would jump to this place ignoring everything
%  inbetween.
%    \begin{macrocode}
    \use_none_delimit_by_q_recursion_stop:w 
    \q_recursion_stop
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
%    \begin{macrocode}
\cs_new:Npn \@@_prepare_sequence_loop:
  {
    \seq_map_indexed_inline:Nn \l_@@_list_of_units_seq
      {
        \prop_clear_new:c { l_@@_keys_ ##1 _prop }
        \seq_clear_new:c { l_@@_list_ ##1 _seq }
        \tl_set_eq:Nc \l_@@_curr_unit_tl { l_@@_base_key_unit_ ##2 _tl }
        \prop_set_eq:cc { l_@@_keys_ ##1 _prop } 
          { l_@@_new_cukeys_ \l_@@_curr_unit_tl _prop }
        \prop_get:cnc { l_@@_keys_ ##1 _prop } { Liste } { l_@@_list_ ##1 _seq }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
%    \begin{macrocode}
\cs_new:Npn \@@_step_loop_start:n #1
  {
    \tl_clear:N \l_@@_stored_units_tl
    \tl_clear:N \l_@@_stored_formula_tl
    \int_set:Nn \l_@@_depth_int { 1 }
    \seq_map_function:cN 
      { l_@@_list_ \int_use:N \l_@@_depth_int _seq } \@@_seq_recursive_loop_function:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
%    \begin{macrocode}
\cs_new:Npn \@@_seq_recursive_loop_function:n #1
  {
    \group_begin:
    \tl_put_right:Nn \l_@@_stored_units_tl { {#1} }
    \tl_set_eq:Nc \l_@@_original_unit_tl { l_@@_base_key_unit_ #1 _tl }
    \tl_put_right:Nx \l_@@_stored_formula_tl 
      { { (
        \exp_not:N \prop_item:Nn
        \exp_not:c { l_@@_new_cukeys_ \l_@@_original_unit_tl _prop } {#1}
      ) } }
    \int_compare:nNnTF { \l_@@_depth_int } = { \l_@@_nr_of_units_int }
      { 
        \exp_after:wN \@@_create_unit:w \l_@@_stored_units_tl 
        \exp_after:wN \@@_create_formula:w \l_@@_stored_formula_tl
      }{
        \int_incr:N \l_@@_depth_int
        \seq_map_function:cN 
          { l_@@_list_ \int_use:N \l_@@_depth_int _seq } \@@_seq_recursive_loop_function:n
      }
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
%    \begin{macrocode}
\keys_define:nn { cooking-units }
  {
    unknown .code:n = 
      { 
        \@@_if_key_ais_derived_unit:VTF \l_keys_key_str
          { \@@_convert_derived_unit:Vn \l_keys_key_str {#1} }
          {
            \msg_error:nnxx { cooking-units } { key-unknown } 
              { \l_keys_path_str } { cooking-units } 
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_key_ais_derived_unit:n #1 { TF }
  {
    \tl_if_exist:cTF { l_@@_base_key_unit_ #1 _tl }
      { \prg_return_true: }
      { \prg_return_false: }
  }
\cs_generate_variant:Nn \@@_if_key_ais_derived_unit:nTF { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} { \@@_declare_cooking_derivative:nnnn }
% The idea is the following. The relation between the units are given as 
% |(#1)/(#2)| (e.g.). The idea is the following:
% \begin{enumerate}
%   \item The derivative contains two units.
%   \item The mathematical relationship is given by |(#1)/(#2)|
%   \item Define |\@@_tmp:w| to be |(#1)/(#2)|.
%   \item Parse through all values and store them in a list (e.g. |\l_tmpa_t|) as | {value-1}{value-2} |
%   \item Use |\exp_after:wN \@@_tmp:w \l_tmpa_t | to expand to |\@@_tmp:w {value-1} {value-2} |
%  \item Let |\@@_tmp:w| do its job.
% \end{enumerate}
%    \begin{macrocode}
\cs_new:Npn \@@_convert_derived_unit:nn #1#2
  {
    \tl_if_eq:ccTF 
      { l_@@_base_key_unit_ #1 _tl }
      { l_@@_base_key_unit_ #2 _tl }
      { 
        \prop_get:NnN \l_@@_derived_units_prop {#1} \l_@@_tmpa_tl
        \prop_get:NnN \l_@@_derived_units_prop {#2} \l_@@_tmpb_tl
        \prop_put:Nnn \l_@@_change_unit_prop {#1} {#2}
        \@@_tl_eval:cn { l_@@_unit_change_ #1 _tl }
          {
            (\l_@@_tmpb_tl) / (\l_@@_tmpa_tl)
          }
        \prop_gput:Nnv \g_@@_master_changer_prop 
          { #1 ~->~ #2 } 
          { l_@@_unit_change_ #1 _tl }
      }{
        \msg_error:nnnn { cooking-units } { key-no-knows-value } {#1} {#2}
      }
  }
\cs_generate_variant:Nn \@@_convert_derived_unit:nn { V }
%    \end{macrocode}
% \end{macro}
% 
%
%
%
%
%
%
% \section {Names}
%
% Stolen from \pkg{l3keys.dtx}
%    \begin{macrocode}
\tl_new:N \l_@@_sanitise_tl
\cs_new_protected:Npn \@@_sanitise_aux:w #1 \q_mark
  { \tl_set:Nn \l_@@_sanitise_tl {#1} }
\group_begin:
  \char_set_catcode_active:n { `\< }
  \char_set_catcode_active:n { `\> }
  \cs_new:Npn \@@_sanitize_open_arrow:
    {
      \exp_after:wN \@@_sanitize_open_arrow_auxi:w \l_@@_sanitise_tl
        \q_mark < \q_nil <
      \exp_after:wN \@@_sanitise_aux:w \l_@@_sanitise_tl
    }
  \cs_new_protected:Npn \@@_sanitize_open_arrow_auxi:w #1 <
    {
      \tl_set:Nn \l_@@_sanitise_tl {#1}
      \@@_sanitize_open_arrow_auxii:w
    }
  \cs_new_protected:Npn \@@_sanitize_open_arrow_auxii:w #1 <
    {
      \quark_if_nil:nF {#1}
        {
          \tl_set:Nx \l_@@_sanitise_tl
            {
              \exp_not:V \l_@@_sanitise_tl
              \token_to_str:N <
              \exp_not:n {#1}
            }
          \exp_after:wN \@@_sanitize_open_arrow_auxii:w
        }
    }
  \cs_new:Npn \@@_sanitize_close_arrow:
    {
      \exp_after:wN \@@_sanitize_close_arrow_auxi:w \l_@@_sanitise_tl
        \q_mark > \q_nil >
      \exp_after:wN \@@_sanitise_aux:w \l_@@_sanitise_tl
    }
  \cs_new_protected:Npn \@@_sanitize_close_arrow_auxi:w #1 >
    {
      \tl_set:Nn \l_@@_sanitise_tl {#1}
      \@@_sanitize_close_arrow_auxii:w
    }
  \cs_new_protected:Npn \@@_sanitize_close_arrow_auxii:w #1 >
    {
      \quark_if_nil:nF {#1}
        {
          \tl_set:Nx \l_@@_sanitise_tl
            {
              \exp_not:V \l_@@_sanitise_tl
              \token_to_str:N >
              \exp_not:n {#1}
            }
          \exp_after:wN \@@_sanitize_close_arrow_auxii:w
        }
    }
\group_end:
\cs_new_protected:Npn \@@_sanitize_arrows:n #1
  {
    \tl_set:Nn \l_@@_sanitise_tl {#1}
    \@@_sanitize_open_arrow:
    \@@_sanitize_close_arrow:
  }
%    \end{macrocode}
%
%
% \begin{macro}{\cudefinename}
%  This command allows to (re)define \enquote{names} for units to be used
%  in \cCutext\ for given language. We need to sanitize the arrows (|<| and |>|)
%  in case they are active. Afterwards, parse through the list.
%    \begin{macrocode}
\NewDocumentCommand \cudefinename { m m }
  {
    \tl_set:Nn \l_@@_language_tl {#1}
    \@@_sanitize_arrows:n {#2}
    \exp_after:wN 
    \@@_parse_definename_start_cycle: \l_@@_sanitise_tl
      \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
%    \end{macrocode}
% \end{macro}  
%
% \begin{macro}{\@@_parse_definename_start_cycle:}
%  Initializes the parse cycle. Set state to \enquote{normal} and clear some variables.
%  Start by grabbing the first argument which is the unit.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_definename_start_cycle:
  { 
    \@@_set_state_to:n { normal }
    \tl_clear:N \l_@@_curr_unit_tl
    \prop_clear:N \l_@@_tmpa_prop
    \bool_set_false:N \l_@@_tmpa_bool
    \@@_parse_definename_unit:n 
  }  
%    \end{macrocode}
% \end{macro}  
% \begin{macro}{ \@@_parse_definename_unit:n }
%  Grab the unit. This can be either an actual unit (defined by |\newcookingunit| and Co.)
%  or it is one of the allowed \enquote{special-keys} like \enquote{decimal-marker},
%  etc. In case neither of those two is found, issue an error, but continue parsing
%  to catch more errors. 
%  
%  The next optional argument is the unit-symbol, which can also be set by this
%  command. If it is not found, grab the next mandatory argument, which is the
%  unit-name.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_definename_unit:n #1
  {
    \quark_if_recursion_tail_stop:n {#1} 
    \seq_if_in:NnTF \g_@@_allowed_special_keys_seq {#1}
      { 
        \@@_set_unit:Nn \l_@@_curr_unit_tl {#1} 
        \bool_set_true:N \l_@@_tmpa_bool
      }{
        \@@_error_if_unit_not_defined:nNT {#1} \l_@@_curr_unit_tl 
          { \@@_set_state_to:n { error } }
      }
    \peek_meaning_ignore_spaces:NTF [
      { \@@_parse_definename_optional_unitsymbol:w }
      { \@@_parse_definename_singular:n }  
  }
%    \end{macrocode}
% \end{macro}  
%
% \begin{macro}{ \@@_parse_definename_optional_unitsymbol:w }
%  The frst optional argument has be found; it is thus the unit-symbol.
%  Changing the unit-symbol is only allowed for actual units, so no \enquote{special-keys}
%  allowed. If we have an unit, store it into |\l_@@_tmpa_prop|.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_definename_optional_unitsymbol:w [#1]
  { 
    \bool_if:NTF \l_@@_tmpa_bool
      {
        \@@_set_state_to:n { error }
        \msg_error:nnxn { cooking-units } { symbol-and-special-keys-error } 
          \l_@@_curr_unit_tl {#1}
      }
      { \prop_put:Nnn \l_@@_tmpa_prop { unit-symbol } {#1} }
    \@@_parse_definename_singular:n
  }
%    \end{macrocode}
% \end{macro}  
%
% \begin{macro}{ \@@_parse_definename_singular:n }
%  Parses the \enquote{name} of the unit (or special key).
%  Do an error check, store the input in the property list and go to the
%  next one, which is the plural form. The next (optional) argument is 
%  the plural form of the \enquote{name}. If there is none, also use |#1| for plural.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_definename_singular:n #1
  {
    \quark_if_recursion_tail_stop_do:nn {#1} 
      { \msg_error:nn { cooking-units } { missing-argument } }
    \prop_put:Nnn \l_@@_tmpa_prop { name } {#1}
    \peek_meaning_ignore_spaces:NTF [
      { \@@_parse_definename_optional_plural:w }
      { \@@_parse_definename_optional_plural:w [#1] }
  }
%    \end{macrocode}
% \end{macro}  
%
% \begin{macro}{ \@@_parse_definename_optional_plural:w }
%  Nothing new here. The next one is the gender. If no gender is found
%  I assume it to be male \enquote{m}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_definename_optional_plural:w [#1]
  {
    \prop_put:Nnn \l_@@_tmpa_prop { name-pl } {#1}
    \peek_meaning_ignore_spaces:NTF <
      { \@@_parse_definename_optional_gender:w  }
      { \@@_parse_definename_optional_gender:w <m> }
  }
%    \end{macrocode}
% \end{macro}  
%
% \begin{macro}{ \@@_parse_definename_optional_plural:w }
%  Check if the gender is correct. Then store it in the property-list
%  and finish the cycle. 
%    \begin{macrocode}
\cs_new:Npn \@@_parse_definename_optional_gender:w <#1>
  {
    \@@_if_gender_error:nT {#1} 
      { \@@_set_state_to:n { error } }
    \prop_put:Nnn \l_@@_tmpa_prop { gender } {#1}
    \@@_parse_name_finish_cycle_and_start_new:VV 
      \l_@@_language_tl \l_@@_curr_unit_tl
  }
%    \end{macrocode}
% \end{macro}  
%
% \begin{macro}{ \@@_parse_name_finish_cycle_and_start_new:nn }
%  Now it makes sense why we used property list before. 
%  Each unit has some basic definitions for each language (see |\newcookingunit| and Co.):
%  \enquote{unit-symbol}, \enquote{name}, \enquote{name\_pl} and \enquote{gender}.
%
%  So going through the property list (where we stored the given values)
%  we set for the given language and unit those definitions (\enquote{unit-symbol} only
%  if found).
%
%  Afterwards, start the next cycle.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_name_finish_cycle_and_start_new:nn #1#2
  {
    \@@_if_state_equal:nT { normal }
      {
        \prop_map_inline:Nn \l_@@_tmpa_prop
          { \@@_culang_def_for:nnnn {#1} {##1} {#2} {##2} }
      }
    \@@_parse_definename_start_cycle:
  }
\cs_generate_variant:Nn \@@_parse_name_finish_cycle_and_start_new:nn { VV }
%    \end{macrocode}
% \end{macro}  
%
% \subsection {cudefinesymbol}
%
% \begin{macro}{ \cudefinesymbol }
%  A small and rather straightforward command.
%  No special sanitizing here, just setting the language and parsing.
%    \begin{macrocode}
\NewDocumentCommand \cudefinesymbol { m m }
  {
    \tl_set:Nn \l_@@_language_tl {#1}
    \@@_cuprint_define_printed_unit:nn #2
    \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_cuprint_define_printed_unit:nn }
%  Sets the symbol for given units or \enquote{special keys}.
%  Nothing extraordinary is done here. We we have an unit we
%  set its \enquote{unit-symbol} for given language, for an \enquote{special key}
%  we set its name. Rinse and repeat.
%    \begin{macrocode}
\cs_new:Npn \@@_cuprint_define_printed_unit:nn #1#2
  {
    \quark_if_recursion_tail_stop:n {#1} 
    \quark_if_recursion_tail_stop_do:nn {#2} 
      { \msg_error:nn { cooking-units } { missing-argument } }
    \seq_if_in:NnTF \g_@@_allowed_special_keys_seq {#1} 
      { \@@_culang_def_for:Vnnn \l_@@_language_tl { name } }
      {
        \@@_error_if_unit_not_defined:nTF {#1} 
          { \use_none:nn }
          { \@@_culang_def_for:Vnnn \l_@@_language_tl { unit-symbol } }
      }
     {#1} {#2}
    \@@_cuprint_define_printed_unit:nn
  }  
%    \end{macrocode}
% \end{macro}
%
%
% \subsection {Phrases}
%
%
%
% \begin{macro}{ \@@_cuprint_define_printed_unit:nn }
%  Defining phrases. Phrases (sadly) depend on the language. 
%  The idea is going to be: Each language has its own property list
%  which is going to be stored for each language. Later, the property
%  list is recoverd for the language currently used. If no phrase is defined
%  the fallback |\q_@@_no_translation| is returned.
%    \begin{macrocode}
\@@_culang_def_base:nnn { phrase } { phrase-prop } { \q_@@_no_translation }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \cudefinephrase }
%  Defining some phrases. This command is just a wrapper for the
%  subcommand.
%    \begin{macrocode}
\NewDocumentCommand \cudefinephrase { m m }
  {
    \@@_new_cuphrase_add:nn {#1} {#2}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_cuphrase_add:nn }
%  |#1| is the language, |#2| is something to be parsed.
%  I am also not quite happy with this construction, but it works.
%
%  First, check if we already have existing phrases for the language.
%  If so, recover it, we add the parsed one to them. Else, clear
%  some variables.
%
%  Next step, sanitize |<| and |>|. I hate this so much.
%
%  Using |\@@_parse_phrase:V| we parse through the argument |#2|.
%  The results are added to |\l_@@_phrase_prop| and |\l_@@_phrase_numbers_seq|.
%
%  By our rules, we prefer big numbers over small ones. For example, 
%  120 can be translated into \enquote{2 Schocks} ($2\times60$) or
%  \enquote{10 Dutzend} ($10\times12$). We prefer the bigger number first,
%  so we will always get \enquote{2 Schocks}. Thus we sort the numbers in the
%  sequence from highest to lowest. We also have negative numbers (phrases only
%  used for one specific number). We prefer the negative over the positive ones
%  if possible.
%
%  Then store the variables and thats it.
%    \begin{macrocode}
\cs_new:Npn \@@_new_cuphrase_add:nn #1#2
  {
    \tl_set:Nn \l_@@_language_tl {#1}
    \@@_culang_if_translation_exists_for:VnnTF \l_@@_language_tl 
      { phrase } { phrase-prop }
      {  
        \@@_culang_let_for:VnnN \l_@@_language_tl { phrase } { phrase-prop }
          \l_@@_phrase_prop
        \prop_get:NnN \l_@@_phrase_prop { seq } \l_@@_phrase_numbers_seq
      }{
        \prop_clear:N \l_@@_phrase_prop
        \seq_clear:N \l_@@_phrase_numbers_seq
      }
      \@@_sanitize_arrows:n {#2}
      \@@_parse_phrase:V \l_@@_sanitise_tl
      \@@_new_cuphrase_sort_sequence:N \l_@@_phrase_numbers_seq
      \prop_put:NnV \l_@@_phrase_prop { seq } \l_@@_phrase_numbers_seq
      \@@_culang_def_for:VnnV 
        \l_@@_language_tl { phrase } { phrase-prop } \l_@@_phrase_prop
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_phrase:n }
%  Wrapper around the parsing cycles. Nothing new.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_phrase:n #1
  {
    \@@_parse_phrase_start_cycle: #1
      \q_recursion_tail \q_recursion_tail \q_recursion_stop
  }
\cs_generate_variant:Nn \@@_parse_phrase:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_phrase_start_cycle: }
%  Starts the parsing cycle. Clear some variables, set state to normal.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_phrase_start_cycle:
  {
    \@@_set_state_to:n { normal }
    \bool_set_false:N \l_@@_tmpa_bool
    \tl_clear:N \l_@@_curr_unit_tl
    \prop_clear:N \l_@@_tmpa_prop
    \@@_parse_stuff_mandatories_plus_star:nn
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_stuff_mandatories_plus_star:nn }
%  Now. We have two cases: two mandatroy arguments following each other
%  (number plus phrase) \emph{or} number plus star plus phrase (so three arguments).
%  In order to not need explicetly test for the star I do the following:
%  Just grab the first two things. |#1| is always the number. |#2| can either be
%  the star |*| \emph{or} a phrase. If it is a star, set a boolean, and restart the command
%  with |#1| already given.
%
%  Then check if |#2| is a number (with a primitve test). Star-numbers are stored
%  negatively. This makes defining a property list easier for me.
%
%  Note that the key in the first |\l_@@_tmpa_prop| is empty. This is done
%  in order to not screw up the later |\prop_map_inline| loop. We also store
%  if the phrase is only used for one number (aka.\ if there is a star).
%
%  Then, parse the optionals.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_stuff_mandatories_plus_star:nn #1#2
  {
    \quark_if_recursion_tail_stop:n {#1}
    \quark_if_recursion_tail_stop_do:nn {#2} 
      { \msg_error:nn { cooking-units } { missing-argument } }
    \str_if_eq:nnTF {#2} { * }
      {
        \bool_set_true:N \l_@@_tmpa_bool
        \@@_parse_stuff_mandatories_plus_star:nn {#1} 
      }{
        \@@_if_evaluation_is_integer:nTF {#1} 
          {
            \int_set:Nn \l_@@_tmpa_int {#1}   
            \tl_set:NV \l_@@_curr_unit_tl \l_@@_tmpa_int
            \bool_if:NT \l_@@_tmpa_bool
              { \tl_put_left:Nn \l_@@_tmpa_bool { - } }    
          }{
            \@@_set_state_to:n { error } 
            \msg_error:nnn { cooking-units} { phrase-unit-not-an-integer } {#1}
          }
        \prop_put:Nnn \l_@@_tmpa_prop { } {#2}
        \prop_put:NnV \l_@@_tmpa_prop { - singlebool } \l_@@_tmpa_bool
        \@@_parse_phrase_optionals:n {#2}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_phrase_optionals:n }
%  Get the plural form of the phrase. If the next token is an open bracket,
%  get the plural form, else set the plural form equal to the singular form.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_phrase_optionals:n #1
  {
    \peek_meaning_ignore_spaces:NTF [
      { \@@_parse_stuff_plural:w }
      { \@@_parse_stuff_plural:w [#1] }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_cuphrase_add:nn }
%  Store the pluarl form in the property list.
%  Next, parse gender. Pretty much the same as before. By default we use
%  a male gender.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_stuff_plural:w [#1]
  {
    \prop_put:Nnn \l_@@_tmpa_prop { -pl } {#1}
    \peek_meaning_ignore_spaces:NTF <
      { \@@_parse_stuff_gender:w }
      { \@@_parse_stuff_gender:w  <m> }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_cuphrase_add:nn }
%  Check if the gender-input is correct, add it to the property list.
%  Then finish the cycle and start a new one.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_stuff_gender:w <#1>
  {
    \@@_if_gender_error:nTF {#1}
      { \@@_set_state_to:n { error } }
      { \prop_put:Nnn \l_@@_tmpa_prop { -gender } {#1} }
    \@@_parse_phrase_finish_cycle_and_start_anew:V \l_@@_curr_unit_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_parse_phrase_finish_cycle_and_start_anew:n }
%  If not errors were found: Add the number to the other numbers (if not already inside).
%  Afterwards map through the property list and set the variations for each number.
%  
%  As an example, if we had \enquote{12}, |\l_@@_phrase_prop| would then contain
%  the keys \enquote{12}, \enquote{12-pl}, \enquote{12-gender}, \enquote{12-singlebool}.
%    \begin{macrocode}
\cs_new:Npn \@@_parse_phrase_finish_cycle_and_start_anew:n #1
  {
    \@@_if_state_equal:nT { normal }
      {
        \seq_if_in:NnF \l_@@_phrase_numbers_seq {#1}
          { \seq_put_right:Nn \l_@@_phrase_numbers_seq {#1} }
        \prop_map_inline:Nn \l_@@_tmpa_prop
          { 
            \prop_put:Nnn \l_@@_phrase_prop { #1 ##1 } {##2} 
          }
      }
    \@@_parse_phrase_start_cycle:
  }
\cs_generate_variant:Nn \@@_parse_phrase_finish_cycle_and_start_anew:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \@@_new_cuphrase_sort_sequence:N }
%  Sorting the sequence of numbers from highest to lowest (in absolute values).
%  And if two absolute values are equal, negative numbers are preferred over
%  positive ones.
%    \begin{macrocode}
\cs_new:Npn \@@_new_cuphrase_sort_sequence:N #1
  {
    \seq_sort:Nn #1
      {
        \int_set:Nn \l_@@_tmpa_int { \int_abs:n {##1} }
        \int_set:Nn \l_@@_tmpb_int { \int_abs:n {##2} }
        \int_compare:nNnTF { \l_@@_tmpa_int } < { \l_@@_tmpb_int }
          { \sort_return_swapped: }
          { 
            \int_compare:nNnTF { \l_@@_tmpa_int } > { \l_@@_tmpb_int }
              { \sort_return_same: }
              {
                \prop_get:NnN \l_@@_phrase_prop { ##1 - singlebool } \l_@@_tmpa_int
                \int_compare:nNnTF { \l_@@_tmpa_int } = { 1 }
                  { \sort_return_same: }
                  { \sort_return_swapped: }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{ \cudefinephrase }
%    \begin{macrocode}
%\NewDocumentCommand \cudefinephrase { m m }
%  {
%%    \@@_cuphrase:nn {#1} {#2}
%  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Old stuff}
%
% \begin{macro} {  }
%    \begin{macrocode}
\cs_new:Npn \@@_old_cutext:nnn #1#2#3
  {
    \tl_set_eq:NN \l_@@_option_unit_tl \l_@@_original_unit_tl
    \@@_old_cutext_default:nnn {#1} {#2} {#3}
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro} { \@@_old_cutext_default:nnn }
% \changes {2016/06/11} {0.98a} { New command }
%    \begin{macrocode}
\cs_new:Npn \@@_old_cutext_default:nnn #1#2#3
  {
    \bool_if:NTF \l_@@_pckopt_draft_bool
      {#2}
      {
        \tl_set:Nn \l_@@_cutext_last_value_tl {#2}
        \tl_if_in:NVTF \l_@@_cutext_last_value_tl \l_@@_input_range_sign_tl
          { 
            \tl_replace_once:NVn \l_@@_cutext_last_value_tl 
              \l_@@_input_range_sign_tl { \q_@@_range } 
            \@@_old_cutext_parse_range:Vn \l_@@_cutext_last_value_tl {#3} 
          }{
            \@@_old_cutext_print_input:Nn \l_@@_cutext_last_value_tl {#3}
          }
      }
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_old_cutext_print_input:Nn #1#2
  {
    \@@_old_cutext_if_numeral_is_int_and_parse_and_smaller_then_print_numerals:NTF #1
      {
        \int_compare:nNnTF {#1} = { 1 }
          {
            \@@_culang_one_let:NnT \l_@@_translation_tmpa_tl {#2}
              {
                \bool_if:NT \l_@@_cutext_uppercase_word_bool
                  {
                    \text_uppercase:x { \tl_head:V \l_@@_translation_tmpa_tl }
                    \tl_tail:V 
                  }
              }
            \l_@@_translation_tmpa_tl
          }{ 
            \bool_if:NTF \l_@@_cutext_uppercase_word_bool
              { \@@_print_Numeral:V #1 }
              { \@@_print_numeral:V #1 }
          }
      }
      { \@@_print_numerical_input:N #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro} {\@@_old_cutext_if_numeral_is_int_and_parse_and_smaller_then_print_numerals:N}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_old_cutext_if_numeral_is_int_and_parse_and_smaller_then_print_numerals:N #1 { TF }
  {
    \bool_if:NTF \l_@@_lokal_numeral_bool
      {
        \@@_if_integer:VTF #1
          {
            \int_compare:nNnTF {#1} < { \l_@@_print_numerals_below_int }
              { \prg_return_true: }
              { \prg_return_false: }
          }{ \prg_return_false: }
      }{ \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new:Npn \@@_old_cutext_parse_range:nn #1 #2
  {
    \@@_old_cutext_parse_range_aux:nww {#2} #1 \q_stop
  }
\cs_generate_variant:Nn \@@_old_cutext_parse_range:nn { V }
\cs_new:Npn \@@_old_cutext_parse_range_aux:nww #1 #2 \q_@@_range #3 \q_stop
  {
    \tl_set:Nn \l_@@_tmpa_tl {#2}
    \tl_set:Nn \l_@@_cutext_last_value_tl {#3}
    \@@_old_cutext_print_input:Nn \l_@@_tmpa_tl {#1}
    \tl_use:N \l_@@_cutext_range_sign_tl
    \@@_old_cutext_print_input:Nn \l_@@_cutext_last_value_tl {#1}
  }
%    \end{macrocode} 
%
%
% \begin{macro}{\@@_cuam_old:n}
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_old:n #1
  {
    \tl_set_rescan:Nnn \l_@@_tmpa_tl
      {
        \char_set_catcode_letter:N \_ %
        \char_set_catcode_ignore:N\ %
      } {#1}
    \bool_if:NTF \l_@@_pckopt_draft_bool
      { \l_@@_tmpa_tl }
      { \@@_cuam_old_parse:V \l_@@_tmpa_tl }
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cuam_old_parse:n #1
  {
    \tl_if_in:nVTF {#1} \l_@@_input_range_sign_tl
      {
        \tl_set:Nn \l_@@_tmpa_tl {#1}
        \tl_replace_once:NVn \l_@@_tmpa_tl \l_@@_input_range_sign_tl { \q_@@_range }
        \@@_cuam_old_parse_range:V \l_@@_tmpa_tl
      }{
        \tl_if_in:nnTF {#1} { / }
          {
            \tl_if_in:nnTF {#1} { _ }
              { \@@_cuam_old_parse_mixed_frac:www #1 \q_stop }
              { \@@_cuam_old_parse_frac:ww #1 \q_stop }
          }{ 
            \tl_if_in:nnTF {#1} { _ }
              { \msg_error:nnn { cooking-units } { missing-slash } {#1} }
              { \@@_cuam_old_parse_scale:n {#1} }
          }
      }
  }
\cs_generate_variant:Nn \@@_cuam_old_parse:n { V }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_old_parse_range:n #1
  {
    \@@_cuam_old_parse_range_aux:ww #1 \q_nil
  }
\cs_generate_variant:Nn \@@_cuam_old_parse_range:n { V }
\cs_new:Npn \@@_cuam_old_parse_range_aux:ww #1 \q_@@_range #2 \q_nil
  {
    #1 \l_@@_cunum_range_sign_tl #2
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_old_parse_scale:n #1 {#1}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_old_parse_frac:ww #1/#2 \q_stop
  { \@@_frac:nn {#1} {#2} }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Npn \@@_cuam_old_parse_mixed_frac:www #1_#2/#3 \q_stop
  { 
    #1 
    \skip_horizontal:N \l_@@_mixed_frac_dim
    \@@_frac:nn {#2} {#3} 
  }
%    \end{macrocode}
%
%
% \subsubsection {cufrac}
%
% Obsolete.
%    \begin{macrocode}
\NewDocumentCommand \cufrac { O{} m }
  {
    \msg_error:nnnn { cooking-units } { obsolete-command } { \cufrac } { \cuam }
    \group_begin:
    \tl_if_empty:nF {#1}
      { \keys_set:nn { cooking-units } {#1} }
    \@@_cufrac:n {#2}
    \group_end:
  }
\cs_new:Npn \@@_cufrac:n #1
  {
    \tl_set_rescan:Nnn \l_@@_tmpa_tl
      {
        \char_set_catcode_letter:N \_ %
        \char_set_catcode_ignore:N\ %
      } {#1}
    \@@_cufrac_parse:V \l_@@_tmpa_tl
  }
\cs_new:Npn \@@_cufrac_parse:n #1
  {
    \tl_if_in:nnTF {#1} { / }
      {
        \tl_if_in:nnTF {#1} { _ }
          { \@@_cufrac_parse_mixed_frac:www #1 \q_stop }
          { \@@_cufrac_parse_frac:ww #1 \q_stop }
      }{ 
        \tl_if_in:nnTF {#1} { _ }
          { \msg_error:nnn { cooking-units } { missing-slash } {#1} }
          { \@@_cufrac_parse_scale:n {#1} }
      }
  }
\cs_generate_variant:Nn \@@_cufrac_parse:n { V }
\cs_new:Npn \@@_cufrac_parse_scale:n #1 {#1}
\cs_new:Npn \@@_cufrac_parse_frac:ww #1/#2 \q_stop
  { \@@_frac:nn {#1} {#2} }
\cs_new:Npn \@@_cufrac_parse_mixed_frac:www #1_#2/#3 \q_stop
  { 
    #1 
    \skip_horizontal:N \l_@@_mixed_frac_dim
    \@@_frac:nn {#2} {#3} 
  }
%    \end{macrocode}
%
%
%
%
%
%
%
% \subsection {cusetup}
%
%    \begin{macrocode}
\NewDocumentCommand \cusetup { m }
  {
    \keys_set:nn { cooking-units } {#1}
  }
%    \end{macrocode}
%
%
%
% \subsection{Definitions et all}
%
% Plase note that at his point we are still inside the Expl3 \enquote{Environment}
% and that spaces are ignored!
%
%    \begin{macrocode}
\newcookingunit { kg }
\newcookingunit { dag }
\newcookingunit { g }
\newcookingunit { oz }
\newcookingunit { lb }
\newcookingunit { stick }
\newcookingunit [ 
  symbol={\ensuremath{ \@@_frac:nn { eV } { c^2 } } } ,
  natural-unit
  ] { eVc-2 }
%    \end{macrocode}
%
%    \begin{macrocode}
\newcookingunit { K }
\newcookingunit [ \ensuremath{ {} ^ { \circ } } \kern-\scriptspace C ]  { C }
\newcookingunit [ \ensuremath{ {} ^ { \circ } } \kern-\scriptspace F ] { F }
\newcookingunit [ \ensuremath{ {} ^ { \circ } } \kern-\scriptspace R\'{e} ] { Re }
%    \end{macrocode}
%
%    \begin{macrocode}
\newcookingunit { d }
\newcookingunit { h }
\newcookingunit { min }
\newcookingunit { s }
\newcookingunit [ 
    symbol={\ensuremath{ \@@_frac:nn { \hbar } { eV } } }, 
    natural-unit
  ] { hbareV-1 }
%    \end{macrocode}
%
%    \begin{macrocode}
\newcookingunit { m }
\newcookingunit { cm }
\newcookingunit { dm }
\newcookingunit { mm }
\newcookingunit { in }
\newcookingunit [ 
    symbol={ \ensuremath{ \@@_frac:nn { c\hbar } { eV } } } ,  natural-unit
  ] { chbareV-1 }
%    \end{macrocode}
%
%    \begin{macrocode}
\newcookingunit { l }
\newcookingunit { dl }
\newcookingunit { cl }
\newcookingunit { ml }
\newcookingunit [ 
    symbol={ \ensuremath { \@@_frac:nn { c^3 \hbar^3 } { eV^3 } } },  natural-unit
  ] { (chbareV-1)3 }
%    \end{macrocode}
%
%    \begin{macrocode}
\newcookingunit { cal }
\newcookingunit { kcal }
\newcookingunit { J }
\newcookingunit { kJ }
\newcookingunit [ natural-unit ] { eV }
%    \end{macrocode}
%
%    \begin{macrocode}
\newcookingunit [ pinch ] { pn }
\newcookingunit { EL }
\newcookingunit { TL }
\newcookingunit [ ssp. ] { ssp } %% saltspoonful
\newcookingunit [ csp. ] { csp } %% coffeespoonful
\newcookingunit [ dsp. ] { dsp }
\newcookingunit [ Msp. ] { Msp }
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareLanguageAlias { AmericanEnglish } { American }
%    \end{macrocode}
%
%    \begin{macrocode}
\cudefinename { German }
  {
    { kg } { Kilogramm } < n >
    { dag } { Dekagramm } < n >
    { g } { Gramm } < n >
    { oz } { Unze } < f >
    { lb } { Pfund } < n >
%    \end{macrocode}
%    \begin{macrocode}
    { d } { Tag } [ Tage ]
    { h } { Stunde } [ Stunden ] < f >
    { min } { Minute } [ Minuten ] < f >
    { s } { Sekunde } [ Sekunden ] < f >
%    \end{macrocode}
%    \begin{macrocode}
    { C } { Grad \space Celsius } 
    { K } { Kelvin } < n >
    { F } { Grad \space Fahrenheit }
    { Re } { Grad \space R\'{e}amur }
%    \end{macrocode}
%    \begin{macrocode}
    { m } { Meter } < n >
    { dm } { Dezimeter } < n >
    { cm } { Centimeter } < n >
    { mm } { Millimeter } < n >
    { in } { Zoll } 
%    \end{macrocode}
%    \begin{macrocode}
    { l } [ l ] { Liter }
    { dl } { Deziliter }
    { cl } { Centiliter }
    { ml } { Milliliter }
%    \end{macrocode}
%    \begin{macrocode}
    { cal } { Kalorie } [ Kalorien ] < f >
    { kcal } { Kilokalorie } [ Kilokalorien ] < f >
    { J } { Joule }
    { kJ } { Kilojoule }
    { eV } { Elektronenvolt } < n > 
%    \end{macrocode}
%    \begin{macrocode}
    { Msp } [ Msp. ] { Messerspitze } [ Messerspitzen ] < f >
    { pn } [ Prise ] { Prise } [ Prisen ] < f >
    { EL } [ EL ] { Essl{\"o}ffel }
    { TL } [ TL ] { Teel{\"o}ffel }
    { csp } [ KL ] { Mokkal{\"o}ffel }
%    \end{macrocode}
%    \begin{macrocode}
    { decimal-mark } { , }
    { one (m) } { ein }
    { one (f) } { eine }
    { one (n) } { ein }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cudefinename { English }
  {
    { kg } { kilogramme }
    { dag } { decagramme }
    { g } { gramme }
    { oz } { ounce } 
    { lb } { pound } [ pounds ]
    { stick } { stick } [ sticks ]
%    \end{macrocode}
%    \begin{macrocode}
    { d } { day } [ days ]
    { h } { hour } [ hours ]
    { min } { minute } [ minutes ]
    { s } { second } [ seconds ]
%    \end{macrocode}
%    \begin{macrocode}
    { C } { degree \space Celsius }  [ degrees \space Celsius ]
    { F } { degree \space Fahrenheit } [ degrees \space Fahrenheit ]
    { K } { kelvin }
    { Re } { degree \space R\'{e}aumur } [ degrees \space R\'{e}aumur ]
%    \end{macrocode}
%    \begin{macrocode}
    { m } { metre } [ metres ]
    { dm } { decimetre } [ decimetres ]
    { cm } { centimetre } [ centimetres ]
    { mm } { millimitre } [ millimitres ]
    { in } { inch } [ inches ]
%    \end{macrocode}
%    \begin{macrocode}
    { l } [ \ensuremath { \ell } ] { litre } [ litres ]
    { dl } { decilitre } [ decilitres ]
    { cl } { centilitre } [ centilitres ]
    { ml } { millilitre } [ millilitres ]
%    \end{macrocode}
%    \begin{macrocode}
    { cal } { calorie } [ calories ]
    { kcal } { kilocalorie } [ kilocalories ]
    { J } { joule } [ joules ]
    { kJ } { kilojoule } [ kilojoules ]
    { eV } { electron \space volt } 
%    \end{macrocode}
%    \begin{macrocode}
%    { Msp } [ pinch ] { pinch } [ pinches ]
%    { Msp } { Messerspitze } [ Messerspitzen ] <f>
    { pn } [ pinch ] { pinch } [ pinches ]
    { EL } [ tbsp. ] { tablespoon } [ tablespoons ]
    { TL } [ tsp. ] { teaspoon } [ teaspoons ]
    { dsp } { dessertspoonful } 
    { csp } { coffeespoonful } 
    { ssp } { saltspoonful } 
%    \end{macrocode}
%    \begin{macrocode}
    { decimal-mark } { . }
    { one (m) } { one }
    { one (f) } { one }
    { one (n) } { one }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cudefinename { AmericanEnglish }
  {
    { kg } { kilogram }
    { dag } { decagram }
    { g } { gram }
    { oz } { ounce } 
%    \end{macrocode}
%    \begin{macrocode}
    { m } { meter } [ meters ]
    { dm } { decimeter } [ decimeters ]
    { cm } { centimeter } [ centimeters ]
    { mm } { millimiter } [ millimiters ]
    { in } { inch } [ inches ]
%    \end{macrocode}
%    \begin{macrocode}
    { l } [ \ensuremath { \ell } ] { liter } [ liters ]
    { dl } { deciliter } [ deciliters ]
    { cl } { centiliter } [ centiliters ]
    { ml } { milliliter } [ milliliters ]
%    \end{macrocode}
%    \begin{macrocode}
%    { Msp } { Messerspitze } [ Messerspitzen ] <f>
    { pn } [ pn. ] { pinch } [ pinches ]
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cudefinename { French }
  {
    { kg } { kilogramme } [ kilogrammes ]
    { dag } { d\'{e}cagramme } [ d\'{e}cagrammes]
    { g } { gramme } [ gramme ]
    { oz } { once } < f >
    { lb } { livre } [ livres ] < f >
%    \end{macrocode}
%    \begin{macrocode}
    { d } { jour } [ jours ]
    { h } { heure } [ heures ] < f >
    { min } { minute } [ minutes ] < f >
    { s } { seconde } [ secondes ] < f >
%    \end{macrocode}
%    \begin{macrocode}
    { C } { degr\'{e} \space Celsius }  [ degr\'{e}s \space Celsius ]
    { K } { degr\'{e} \space Fahrenheit } [ degr\'{e}s \space Fahrenheit ]
    { F } { kelvin } [ kelvins ]
    { Re } { \'{e}chelle \space R\'{e}aumur } [ degr\'{e}s \space R\'{e}aumur ]
%    \end{macrocode}
%    \begin{macrocode}
    { m } { m\`{e}tre } [ m\`{e}tres ]
    { dm } { d\'{e}cim\`{e}tre } [ d\'{e}cim\`{e}tres ]
    { cm } { centim\`{e}tre } [ centim\`{e}tres ]
    { mm } { millim\`{e}tre } [ millim\`{e}tres ]
    { in } [ po ] { pouce } [ pouces ]
%    \end{macrocode}
%    \begin{macrocode}
    { l } [ L ] { litre } [ litres ]
    { dl } [ dL ] { d\'{e}cilitre } [ d\'{e}cilitres ]
    { cl } [ cL ] { centilitre } [ centilitres ]
    { ml } [ mL ] { millilitre } [ millilitres ]
%    \end{macrocode}
%    \begin{macrocode}
    { cal } { calorie } [ calorie ]
    { kcal } { kilocalorie } [ kilocalories ]
    { J } { joule } [ joules ]
    { kJ } { kilojoule } [ kilojoules ]
    { eV } { \'{e}lectron-volt } [ \'{e}lectron-volts ]
%    \end{macrocode}
%    \begin{macrocode}
    { pn } { pinc\'{e}e } < f > 
    { EL } [c.\`{a}.s.] { cuill\`{e}re  \space \`{a} \space  soupe } < f >
    { TL } [c.\`{a}.c.] { cuill\`{e}re  \space \`{a} \space  caf\'{e} } < f >
%    \end{macrocode}
%    \begin{macrocode}
    { decimal-mark } { . }
    { one (m) } { un }
    { one (f) } { une }
    { one (n) } { un }
  } 
%    \end{macrocode}
%
%
%
%    \begin{macrocode}
\cudefinekeys { kg }
  {
    { dag }{ 100 }
    { g }  { 1000 }
    { lb } { 1/0.45359237 } 
    { oz } { 16/0.45359237 } 
    { stick } { 4/0.45359237 }
    { eVc-2 } { 560958865.0e+27 } %% (560958865.0 +- 3.5) e+27
  }
%    \end{macrocode}
%    \begin{macrocode}
\cudefinekeys { d }
  {
    { h }  { 24 }
    { min }{ 1440 }
    { s }  { 86400 }
    { hbareV-1 } { 151926746.1e+7 * 86400 } %% (151926746.1 +- 2.1) e+7
  }
%\cuaddtokeys { s } { hbareV-1 } { 6.582119514e-16 }
%    \end{macrocode}
%    \begin{macrocode}
\cudefinekeys { m }
  {
    { dm } { 10 }
    { cm } { 100 }
    { mm } { 1000 }
    { in } { 36/0.9144 }
    { chbareV-1 } { 5067730.759 } %% 5067730.759 +- 0.070
  }
%\cuaddtokeys { m } { chbareV-1 } { 1.97326972e-7 }
%    \end{macrocode}
%    \begin{macrocode}
\cudefinekeys { l }
  {
    { dl } { 10 }
    { cl } { 100 } 
    { ml }{ 1000 } 
    { (chbareV-1)3 } { 130148929.5e+12 * 1e-3 } %% (130148929.5 +- 5.4 e+12)*1e-3
  }
%    \end{macrocode}
%    \begin{macrocode}
\cudefinekeys { J }
  {
    { kJ }{ 1e-3 }
    { cal }{ 0.2388459 }
    { kcal }{ 0.2388459e-3 }
    { eV }{ 624150912.6e+10 } %% (624150912.6 +- 3.9) e+10
  }
%\cuaddtokeys { J } { eV } { 1.6021766208e-19 }
%    \end{macrocode}
%    \begin{macrocode}
\fp_const:Nn \c_@@_kb_eV_fp {  8.617 330 3 e-5  }
\cudefinesinglekey { C }
  {
    { K } { #1 + 273.15 }
    { F } { #1 * 1.8 + 32 }
    { Re } { #1 * 0.8 }
    { eV } { ( #1 + 273.15 ) * \c_@@_kb_eV_fp }
  }
\cudefinesinglekey { F }
  {
    { C } { ( #1 - 32 ) *  5/9 }
    { K } { ( #1 + 459.67 ) *  5/9 }
    { Re } { ( #1 - 32 ) * 4/9 }
    { eV } {( #1 + 459.67 ) *  5/9 * \c_@@_kb_eV_fp }
  }
\cudefinesinglekey { K } 
  {
    { C } { #1 - 273.15 }
    { F } { #1 * 1.8 - 459.67 }
    { Re } { ( #1 - 273.15 ) * 0.8 }
    { eV } { #1 * \c_@@_kb_eV_fp }
  }
\cudefinesinglekey { Re }
  {
    { K } { #1 * 1.25 + 273.15 }
    { C } { #1  * 1.25 }
    { F } { #1 * 2.25 + 32 }
    { eV } { ( #1 * 1.25 + 273.15 ) * \c_@@_kb_eV_fp }    
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cudefinephrase { German } 
  {  
%    { 6 } * { halbes \  Dutzend } < n >
%    { 6 }  { halbe \  Dutzend } < n >
    { 12 } { Dutzend } < n >
%    { 60 } { Schock } < n >
%    { 1728 } { Gro{\ss}gros } < n >
%    { 144 } { Gros } < n >
  }
%    \end{macrocode}
%
%
% \subsection{Finish}
%
%    \begin{macrocode}
\cudeclareunitgroup { weight } { kg , dag, g, oz, lb, stick }
\cudeclareunitgroup { length } { m , dm , cm , mm , in }
\cudeclareunitgroup { volume } { l , dl , cl  , ml }
\cudeclareunitgroup { temperature } { C , F , K , Re }
\cudeclareunitgroup { energy } { cal, kcal , J , kJ , eV }
\cudeclareunitgroup { time } { d , h , min , s }
\cusetoptionfor { F , C , K , Re } { round-precision = 0 }
\cusetup 
  { 
    curef-add-forbidden-unit = { F , C , K , Re } ,
    add-temperature-to-check =
      {
        K = 0,
        C = -273.15 ,
        F = -459.67 ,
        Re = -218.52
      } ,
    round-precision = 2 ,
  }
%\AtBeginDocument{
%\keys_define:nn { cooking-units }
%  {
%    unknown .code:n = { \tl_show:N {\l_keys_key_str} }
%  }
%  \keys_set:nn { cooking-units } {#2}
%  
%}
%    \end{macrocode}
%
%
%
%
%
%
%
%
%
%
%    \begin{macrocode}
%</package>      
%    \end{macrocode}
%
% \end{implementation}
%
%
%
% \begin{thebibliography}{}
%   \bibitem{Gattopardo} 
%     Guiseppe Tomasi di Lampedusa, \emph{Der Gattopardo},
%     Piper, Volume~8 (2018), ISBN~978-3-492-24586-9
%
%   \bibitem{Sh:3} 
%     Sir Arthur Conan Doyle, \emph{Sherlock Holmes The Complete Novels and Stories Volume~II},
%     Bantam Books
%
%  \bibitem{Nist2008} \emph{Guide for the Use of the International System of Units (SI)},
%    NIST Special Publication 811, 2008 Edition, Ambler Thompson and Barry N. Taylor
%
%  \bibitem{Nist2006} \emph{The International System of Units (SI) – Conversion Factors 
%    for General Use}, NIST Special Publication 1038, May 2006,
%    Kenneth Butcher, Linda Crown and Elizabeth J. Gentry
%
%  \bibitem{WM1985} \emph{Weights and Measures Act 1985},
%    \url{https://www.legislation.gov.uk/ukpga/1985/72}
%
%  \bibitem{StickSource} \url{https://cooking.stackexchange.com/questions/784/translating-cooking-terms-between-us-uk-au-ca-nz}
%
% \end{thebibliography}
% 
% 
%
% \endinput
%
%
%
%
% Local Variables:
% mode: doctex
% TeX-master: t
% End: